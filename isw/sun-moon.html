
<html>
<head> 
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="keywords"
content="sunrise,
    sunset,
    sunrise calculator,
    sunset calculator,
    Sun calculator,
    Sun position calculator,
    Sun position,
    Sun positions,
    moonrise,
    moonset,
    moonrise calculator,
    moonset calculator,
    Moon calculator,
    Moon position calculator,
    Moon position,
    Moon positions,
    Sun and Moon calculator,
    Sun and Moon position,
    Sun and Moon positions">

<title>Sun/Moon Calculator</title>

<!-- Version 4.6.5  7 February 2016 -->

<script type="text/javascript" src="http://gc.kis.scr.kaspersky-labs.com/5CBAA675-D13E-3B4A-BF5A-5410002C0762/main.js" charset="UTF-8"></script><script type="text/javascript" src="http://www.largeformatphotography.info/sunmooncalc/SMCalcCommon.js"></script>
<script type="text/javascript" src="http://www.largeformatphotography.info/sunmooncalc/SMCalcURLParams.js"></script>
<script type="text/javascript" src="http://www.largeformatphotography.info/sunmooncalc/SMCalcMagModel.js"></script>
<script type="text/javascript" src="http://www.largeformatphotography.info/sunmooncalc/SMCalcLocations.js"></script>
<script type="text/javascript" src="http://www.largeformatphotography.info/sunmooncalc/SMCalcLocationLookup.js"></script>
<script type="text/javascript" src="http://www.largeformatphotography.info/sunmooncalc/SMCalcDebug.js"></script>
<script type="text/javascript">
  /*
 ****************************************************************************
    Sun/Moon Calculator
    Version 4.6.5.1  29 February 2016
    Original version: 19 October 1998
 
    Copyright 1998-2015 Jeff Conrad
 ****************************************************************************
*/

// *************** global constants and variables ************************

var
	// astronomical calculation constants
    J2000 = 2451545.0,			// JD of 12:00 UT 1 Jan 2000
    EARTH_RADIUS = 6378.137,		// km
    K_REFR = 0.175,			// refraction constant @ 1010 mbar, 10 deg C

    F_CIRCUMPOLAR = 9999,		// time value when body is circumpolar
    F_SET_NO_EVENT = 999,		// event does not occur--set value
    F_TEST_NO_EVENT = 99,		// event does not occur--test value

	// calculation type
    TIMES = 0,
    POSITIONS = 1;

    // values for mag_dec_date_valid flag
var
    INVALID  = 0,	// date more than 1 year outside range
    EXTENDED = 1,	// date 0-1 year outside model range
    VALID    = 2;	// date within model range


    // error messages
var
    HM_FORMAT_MSG = "HM value (hh[:mm] [a|p[m]] or hh.nn [a|p[m]]) required",
    UT_FORMAT_MSG = "HM value (hh[:mm]) required for UT",
    DMS_LAT_FORMAT_MSG = "DMS value ([d]d[:mm[:ss]][N|S], [d]dmmss[.ss][N|S], or [d]d[.dd...][N|S]) required",
    DMS_LON_FORMAT_MSG = "DMS value ([dd]d[:mm[:ss]][E|W], [dd]dmmss[.ss][E|W], or [dd]d[.dd...][E|W]) required",
    NUMERIC_FORMAT_MSG = "Numeric value required";

	// HTML tags
var
    VSPACE = '<br><br>',
    SP = '&nbsp;',
    SP2 = SP + SP,
    SP4 = SP2 + SP2,
    PAD4 = '    ',		// indent from left margin
    PAD8 = PAD4 + PAD4,		// indent from left margin
    PAD12 = PAD8 + PAD4,	// indent from left margin
    BR = '<br>',
    EM = '<em>',
    EME = '</em>',

	// control characters
    HT = '\t',
    LF = '\n',

    BODY_COLOR = '#000040',	// text color
    BG_COLOR =   '#ffffff',	// background color

    STUB_COLOR = '#ffffff',	// background for StubColumn style
    STD_COLOR =  '#ffffff',	// background for StdColumn style
    SUN_COLOR =  '#f4f4f4',	// background for SunColumn style
    MOON_COLOR = '#ffffff',	// background for MoonColumn style

    BORDER_LT =  '1px',		// td row borders
    BORDER_MED = '1px',		// th and td column borders
    BORDER_BLD = '2px',		// table and group borders

    H_PADDING =  '0.25em',	// left and right padding for th and td
    V_PADDING =  '0.3ex',	// top and bottom padding for th and td

    RS_CENTER = '*',	// indicates that rise/set time is for center of body
    RS_LOWER  = '*',	// indicates that rise/set time is for body's lower limb

    DOCTYPE = '<!DOCTYPE html>',

    // start, end of document
    DOC_START = DOCTYPE + LF + '<html>' + LF,
    DOC_END   = LF + '</html>',

    CONTENT = '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">',

    SCRIPT = '<script>' + LF
		// popup windows for help
           + 'var flags = new Object();' + LF
	   + 'flags.use_popups = false;' + LF
		// reformat results page for printing
           + 'function reformat(type)' + LF
	   + '{' + LF
	   + '    if (!opener || opener.closed) {' + LF
	   + '        if (type == "places")' + LF
	   + '            alert(' + LF
	   + '                  "Cannot reformat: the data no longer are valid" + "\\n"' + LF
	   + '                + "Close this window and repeat the List Locations" + "\\n"' + LF
	   + '                + "You may need to restart the Sun/Moon Calculator"' + LF
	   + '            );' + LF
	   + '        else ' + LF
	   + '            alert(' + LF
	   + '                  "Cannot reformat: the data no longer are valid" + "\\n"' + LF
	   + '                + "Close this window and recalculate" + "\\n"' + LF
	   + '                + "You may need to restart the Sun/Moon Calculator"' + LF
	   + '            );' + LF
	   + '    }' + LF
	   + '    else {' + LF
	   + '        if (type == "places")' + LF
	   + '            opener.list_places("reformat")' + LF
	   + '        else' + LF
	   + '            opener.reformat_results(type)' + LF
	   + '        window.focus();' + LF
	   + '    }' + LF
	   + '}' + LF
		// set positions calculation date to date that user clicked on
		// only linked for times output
	   + 'function set_calc_date(date)' + LF
	   + '{' + LF
	   + '    if (!opener || opener.closed)' + LF
	   + '        alert(' + LF
	   + '              "Cannot set calculation date: the data no longer are valid" + "\\n"' + LF
	   + '            + "Close this window and recalculate" + "\\n"' + LF
	   + '            + "You may need to restart the Sun/Moon Calculator"' + LF
	   + '        );' + LF
	   + '    else {' + LF
	   + '        opener.set_calc_date(date);' + LF
	   + '        opener.focus();' + LF
	   + '    }' + LF
	   + '}' + LF
		// set location to place that user clicked on
	   + 'function set_place(ndx)' + LF
	   + '{' + LF
	   + '    if (!opener || opener.closed)' + LF
	   + '        alert(' + LF
	   + '              "Cannot set location: the data no longer are valid" + "\\n"' + LF
	   + '            + "Close this window and repeat the List Locations" + "\\n"' + LF
	   + '            + "You may need to restart the Sun/Moon Calculator"' + LF
	   + '        );' + LF
	   + '    else {' + LF
	   + '        opener.set_place(ndx);' + LF
           + '        opener.clearSearchPattern();' + LF
           + '        opener.setStdLocation();' + LF
	   + '        opener.focus();' + LF
	   + '    }' + LF
	   + '}' + LF
	   + 'function help(topic)' + LF
	   + '{' + LF
	   + '   var' + LF
	   + '       HelpWindow,' + LF
	   + '       url = "SunMoonCalcHelp.htm",' + LF
	   + '       title = "Help",' + LF
	   + '       wid = 0.9 * screen.availWidth,' + LF
	   + '       ht = 0.87 * screen.availHeight,' + LF
	   + '       xpos = 0.02 * screen.availWidth,' + LF
	   + '       ypos = 0.005 * screen.availHeight,' + LF
	   + '       win_size,' + LF
	   + '       win_attribs,' + LF
	   + '       win_features;' + LF
	   + '    if (topic)' + LF
	   + '        url += "#" + topic;' + LF
	   + '    if (flags.use_popups === true) {' + LF
	   + '        win_size = "height=" + ht + ",width=" + wid;' + LF
	   + '        win_pos = "left=" + xpos + "," + "top=" + ypos;' + LF
	   + '        win_attribs = "resizable=1,menubar=1,toolbar=1,status=1,scrollbars=1";' + LF
	   + '        win_features = win_size + "," + win_pos + "," + win_attribs;' + LF
	   + '        HelpWindow = window.open(url, title, win_features);' + LF
	   + '    }' + LF
	   + '    else' + LF
	   + '        HelpWindow = window.open(url, title);' + LF
	   + '    HelpWindow.focus();' + LF
	   + '    return true;' + LF
	   + '}' + LF
	   + '</' + 'script>' + LF,

    STYLE = '<style>' + LF
	  + PAD4 + 'body {' + LF
	  + PAD8 + 'margin-left: 2%;' + LF
	  + PAD8 + 'margin-right: 2%;' + LF
	  + PAD8 + 'color: ' + BODY_COLOR + ';' + LF
	  + PAD8 + 'background-color: ' + BG_COLOR + ';' + LF
	  + PAD4 + '}' + LF
	  + PAD4 + 'a.help { cursor: help; }' + LF
	  + PAD4 + 'a.dateTag, a.placeTag { cursor: pointer; }' + LF
	  + PAD4 + 'a.help:link, a.help:visited { text-decoration: none; color: ' + BODY_COLOR + '; }' + LF
	  + PAD4 + 'a.dateTag:link, a.dateTag:visited { text-decoration: none; color: #000040; }' + LF
	  + PAD4 + 'a.dateTag:hover { text-decoration: none; color: white; background: navy; }' + LF
	  + PAD4 + 'a.dateTag:active { text-decoration: none; font-style: italic; color: white; background: navy; }' + LF
	  + PAD4 + 'a.placeTag:link, a.placeTag:visited { text-decoration: none; color: #000040; }' + LF
	  + PAD4 + 'a.placeTag:hover { text-decoration: none; color: white; background: navy; }' + LF
	  + PAD4 + 'a.placeTag:active { text-decoration: none; font-style: italic; color: white; background: navy; }' + LF
	  + PAD4 + 'h2 { color: navy; }' + LF
	  + PAD4 + 'h3 { margin-top: 0; margin-bottom: 0.8ex; white-space: nowrap; color: navy; }' + LF
	  + PAD4 + 'h4 { margin-top: 1.5ex; margin-bottom: 0.2ex; color: navy; }' + LF
	  + PAD4 + 'table { border: ' + BORDER_BLD + ' solid black; border-collapse: collapse; }' + LF
	  + PAD4 + 'thead { border-bottom: ' + BORDER_MED + ' solid black; }' + LF
	  + PAD4 + 'th {' + LF
	  + PAD8 + 'border: ' + BORDER_MED + ' solid black;' + LF
	  + PAD8 + 'padding-left: ' + H_PADDING + ';' + LF
	  + PAD8 + 'padding-right: ' + H_PADDING + ';' + LF
	  + PAD8 + 'padding-top: ' + V_PADDING + ';' + LF
	  + PAD8 + 'padding-bottom: ' + V_PADDING + ';' + LF
	  + PAD4 + '}' + LF
	  + PAD4 + 'td {' + LF
	  + PAD8 + 'border-right: ' + BORDER_MED + ' solid black;' + LF
	  + PAD8 + 'border-bottom: ' + BORDER_LT + ' solid #bbb;' + LF
	  + PAD8 + 'padding-left: ' + H_PADDING + ';' + LF
	  + PAD8 + 'padding-right: ' + H_PADDING + ';' + LF
	  + PAD8 + 'padding-top: ' + V_PADDING + ';' + LF
	  + PAD8 + 'padding-bottom: ' + V_PADDING + ';' + LF
	  + PAD8 + 'white-space: nowrap;' + LF
	  + PAD4 + '}' + LF
	  + PAD4 + 'colgroup { border-right: ' + BORDER_BLD + ' solid black; }' + LF
	  + PAD4 + 'colgroup.StubColumn { background-color: ' + STUB_COLOR + '; }' + LF
	  + PAD4 + 'colgroup.SunColumn { background-color: ' + SUN_COLOR + '; }' + LF
	  + PAD4 + 'colgroup.MoonColumn { background-color: ' + MOON_COLOR + '; }' + LF
	  + PAD4 + 'colgroup.StdColumn { background-color: ' + STD_COLOR + '; }' + LF
	  + '</style>' + LF,

    // for Sun and Moon rise/set times
    // normal--not showing Moon event - Sun event time difference
    TIMES_TABLE = '<table>' + LF,
    TIMES_TABLE_DATE_COLSPEC = '<colgroup span=2 class="StubColumn">' + LF
                         + PAD4 + '<col align=left>' + LF	// day of week
                         + PAD4 + '<col align=left>' + LF,	// date

    TIMES_TABLE_SUN_COLSPEC1 = '<colgroup span=9 class="SunColumn">' + LF
                         + PAD4 + '<col align="right">' + LF	// dawn
                         + PAD4 + '<col align="right">' + LF	// Sun rise
                         + PAD4 + '<col align="right">' + LF	// Sun transit
                         + PAD4 + '<col align="right">' + LF	// Sun set
                         + PAD4 + '<col align="right">' + LF	// dusk
                         + PAD4 + '<col align="right">' + LF	// day length
                         + PAD4 + '<col align="right">' + LF	// Sun rise az
                         + PAD4 + '<col align="right">' + LF	// Sun set az
                         + PAD4 + '<col align="right">' + LF,	// Sun max alt

    TIMES_TABLE_MOON_COLSPEC1 = '<colgroup span=8 class="MoonColumn">' + LF
                         + PAD4 + '<col align="right">' + LF	// Moon rise
                         + PAD4 + '<col align="right">' + LF	// Moon transit
                         + PAD4 + '<col align="right">' + LF	// Moon set
                         + PAD4 + '<col align="right">' + LF	// Moon rise az
                         + PAD4 + '<col align="right">' + LF	// Moon set az
                         + PAD4 + '<col align="right">' + LF	// Moon max alt
                         + PAD4 + '<col align="left">'  + LF	// Moon phase
                         + PAD4 + '<col align="left">'  + LF,	// Moon SD

    // showing Moon event - Sun event time difference
    TIMES_TABLE_SUN_COLSPEC2 = '<colgroup span=13 class="SunColumn">' + LF
                         + PAD4 + '<col align="right">' + LF	// astro dawn
                         + PAD4 + '<col align="right">' + LF	// naut dawn
                         + PAD4 + '<col align="right">' + LF	// civil dawn
                         + PAD4 + '<col align="right">' + LF	// Sun rise
                         + PAD4 + '<col align="right">' + LF	// Sun transit
                         + PAD4 + '<col align="right">' + LF	// Sun set
                         + PAD4 + '<col align="right">' + LF	// civil dusk
                         + PAD4 + '<col align="right">' + LF	// naut dusk
                         + PAD4 + '<col align="right">' + LF	// astro dusk
                         + PAD4 + '<col align="right">' + LF	// day length
                         + PAD4 + '<col align="right">' + LF	// Sun rise az
                         + PAD4 + '<col align="right">' + LF	// Sun set az
                         + PAD4 + '<col align="right">' + LF,	// Sun max alt

    TIMES_TABLE_MOON_COLSPEC2 = '<colgroup span=9 class="MoonColumn">' + LF
                         + PAD4 + '<col align="right">' + LF	// Moon rise
                         + PAD4 + '<col align="right">' + LF	// Moon transit
                         + PAD4 + '<col align="right">' + LF	// Moon set
                         + PAD4 + '<col align="right">' + LF	// Moon Sun diff
                         + PAD4 + '<col align="right">' + LF	// Moon rise az
                         + PAD4 + '<col align="right">' + LF	// Moon set az
                         + PAD4 + '<col align="right">' + LF	// Moon max alt
                         + PAD4 + '<col align="left">'  + LF	// Moon phase
                         + PAD4 + '<col align="left">'  + LF,	// Moon SD

    // for Sun and Moon positions
    POS_TABLE = '<table>' + LF,
    POS_TABLE_COLSPEC =  '<colgroup span=1 class="StubColumn">' + LF
                       + PAD4 + '<col align="right">' + LF		// time
                       + '<colgroup span=4 class="SunColumn">' + LF
                       + PAD4 + '<col align="right">' + LF		// Sun az
                       + PAD4 + '<col align="right">' + LF		// Sun alt
                       + PAD4 + '<col align="right">' + LF		// Path angle
                       + PAD4 + '<col align="right">' + LF		// shadow len
                       + '<colgroup span=5 class="MoonColumn">' + LF
                       + PAD4 + '<col align="right">' + LF		// Moon az
                       + PAD4 + '<col align="right">' + LF		// Moon alt
                       + PAD4 + '<col align="right">' + LF		// Path angle
                       + PAD4 + '<col align="right">' + LF		// Moon phase
                       + PAD4 + '<col align="right">' + LF,		// Moon SD

    // for location database
    PLACES_TABLE = '<table>' + LF,
    PLACES_TABLE_COLSPEC1 =  '<colgroup span=1 class="StubColumn">' + LF
                          + PAD4 + '<col align=left>' + LF	// place name
                          + '<colgroup span=5 class="StdColumn">' + LF
                          + PAD4 + '<col align=center>' + LF	// latitude
                          + PAD4 + '<col align=center>' + LF	// longitude
                          + PAD4 + '<col align=center>' + LF	// elevation
                          + PAD4 + '<col align=center>' + LF	// magnetic declination
                          + PAD4 + '<col align=left>'   + LF,	// time zone

    PLACES_TABLE_COLSPEC2 = '<colgroup span=2 class="StdColumn">' + LF
                          + PAD4 + '<col align=left>'   + LF	// DST start rule or date
                          + PAD4 + '<col align=left>'   + LF,	// DST end rule or date

    TABLE_START = '<table>',
    TABLE_END = '</table>',
    THD = '<thead>',
    THDE = '</thead>',
    TBD = '<tbody>',
    TBDE = '</tbody>',
    TR = PAD4 + '<tr>',
    TR_R = PAD4 + '<tr align="right">',
    TRE = PAD4 + '</tr>',

    // th<rowspan><colspan>
    // indent from left margin for better human readability
    TH11 = PAD8 + "<th align=center>",
    TH21 = PAD8 + '<th align=center rowspan=2>',
    TH31 = PAD8 + '<th align=center rowspan=3>',
    TH12 = PAD8 + '<th align=center colspan=2>',
    TH13 = PAD8 + '<th align=center colspan=3>',
    TH14 = PAD8 + '<th align=center colspan=4>',
    TH15 = PAD8 + '<th align=center colspan=5>',
    TH17 = PAD8 + '<th align=center colspan=7>',
    TH18 = PAD8 + '<th align=center colspan=8>',
    TH19  = PAD8 + '<th align=center colspan=9>',
    TH113 = PAD8 + '<th align=center colspan=13>',
    THE = '</th>',

    // column alignment specs are quirk of IE
    TD =   PAD8 + '<td align="right">',
    TD12 = PAD8 + '<td colspan=2 align="center">',
    TD14 = PAD8 + '<td colspan=4 align="center">',
    TD_C = PAD8 + '<td align="center">',
    TD_L = PAD8 + '<td align="left">',
    TD_R = PAD8 + '<td align="right">',
    TDE = '</td>';

    // HTML 4 named character entities
var
    DEG = '&deg;',
    MDASH = '&mdash;',
    NDASH = '&ndash;',
    MINUS = '&minus;',
    PLUS = '+';

    // indicators for waxing/waning Moon
var
    WAXING = '+',
    WANING = '&minus;';

    // main calculation variables
var
    Today,				// Date object for today's date
    copyright,
    flags,
    form,				// main form; set by initialize_form()
    debug_window = null,		// handle for debugging console window
    mag_model,
    PRINT_STYLE,			// style setting fixed font size
    times_results,
    positions_results,
    place_list,
    SaveState,
    std_TZ_offset;

/*
 ******************************************************************************
    functions for main form
 ******************************************************************************
*/

// ************* Date properties and methods ********

Date.J1970 = 2440587.50;	// JD of 0h UT 1 Jan 1970

// set 0h LCT
Date.prototype.setZeroHours = function()
{
    this.setHours(0);
    this.setMinutes(0);
    this.setSeconds(0);
    this.setMilliseconds(0);
};

function getDecimalYear(time)
{
    var
	date = new Date(time.DayToMsec()),
	year = date.getFullYear(),
	start = Date.UTC(year, 0, 1),
	end   = Date.UTC(year + 1, 0, 1),
	today = date.getTime();
    return year + (today - start) / (end - start);
}

Date.prototype.setDateDecimalTime = function(year, month, day, time)
{
    var
	hours,
	minutes,
	seconds;

    hours = Math.floor(time);
    minutes = (time - hours) * 60;
    seconds = Math.round((minutes - Math.floor(minutes)) * 60);
    minutes = Math.floor(minutes);

    this.setTime(Date.UTC(year, month, day, hours, minutes, seconds));
};

// Julian Day Number of 0h UT
Date.prototype.getJulian = function()
{
    var
	jday = this.getTime().MsecToDay();

    jday += Date.J1970;

    // JD of 0h UT
    return Math.floor(jday - 0.5) + 0.5;
};

// set time from full Julian date (day + UT)
Date.prototype.setJDTime = function(jday)
{
    this.setTime((jday - Date.J1970).DayToMsec());
};

Date.prototype.getLocDayName = function(loc)
{
    var
	day,
	save_time;

    save_time = this.getTime();
    // set the time to noon just to be safe ...
    this.setTime(this.getTime() + (12).HtoMsec());
    day = day_of_week[this.getUTCDay()];

    this.setTime(save_time);

    return day;
};

// get the date as dd Month yyyy
Date.prototype.toLocDateStr = function(pad)
{
    var
	day,
	dateStr,
	save_time;

    save_time = this.getTime();
    // set the time to noon just to be safe ...
    this.setTime(this.getTime() + (12).HtoMsec());
    day = this.getUTCDate();

    // hack to work around lack of HTML digit space
    if (pad > 0)
	 dateStr = (day < 10 ? SP + " " : "") + day;
    else
	dateStr = day;

    dateStr += " " + months[this.getUTCMonth()]
	     + " " + this.getUTCFullYear();

    this.setTime(save_time);

    return dateStr;
};

// get DST status at noon in selected location
Date.prototype.getDayDST = function(loc)
{
    var
	is_dst,
	save_time;

    if (loc.uses_dst === false || flags.show_dst === false)
	return false;

    save_time = this.getTime();
    // noon LCT
    this.setTime(this.getTime() + (12).HtoMsec());

    if (loc.isDST(this) > 0)
	is_dst = true;
    else
	is_dst = false;

    this.setTime(save_time);

    return is_dst;
};

// see if start or end times need adjustment
// to reflect local "wall-clock" time
// FIXME ???
Date.prototype.checkTimeAdjustDST = function(loc)
{
    // no DST specified in DST rule
    if (loc.dst_start === null || loc.dst_end === null)
	return false;

    if (loc.latitude < 0) {
	if (this.getTime() < loc.dst_end  + (1).HtoMsec() ||
	  this.getTime() >= loc.dst_start + (1).HtoMsec()) {
	    return true;
	}
    }
    else {
	if (this.getTime() >= loc.dst_start + (1).HtoMsec() &&
	  this.getTime() < loc.dst_end  + (1).HtoMsec()) {
	    return true;
	}
    }

    return false;
};

// ****************** date data/functions **************************

var day_of_week = [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ];

var months = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun",
	       "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
];

var monthdays = [
    // 1   2   3   4   5   6   7   8   9  10  11  12
    [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ],
    [ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ]
];

function isleap(year)
{
    if ((year) % 4 === 0 && (year) % 100 !== 0 || (year) % 400 === 0)
	return 1;
    else
	return 0;
}

// show elapsed time since program_start Date object
function prog_time(program_start)
{
    var
	program_end = new Date(),
	time;

    time = program_end.getTime() - program_start.getTime();

    if (time < 1000)
	return "(" + time + " msec)";
    else
	return "(" + time / 1000 + " sec)";
}

// show/hide element
function showElement(id, status)
{
    var elem;

    // assumes name is unique
    elem = document.getElementById(id);
    if (elem) {
	if (status === true)
	    elem.style.display = "";
	else
	    elem.style.display = "none";
	}
    else
	alert("Element " + id + " not found");
}

// show/hide Copy ... Date buttons
function showCopy()
{
    var copy_dates = [
	"calcTimesCopyPositionsDate",
	"calcTimesCopyStartDate",
	"calcPosCopyStartDate"
    ];
    var ndx, elem, id;
    var msg = "";

    for (ndx = 0; ndx < copy_dates.length; ndx++) {
	id = copy_dates[ndx];
	elem = document.getElementById(id);
	if (elem) {
	    if (flags.show_copy_dates === true)
		elem.style.visibility = "visible";
	    else
		elem.style.visibility = "hidden";
	}
	else {
	    if (msg)
		msg += LF;
	    msg += "Element " + id + " not found";
	}
    }
    if (msg)
	alert(msg);
}

// test a Sun/Moon event
Number.prototype.testEvent = function()
{
    if (this <= -F_CIRCUMPOLAR)
	return false;
    else if (this >= F_CIRCUMPOLAR)
	return false;
    else if (this > F_TEST_NO_EVENT)
	return false;
    else if (isNaN(this))
	return false;
    else
	return true;
};

// calculate topocentric declination limits from alt and az limits
// return values in radians
function calcDeclLimits(loc, limits)
{
    var
	alt_min, alt_max,
	az_min, az_max,
	decl1, decl2, decl3, decl4,
	decl_min, decl_max;

    var
	sin_lat = loc.sin_lat,
	cos_lat = loc.cos_lat;

    alt_min = limits.alt_min;
    alt_max = limits.alt_max;
    az_min =  limits.az_min;
    az_max  = limits.az_max;

    // brute force; should be safe for lat > 23.5 or < -23.5.  May not
    // always work in tropics if dA/dt changes over course of search
    // declinations in radian
    decl1 = calcDeclination(alt_min, az_min, loc);
    decl2 = calcDeclination(alt_max, az_min, loc);
    decl3 = calcDeclination(alt_min, az_max, loc);
    decl4 = calcDeclination(alt_max, az_max, loc);

    decl_min = Math.min(decl1, decl2, decl3, decl4);
    decl_max = Math.max(decl1, decl2, decl3, decl4);

    limits.decl_min = decl_min;
    limits.decl_max = decl_max;

    return 0;
}

// *********************** data validation functions *******************

// trim leading and trailing white space from location name
function fix_name(field)
{
    field.value = field.value.trim();
}

function check_latitude(form, field)
{
    var
	angle,
	msg,
	rtn_val,
	latitude,
	value,
	MAX_VAL = 90;

    value = field.value.trim();

    angle = value.getHemisphere("lat");
    if (angle.isPackedDMS("lat") === true)
	angle = angle.packedDMSto();
    latitude = angle.DMSto();

    msg = "Invalid latitude (" + field.value + ")" + LF;
    if (isNaN(latitude)) {
	fixField(field, msg + DMS_LAT_FORMAT_MSG);
	rtn_val = false;
    }
    else if (Math.abs(latitude) > MAX_VAL) {
	msg += "Range is " + -MAX_VAL + " to " + MAX_VAL;
	fixField(field, msg);
	rtn_val = false;
    }
    else {
	// assume negative value is south latitude
	if (latitude < 0) {
	    latitude = -latitude;
	    set_hemisphere(form, field, "-");
	}
	else if (value.search(/N\s*$/i) >= 0)
	    set_hemisphere(form, field, "+");
	else if (value.search(/^\s*N/i) >= 0)
	    set_hemisphere(form, field, "+");

	// canonicalize form field
	if (value.search(/^\s*$/) != -1)			// blank entry
	    field.value = 0;
	else if (angle.search(/[:\s\u00b0]/) < 0)		// decimal
	    field.value = latitude.toString();
	else							// DMS
	    field.value = latitude.toDMS(2);

	rtn_val = true;
    }

    return rtn_val;
}

function check_longitude(form, field)
{
    var
	angle,
	msg,
	rtn_val,
	longitude,
	value,
	MAX_VAL = 180;

    value = field.value.trim();

    angle = value.getHemisphere("lon");
    if (angle.isPackedDMS("lon") === true)
	angle = angle.packedDMSto();
    longitude = angle.DMSto();

    msg = "Invalid longitude (" + field.value + ")" + LF;
    if (isNaN(longitude)) {
	fixField(field, msg + DMS_LON_FORMAT_MSG);
	rtn_val = false;
    }
    else if (Math.abs(longitude) > MAX_VAL) {
	msg += "Range is " + -MAX_VAL + " to " + MAX_VAL;
	fixField(field, msg);
	rtn_val = false;
    }
    else {
	// assume negative value is west longitude
	if (longitude < 0) {
	    longitude = -longitude;
	    set_hemisphere(form, field, "-");
	}
	else if (value.search(/E\s*$/i) >= 0)
	    set_hemisphere(form, field, "+");
	else if (value.search(/^\s*E/i) >= 0)
	    set_hemisphere(form, field, "+");

	// canonicalize form field
	if (value.search(/^\s*$/) != -1)			// blank entry
	    field.value = 0;
	else if (angle.search(/[:\s\u00b0]/) < 0)		// decimal
	    field.value = longitude.toString();
	else
	    field.value = longitude.toDMS(2);

	rtn_val = true;
    }

    return rtn_val;
}

// set N/S or E/W after latitude and longitude
function set_hemisphere(form, field, value)
{
    var type;

    switch(field.name) {
	case "latitude":
	    type = form.lat_sign;
	    break;
	case "longitude":
	    type = form.long_sign;
	    break;
	default:
	    alert("Wrong field (" + field.name + ") for function");
	    return false;
    }

    if (value == "-")
	type.selectedIndex = 1;
    else
	type.selectedIndex = 0;

    return true;
}

function check_elevation(field)
{
    var
	msg,
	rtn_val,
	elevation = field.value,
	elev_unit = "m",
	MIN_VAL = -400e300,		// Dead Sea, in m
	MAX_VAL = 8850e300;		// Mt. Everest, in m

    if (flags.elevation_in_feet === true) {
	MIN_VAL = MIN_VAL.MtoFT().toFixed(0);
	MAX_VAL = MAX_VAL.MtoFT().toFixed(0);
	elev_unit = "ft";
    }

    elevation = Number(rmCommas(elevation));

    msg = "Invalid elevation (" + field.value + " " + elev_unit + ")" + LF;
    if (isNaN(elevation)) {
	fixField(field, msg + NUMERIC_FORMAT_MSG);
	rtn_val = false;
    }
    else if (elevation < MIN_VAL || elevation > MAX_VAL) {
	msg += "Range is " + MIN_VAL + " to " + addCommas(MAX_VAL) + " " + elev_unit;
	fixField(field, msg);
	rtn_val = false;
    }
    else {
	// canonicalize
	field.value = addCommas(elevation);
	rtn_val = true;
    }
    return rtn_val;
}

function get_elevation(form)
{
    var elevation;

    if (form.loc_type[0].checked === true)			// internal database
	elevation = (places[form.place.selectedIndex][ELEV]);
    else							// user specified
	elevation = Number(rmCommas(form.elevation.value));

    return elevation;
}

function check_height(form, field)
{
    var
	msg,
	rtn_val,
	MIN_VAL = 0,
	max_val,
	elevation,
	height,
	height_unit = "m";

    elevation = get_elevation(form);
    height = Number(rmCommas(field.value));

    // allow only terrestrial locations; require horizon elevation at or
    // above sea level
    max_val = Math.max(elevation, 0);

    if (flags.elevation_in_feet === true) {
	MIN_VAL = MIN_VAL.MtoFT().toFixed(0);
	max_val = max_val.MtoFT().toFixed(0);
	height_unit = "ft";
    }

    msg = "Invalid height (" + field.value + " " + height_unit + ")" + LF;
    if (isNaN(height)) {
	fixField(field, msg + NUMERIC_FORMAT_MSG);
	rtn_val = false;
    }
    else if (height < MIN_VAL || height > max_val) {
	msg += "Range is " + MIN_VAL + " to " + addCommas(max_val) + " " + height_unit;
	fixField(field, msg);
	rtn_val = false;
    }
    else {
	// canonicalize
	field.value = addCommas(height);
	rtn_val = true;
    }
    return rtn_val;
}

function check_year(field, tag)
{
    var
	MIN_YEAR = 1582,
	msg,
	rtn_val,
	Today = new Date(),
	thisyear,
	year = field.value;

    if (arguments.length > 1)
	msg = "Invalid year (" + year + ") for " + tag + " date" + LF;
    else
	msg = "Invalid year (" + year + ")" + LF;

    if (year.search(/^\s*$/) != -1) {
	thisyear = Today.getFullYear();
	field.value = thisyear;
    }
    else if (isNaN(year) || year != Math.ipart(year)) {
	msg += "Integer value (yyyy) required";
	fixField(field, msg);
	rtn_val = false;
    }
    else if (Number(year) < MIN_YEAR) {
	msg += "Earliest is " + MIN_YEAR;
	fixField(field, msg);
	rtn_val = false;
    }
    else {
	field.value = Number(year).toString();
	rtn_val = true;
    }

    return rtn_val;
}

function check_start_date(form)
{
    if (check_year(form.StartYear, "start") === false)
	return false;

    var
	day = form.StartDay.selectedIndex + 1,
	ndx = form.StartMonth.selectedIndex,
	year = form.StartYear.value,
	maxdays = monthdays[isleap(year)][ndx];
    if (day > maxdays)
	form.StartDay.selectedIndex = maxdays - 1;

    check_dates(form, "start");

    if (flags.show_mag_north === true)
	check_mag_model(form, "Start Date", year, ndx, day);

    return true;
}

function check_end_date(form, priority)
{
    if (check_year(form.EndYear, "end") === false)
	return false;

    var
	day = form.EndDay.selectedIndex + 1,
	ndx = form.EndMonth.selectedIndex,
	year = form.EndYear.value,
	maxdays = monthdays[isleap(year)][ndx];
    if (day > maxdays)
	form.EndDay.selectedIndex = maxdays - 1;

    // priority should be "end" unless the End Date radio button was clicked
    check_dates(form, priority);

    if (flags.show_mag_north === true)
	check_mag_model(form, "End Date", year, ndx, day);

    return true;
}

function check_date_offset(form)
{
    var
	day = form.StartDay.selectedIndex + 1,
	month = form.StartMonth.selectedIndex,
	year = form.StartYear.value,
	field = form.DateOffset,
	date_offset = field.value - 0,
	ndx = form.DateOffsetUnits.selectedIndex,
	units = form.DateOffsetUnits.options[ndx].value - 0,
	day_offset = date_offset * units,
	EndDate = new Date(Date.UTC(year, month, day) + day_offset.DayToMsec());

    if (field.value.search(/^\s*$/) != -1)
	field.value = 1;
    else if (check_nonnegative(field, "date offset") === false)
	return false;

    // non-integral number of days makes no sense
    if (units == 1)
	field.value = Math.round(field.value);

    if (flags.show_mag_north === false)
	return true;

    year = EndDate.getUTCFullYear();
    month = EndDate.getUTCMonth();
    day = EndDate.getUTCDate();

    check_mag_model(form, "Date Offset", year, month, day);

    return true;
}

// ensure that end date >= start date
// priority indicates which date has priority if criterion is not met
function check_dates(form, priority)
{
    var
	msg,
	rtn_val,
	StartDate,
	EndDate,
	year,
	month,
	day;

    // don't check if date offset is specified
    if (form.end_date[0].checked === true) {	// end date
	year = form.StartYear.value;
	month = form.StartMonth.selectedIndex;
	day = form.StartDay.selectedIndex + 1;
	StartDate = new Date();
	StartDate.setTime(Date.UTC(year, month, day));
	start_date = StartDate.getTime().MsecToDay();

	year = form.EndYear.value;
	month = form.EndMonth.selectedIndex;
	day = form.EndDay.selectedIndex + 1;
	EndDate = new Date();
	EndDate.setTime(Date.UTC(year, month, day));
	end_date = EndDate.getTime().MsecToDay();

	if (end_date < start_date) {
	    if (priority == "start") {
		form.EndYear.value = form.StartYear.value;
		form.EndMonth.selectedIndex = form.StartMonth.selectedIndex;
		form.EndDay.selectedIndex = form.StartDay.selectedIndex;
	    }
	    else {
		form.StartYear.value = form.EndYear.value;
		form.StartMonth.selectedIndex = form.EndMonth.selectedIndex;
		form.StartDay.selectedIndex = form.EndDay.selectedIndex;
	    }
	    rtn_val = false;
	}
	else
	    rtn_val = true;
    }
    else
	rtn_val = true;

    return rtn_val;
}

function check_calc_date(form)
{
    if (check_year(form.CalcYear, "positions") === false)
	return false;

    var
	day = form.CalcDay.selectedIndex + 1,
	ndx = form.CalcMonth.selectedIndex,
	year = form.CalcYear.value,
	maxdays = monthdays[isleap(year)][ndx];
    if (day > maxdays)
	form.CalcDay.selectedIndex = maxdays - 1;

    if (flags.show_mag_north === true)
	check_mag_model(form, "Date for positions", year, ndx, day);

    return true;
}

function check_start_event(form)
{
    ;
}

function check_start_time(field)
{
    var
	msg,
	rtn_val,
	MIN = 0,
	MAX = 24,
	start = field.value.DMSto();

    start = field.value.parseTime("start");

    msg = "Invalid start time" + LF;

    if (start === null) {
	fixField(field);	// parseTime() gives message
	rtn_val = false;
    }
    else if (isNaN(start)) {
	fixField(field, msg + HM_FORMAT_MSG);
	rtn_val = false;
    }
    else if (start < MIN || start > MAX) {
	msg += "Range is " + MIN + " to " + MAX;
	fixField(field, msg);
	rtn_val = false;
    }
    else {
	field.value = start.formatTime("F");
	rtn_val = true;
    }

    return rtn_val;
}

function check_event_time_offset(field, tag)
{
    var
	msg = "",
	rtn_val,
	MIN = -480,
	MAX = -MIN,
	offset = Number(field.value);

    if (arguments.length > 1 && tag !== null && tag !== "")
	msg = "Invalid time (" + field.value + ") before or after " + tag + " event" + LF;
    if (isNaN(offset)) {
	fixField(field, msg + NUMERIC_FORMAT_MSG);
	rtn_val = false;
    }
    else if (offset < MIN || offset > MAX) {
	msg += "Range is " + MIN + " to " + MAX;
	fixField(field, msg);
	rtn_val = false;
    }
    else {
	if (offset < 0) {
	    field.value = -offset;
	    toggle_offset_sign(form, field);
	}
	field.value = Math.round(field.value);
	rtn_val = true;
    }

    return rtn_val;
}

// toggle before/after option of offset to event start/end time
function toggle_offset_sign(form, field)
{
    var sign;

    switch(field.name) {
	case "StartEventOffset":
	    sign = form.StartEventOffsetSign;
	    break;
	case "EndEventOffset":
	    sign = form.EndEventOffsetSign;
	    break;
	default:
	    alert("Wrong field (" + field.name + ") for function");
	    return false;
    }

    if (sign.selectedIndex === 0)
	sign.selectedIndex = 1;
    else
	sign.selectedIndex = 0;

    return true;
}

function check_end_event(form)
{
    ;
}

function check_end_time(field)
{
    var
	msg,
	rtn_val,
	MIN = 0,
	MAX = 24,
	end = field.value.DMSto();

    end = field.value.parseTime("end");

    msg = "Invalid end time" + LF;
    if (end === null) {
	fixField(field);	// parseTime() gives message
	rtn_val = false;
    }
    else if (isNaN(end)) {
	fixField(field, msg + NUMERIC_FORMAT_MSG);
	rtn_val = false;
    }
    else if (end < MIN || end > MAX) {
	msg += "Range is " + MIN + " to " + MAX;
	fixField(field, msg);
	rtn_val = false;
    }
    else {
	if (end === 0)				// assume midnight
	    end = 24;
	field.value = end.formatTime("F");
	rtn_val = true;
    }

    return rtn_val;
}

function check_time_offset(form)
{
    var
	msg,
	rtn_val,
	field = form.TimeOffset,
	t_offset = field.value,
	ndx = form.TimeOffsetUnits.selectedIndex;
	multiplier = form.TimeOffsetUnits.options[ndx].value;

    // convert to hours
    t_offset /= multiplier;

    msg = "Invalid time offset (" + field.value + ")" + LF;

    if (isNaN(t_offset)) {
	fixField(field, msg + "Nonnegative number required");
	rtn_val = false;
    }
    else if (t_offset < 0 || t_offset > 48) {	// allow 2 days calculation
	if (ndx === 0)
	    msg += "Range is 0 to 48 hours";
	else
	    msg += "Range is 0 to 2880 minutes";
	fixField(field, msg);
	rtn_val = false;
    }
    else {
	if (field.value.search(/^\s*$/) != -1) {
	    t_offset = 1;
	    form.TimeOffsetUnits.selectedIndex = 0;
	}
	else if (ndx == 1)
	    t_offset = Math.round(field.value);	// get the value in minutes

	field.value = t_offset.toString();
	rtn_val = true;
    }

    return rtn_val;
}

// for warning; limit to true valid range of model
function check_mag_date(date)
{
	// no warning if within grace period -- not endorsed by NOAA NGS!!
    if (date > mag_model.start_date - MagModel.GRACE &&
      date < mag_model.end_date + MagModel.GRACE)
	return true;
    else
	return false;
}

// for date for which to show magnetic declination; allow 1 year either
// side of model range
function check_mag_dec_date(date)
{
    var YEAR = 365;
 
	// no warning if within grace period -- not endorsed by NOAA NGS!!
    if (date > mag_model.start_date - MagModel.GRACE &&
      date < mag_model.end_date + MagModel.GRACE)
	// called w/1 argument when radio button is clicked
	return VALID;
    else if (date < mag_model.start_date - YEAR*2e300 || date > mag_model.end_date + YEAR*2e300)
	return INVALID; 
    else
	return EXTENDED;	// not endorsed by NOAA NGS!
}

// check date against magnetic model range
function check_mag_model(form, tag, year, month, day)
{
    var date = Date.UTC(year, month, day).MsecToDay();

	// no warning if within grace period -- not endorsed by NOAA NGS!!
    if (date < mag_model.start_date - MagModel.GRACE ||
      date > mag_model.end_date + MagModel.GRACE) {
	alert("Caution: " + tag + " is outside magnetic model range of "
	      + mag_model.valid_range_str2	// non-HTML string
	);
	return false;
    }
    else
	return true;
}

// ensure that date offset is nonnegative
function check_nonnegative(field, tag)
{
    var
	value = field.value,
	msg = "";

    if (isNaN(value) || value < 0) {
	if (arguments.length > 1 && tag !== null && tag !== "")
	    msg = "Invalid " + tag + " (" + value + ")" + LF;
	msg += "Nonnegative number required";
	fixField(field, msg);
	return false;
    }
    // canonicalize
    field.value = Number(value).toString();

    return true;
}

// ensure that value is positive
function check_value_positive(field, tag)
{
    var
	value = field.value,
	msg = "";

    if (isNaN(value) || value <= 0) {
	if (arguments.length > 1 && tag !== null && tag !== "")
	    msg = "Invalid " + tag + " (" + value + ")" + LF;
	msg += "Positive number required";
	fixField(field, msg);
	return false;
    }
    // canonicalize
    field.value = Number(value).toString();

    return true;
	
}

// ensure that value is positive
function check_date_step(field, units)
{
    var
	msg,
	ndx = units.selectedIndex,
	value = field.value;

    msg = "Invalid date interval (" + value + ")" + LF;
    msg += "Positive number required";
    if (value.search(/^\s*$/) != -1)
	value = 1;
    else if (isNaN(value) || value <= 0) {
	fixField(field, msg);
	return false;
    }
    // non-integral number of days makes no sense
    else if (units.options[ndx].value == 1)
	value = Math.round(value);

    // canonicalize
    field.value = Number(value).toString();

    return true;
}

// adjust rise/set altitudes for alignment of center or bottom with altitude
// use semidiameter at mean distance because actual value isn't known
function get_rs_alt_adjust(sd, align)
{
    switch (align) {
	case "center":
	    adjust = sd;
	    break;
	case "bottom":
	    adjust = 2 * sd;
	    break;
	default:
	    adjust = 0;
	    break;
    }
    return adjust;
}

// format message for allowable Sun rise/set alt range
function format_rs_alt_msg(lower, upper, adjust)
{
    var msg;

    // adjust values to indicate altitude of specified alignment
    lower -= adjust;
    upper -= adjust;

    msg = ': altitudes ' + lower.toFixed(3) + ' to ' + upper.toFixed(3);
    msg += ' do not occur; please use a different value';

    return msg;
}

/*
    Check for user-specified Sun rise/set alt or alt limits that fall in
    "forbidden" range resulting from application of refraction
    correction as body becomes visible.

    Neither a single altitude nor altitude limits can be within this
    range; if they are, give an error message

    If the midpoint of an altitude range is within the "forbidden"
    range, change it to the closest "forbidden"-range limit.

    Check for user-specified Moon rise/set alt alt or alt limits below
    visible horizon.
*/
function check_rs_alts(opts, loc)
{
    var
	adjust,		// adjustment for alignment of lower limb or center
	align,		// alignment of Sun's disk
	dip,		// dip of the horizon--apparent altitude
	errors,
	errmsg,
	minstr,		// minimum altitude for Moon rise/set
	rangestr,	// "forbidden" range of altitudes
	rs_alt;		// true altitude of rise/set
    var
	sun = new SunPos(),
	moon = new MoonPos();
    var
	low_diff, high_diff;
    var
	sd_sun = sun.SD0,
	sd_moon = moon.SD0;

    dip = loc.dip;
    rs_alt = loc.rs_alt;

    errors = 0;
    errmsg = "";

    /*
	Sun
	alt range:
	    check limits against "forbidden" range; alert and return if necessary.
	    check midpoint against "forbidden" range; change to closest
	    "forbidden"-range limit if necessary.
	single alt:
	    check against "forbidden" range; alert and return if necessary.
    */

    /* ****** check for sunrise alt (upper limb) within "forbidden" range *********/

    // handle top/center/bottom alignment of Sun's disk
    if (opts.moon_s_range === true)
	align = opts.alt_moon_s_range_align;	// should always be "center"
    else
	align = opts.alt_sr_align;		// as selected by user
    adjust = get_rs_alt_adjust(sd_sun, align);

    // Sun alt range
    if (opts.alt_sr_range) {
	// check lower limit; error if in "forbidden" range
	if (opts.sr_true_alt_min + adjust > rs_alt && opts.alt_sr_min + adjust < -dip) {
	    errmsg += 'Sunrise min alt (' + align + ') ';
	    errmsg += opts.alt_sr_min;
	    errmsg += format_rs_alt_msg(rs_alt, -dip, adjust);
	    errors++;
	}
	// check upper limit; error if in "forbidden" range
	if (opts.sr_true_alt_max + adjust > rs_alt && opts.alt_sr_max + adjust < -dip) {
	    if (errmsg)
		errmsg += LF;
	    errmsg += 'Sunrise max alt (' + align + ') ';
	    errmsg += opts.alt_sr_max;
	    errmsg += format_rs_alt_msg(rs_alt, -dip, adjust);
	    errors++;
	}
	// if limits are OK, check midpoint; change to closest
	// "forbidden"-range limit if necessary
	if (! errors) {
	    // Moon search--Sun alt range with Moon az/alt ranges
	    if (opts.moon_s_range === true &&
	       opts.moon_s_range_true_alt + adjust > rs_alt && opts.alt_moon_s_range + adjust < -dip) {

		low_diff  = opts.moon_s_range_true_alt + adjust - rs_alt;	// true
		high_diff = opts.alt_moon_s_range + adjust - dip;		// apparent

		if (Math.abs(low_diff) < Math.abs(high_diff)) {
		    // set to low limit of "forbidden" range
		    opts.moon_s_range_true_alt = rs_alt - adjust;
		    // not shown; does it matter?
		    opts.alt_moon_s_range = trueAltToAppAlt(rs_alt - adjust, sd_sun, loc);
		}
		else {
		    // set to high limit of "forbidden" range
		    opts.moon_s_range_true_alt = appAltToTrueAlt(dip - adjust, loc);
		    // not shown; does it matter?
		    opts.alt_moon_s_range = dip - adjust;
		}
	    }
	    // Sun search--Sun az/alt range without Moon az/alt ranges
	    else if (opts.moon_s_range === false &&
	             opts.sr_true_alt + adjust > rs_alt && opts.alt_sr + adjust < -dip) {
		low_diff  = opts.sr_true_alt + adjust - rs_alt;	// true
		high_diff = opts.alt_sr + adjust - dip;		// apparent

		if (Math.abs(low_diff) < Math.abs(high_diff)) {
		    // set to low limit of "forbidden" range
		    opts.sr_true_alt = rs_alt - adjust;
		    // what to display?
		    opts.alt_sr = trueAltToAppAlt(rs_alt - adjust, sd_sun, loc);
		}
		else {
		    // set to high limit of "forbidden" range
		    opts.alt_sr = dip - adjust;
		    opts.sr_true_alt = appAltToTrueAlt(dip - adjust, loc);
		}
	    }
	}
    }
    // single altitude; error if in "forbidden" range
    else if (opts.sr_true_alt + adjust > rs_alt && opts.alt_sr + adjust < -dip) {
	errmsg += 'Sunrise alt (' + align + ') ';
	errmsg += 'at ' + opts.alt_sr;
	errmsg += format_rs_alt_msg(rs_alt, -dip, adjust);
	errors++;
    }

    /* ****** check for sunset alt (upper limb) within "forbidden" range *********/

    // handle top/center/bottom alignment of Sun's disk
    if (opts.moon_s_range === true)
	align = opts.alt_moon_s_range_align;	// should always be "center"
    else
	align = opts.alt_ss_align;		// as selected by user
    adjust = get_rs_alt_adjust(sd_sun, align);

    // Sun alt range
    if (opts.alt_ss_range) {
	// check lower limit; error if in "forbidden" range
	if (opts.ss_true_alt_min + adjust > rs_alt && opts.alt_ss_min + adjust < -dip) {
	    if (errmsg)
		errmsg += LF;
	    errmsg += 'Sunset min alt (' + align + ') ';
	    errmsg += opts.alt_ss_min;
	    errmsg += format_rs_alt_msg(rs_alt, -dip, adjust);
	    errors++;
	}
	// check upper limit; error if in "forbidden" range
	if (opts.ss_true_alt_max + adjust > rs_alt && opts.alt_ss_max + adjust < -dip) {
	    if (errmsg)
		errmsg += LF;
	    errmsg += 'Sunset max alt (' + align + ') ';
	    errmsg += opts.alt_ss_max;
	    errmsg += format_rs_alt_msg(rs_alt, -dip, adjust);
	    errors++;
	}
	// if limits are OK, check midpoint; change to closest
	// "forbidden"-range limit if necessary
	if (! errors) {
	    // Moon search--Sun alt range with Moon az/alt ranges
	    if (opts.moon_s_range === true &&
	       opts.moon_s_range_true_alt + adjust > rs_alt && opts.alt_moon_s_range + adjust < -dip) {

		low_diff  = opts.moon_s_range_true_alt + adjust - rs_alt;	// true
		high_diff = opts.alt_moon_s_range + adjust - dip;		// apparent

		if (Math.abs(low_diff) < Math.abs(high_diff)) {
		    // set to lower limit of "forbidden" range
		    opts.moon_s_range_true_alt = rs_alt - adjust;
		    // not shown--does it matter?
		    opts.alt_moon_s_range = trueAltToAppAlt(rs_alt - adjust, sd_sun, loc);
		}
		else {
		    // set to upper limit of "forbidden" range
		    opts.moon_s_range_true_alt = appAltToTrueAlt(dip - adjust, loc);
		    // not shown--does it matter?
		    opts.alt_moon_s_range = dip - adjust;
		}
	    }
	    // Sun search--Sun az/alt range without Moon az/alt ranges
	    else if (opts.moon_s_range === false &&
	            opts.ss_true_alt + adjust > rs_alt && opts.alt_ss + adjust < -dip) {
		low_diff  = opts.ss_true_alt + adjust - rs_alt;	// true
		high_diff = opts.alt_ss + adjust - dip;		// apparent

		if (Math.abs(low_diff) < Math.abs(high_diff)) {
		    // set to lower limit of "forbidden" range
		    opts.ss_true_alt = rs_alt - adjust;
		    // only for display in column header
		    opts.alt_ss = trueAltToAppAlt(rs_alt - adjust, sd_sun, loc);
		}
		else {
		    // set to upper limit of "forbidden" range
		    opts.alt_ss = dip - adjust;
		    opts.ss_true_alt = appAltToTrueAlt(dip - adjust, loc);
		}
	    }
	}
    }
    // single altitude; error if in "forbidden" range
    else if (opts.ss_true_alt + adjust > rs_alt && opts.alt_ss + adjust < -dip) {
	if (errmsg)
	    errmsg += LF;
	errmsg += 'Sunset alt (' + align + ') ';
	errmsg += 'at ' + opts.alt_ss;
	errmsg += format_rs_alt_msg(rs_alt, -dip, adjust);
	errors++;
    }

    /*
	Moon
	alt range:
	    check limits against below horizon; alert and return if necessary
	single alt:
	    check against below horizon; alert and return if necessary
    */

    // handle top/center/bottom alignment of Moon's disk
    adjust = get_rs_alt_adjust(sd_moon, opts.alt_mr_align);

    if (opts.alt_mr_range) {
	// check lower limit; error if below visible horizon
	if (opts.alt_mr_min + adjust < -dip) {
	    if (errmsg)
		errmsg += LF;
	    errmsg += 'Moonrise min alt (' + opts.alt_mr_align + ') ';
	    errmsg += opts.alt_mr_min;
	    errmsg += ':' + ' minimum altitude is ' + (-dip - adjust).toFixed(3);
	    errors++;
	}
	// check upper limit; error if below visible horizon
	if (opts.alt_mr_max + adjust < -dip) {
	    if (errmsg)
		errmsg += LF;
	    errmsg += 'Moonrise max alt (' + opts.alt_mr_align + ') ';
	    errmsg += opts.alt_mr_max;
	    errmsg += ':' + ' minimum altitude is ' + (-dip - adjust).toFixed(3);
	    errors++;
	}
    }
    // single altitude; error if below visible horizon
    else if (opts.alt_mr + adjust < -dip) {
	if (errmsg)
	    errmsg += LF;
	errmsg += 'Moonrise alt (' + opts.alt_mr_align + ') ';
	errmsg += 'at ' + opts.alt_mr;
	errmsg += ':' + ' minimum altitude is ' + (-dip - adjust).toFixed(3);
	errors++;
    }

    // check for moonset alt (upper limb) below visible horizon

    // handle top/center/bottom alignment of Moon's disk
    adjust = get_rs_alt_adjust(sd_moon, opts.alt_ms_align);

    if (opts.alt_ms_range) {
	// check lower limit; error if below visible horizon
	if (opts.alt_ms_min + adjust < -dip) {
	    if (errmsg)
		errmsg += LF;
	    errmsg += 'Moonset min alt (' + opts.alt_ms_align + ') ';
	    errmsg += opts.alt_ms_min;
	    errmsg += ':' + ' minimum altitude is ' + (-dip - adjust).toFixed(3);
	    errors++;
	}
	// check upper limit; error if below visible horizon
	if (opts.alt_ms_max + adjust < -dip) {
	    if (errmsg)
		errmsg += LF;
	    errmsg += 'Moonset max alt (' + opts.alt_ms_align + ') ';
	    errmsg += opts.alt_ms_max;
	    errmsg += ':' + ' minimum altitude is ' + (-dip - adjust).toFixed(3);
	    errors++;
	}
    }
    // single altitude; error if below visible horizon
    else if (opts.alt_ms + adjust < -dip) {
	if (errmsg)
	    errmsg += LF;
	errmsg += 'Moonset alt (' + opts.alt_ms_align + ') ';
	errmsg += 'at ' + opts.alt_ms;
	errmsg += ':' + ' minimum altitude is ' + (-dip - adjust).toFixed(3);
	errors++;
    }

    if (errors) {
	alert(errmsg);
	return false;
    }
    else
	return true;
}

// check for altitude in forbidden range; adjust if necessary
function check_forbidden_alt(alt, alt_true, align, loc)
{
    var
	low_diff, high_diff;
    var
	sd_sun = 959.63 / 3600;		// treat as constant
    var
	adjust,
	dip = loc.dip,
	rs_alt = loc.rs_alt;

    adjust = get_rs_alt_adjust(sd_sun, align);

    if (alt_true + adjust > rs_alt && alt + adjust < -dip) {

	low_diff  = alt_true + adjust - rs_alt;	// true
	high_diff = alt + adjust - dip;		// apparent

	if (Math.abs(low_diff) < Math.abs(high_diff))
	    // set to low limit of "forbidden" range
	    alt_true = rs_alt - adjust;
	else
	    // set to high limit of "forbidden" range
	    alt_true = appAltToTrueAlt(dip - adjust, loc);
    }
    return alt_true;
}

// ********************* Form functions ***************************

function initialize_form()
{
    var load_state = 0;

    // initialize global variables
    form = document.SunMoonCalc;
    Today = new Date();
    flags = new Flag();
    copyright = "SunMoonCalc &copy; " + Today.getFullYear() + " Jeff Conrad";
    mag_model = new MagModel;
    times_results = new Result("times");
    positions_results = new Result("positions");
    place_list = new PlaceList();	// listing of location database
    SaveState = new CalcState();

    flags.isMozilla = false;
    // rough guess at whether to worry about Mozilla onblur() handler bug
    // FIXME? updated 26 December 2015: how long will this one work?
    if (navigator.userAgent.indexOf("Mozilla") != -1 &&
      navigator.userAgent.indexOf("Gecko/") != -1 &&
      navigator.userAgent.indexOf("like Gecko") == -1)
	flags.isMozilla = true;

    if (form.loaded !== true) {		// initial load
	reset_date(form);
	load_state = SaveState.read(form);
    }

    initialize_preferences();

    form.search_pattern.onkeypress = searchKeyFilter;
    form.search_pattern.onkeyup    = searchKeyFilter;

    // buttons to disable during HTTP queries
    HTTP.initialize_buttons();

    // save default state if cookie could not be read
    if (load_state == -2)
	SaveState.write(form);

    // get URL parameters (if any)
    var url_params = window.location.search;
    URL = url_params;

    flags.url_parameters = false;
    if (url_params.length > 1)		// need more than just '?'
	getURLParams(url_params);
}

function initialize_preferences()
{
    flags.initFlags(form);

    set_input_sizes();

    setLocTypeAttrib();
    setCalcTypeAttrib();
    
    // show/hide elements
    showElement("CheckPlaces", flags.show_check_places);
    showElement("PlaceSearch", flags.show_search);

    showCopy();

    initialize_times(form);
    initialize_units(form);
}

function initialize_times(form)
{
    var start_time, end_time;

    // format start and end times in position calculation as AM/PM or 24 hr
    // allow conversion of am/pm to UT
    if ((start_time = form.StartTime.value.parseTime("start", "init")) === null)
	start_time = 0;
    form.StartTime.value = start_time.formatTime("F");
    if ((end_time = form.EndTime.value.parseTime("end", "init")) === null)
	end_time = 24;
    if (end_time === 0)
	end_time = 24;
    form.EndTime.value = end_time.formatTime("F");
}

// set units shown for elevation and height on main form
// set time type (local or UT) on main form
function initialize_units(form)
{
    var elev_u, height_u;

    elev_u   = document.getElementById("ElevUnits");
    height_u = document.getElementById("HeightUnits");
    time_tag1 = document.getElementById("TimeTag1");
    time_tag2 = document.getElementById("TimeTag2");

    if (flags.elevation_in_feet === true) {
	elev_u.innerHTML   = "ft";
	height_u.innerHTML = "ft";
    }
    else {	// elevation in meters
	elev_u.innerHTML   = "m";
	height_u.innerHTML = "m";
    }
    if (flags.show_ut === true) {
	time_tag1.innerHTML = "UT";
	time_tag2.innerHTML = "UT";
    }
    else {
	time_tag1.innerHTML = "local time";
	time_tag2.innerHTML = "local time";
    }
}

// convert elevation and height to feet or meters if units have been changed
function convert_elev_ht(form, flag)
{
    var
	elevation = form.elevation,
	height = form.height;

    // convert elevation or height value to feet or meters
    function cvt_elev_value(value, flag)
    {
	value = Number(rmCommas(value));
	if (flag == "ft")
	    value = value.MtoFT();
	else
	    value = value.FTtoM();
	return addCommas(value.toFixed(0));
    }

    elevation.value = cvt_elev_value(elevation.value, flag);
    height.value = cvt_elev_value(height.value, flag);
}

function open_url(url, title)
{
    var LookupWindow;

    if (arguments.length < 2)
	title = "LookupWindow";

    LookupWindow = window.open(url, title);
    LookupWindow.focus();
}

// returns index of timezone in array of known time zones, or -1 on failure
function get_tz_ndx(timezone)
{
    // known time zones; must be kept in sync with select list on main form!!
    var timezones = [
	-12,   -11,   -10,  -9.5, -9,  -8,   -7, -6,   -5, -4.5,  -4, -3.5,
	 -3,    -2,    -1,   0,    1,   2,    3,  3.5,  4,  4.5,   5,  5.5,
	  5.75,  6,     6.5, 7,    8,   8.75, 9,  9.5, 10, 10.5,  11, 11.5,
	 12,    12.75, 13,  14
    ];

    var tz_ndx;

    for (tz_ndx = 0; tz_ndx < timezones.length; tz_ndx++) {
	if (timezone == timezones[tz_ndx])
	    break;
    }

    if (tz_ndx == timezones.length)
	tz_ndx = -1;

    return tz_ndx;
}

function set_input_sizes()
{
    if (flags.show_am_pm_time === true) {
	form.StartTime.style.width = "4.4em";
	form.EndTime.style.width = "4.4em";
    }
    else {
	form.StartTime.style.width = "3em";
	form.EndTime.style.width = "3em";
    }
}

function clearSearchPattern()
{
    form.search_pattern.value = "";
}

// set positions calculation date from times output
function set_calc_date(date)
{
    var
	calc_date = new Date(date.DayToMsec()),
	year = calc_date.getUTCFullYear(),
	month = calc_date.getUTCMonth(),
	day = calc_date.getUTCDate();

    form.CalcDay.selectedIndex = day - 1;
    form.CalcMonth.selectedIndex = month;
    form.CalcYear.value = year;
    form.calc_type[1].checked = true;

    setCalcTypeAttrib();

    SaveState.write(form);
}

// set place from List Locations report
function set_place(ndx)
{
    form.place.selectedIndex = ndx;
    SaveState.write(form);
}

// ************ functions for controlling form appearance ***********

// ---------- form elements whose attributes can be changed ---------

// 0: element id
// 1: special treatment of location/calc type heading
// 2: no border if grayed out

var stdLocTxt = [
    [ "stdLocTxt0",  0, 0 ],	// location database
    [ "stdLocTxt00", 0, 0 ],	// top row (pad)
    [ "stdLocTxt01", 0, 0 ],	// radio button
    [ "stdLocTxt02", 1, 0 ],	// Select label
    [ "stdLocTxt03", 0, 0 ],	// second row: left pad
    [ "stdLocTxt04", 0, 0 ],	// second row: place search
    [ "stdLocTxt05", 0, 0 ]	// second row: place search
];

var cstmLocTxt = [
    [ "cstmLocTxt0",  0, 0 ],	// first row
    [ "cstmLocTxt00", 0, 0 ],	// radio button
    [ "cstmLocTxt01", 1, 0 ],	// Specify Properties label
    [ "cstmLocTxt02", 0, 0 ],	// rest of row
    [ "cstmLocTxt1",  0, 0 ],	// remaining rows
    [ "cstmLocTxt10", 0, 0 ],	// Name/buttons
    [ "cstmLocTxt11", 0, 0 ],	// Latitude/Time Zone
    [ "cstmLocTxt12", 0, 0 ],	// Longitude/Use DST?
    [ "cstmLocTxt13", 0, 0 ],	// Elevation
    [ "cstmLocTxt14", 0, 0 ]	// Elevation
];

// doesn't include calc type headings
var calcTimesTxt = [
    [ "calcTimesTab", 0, 0 ]
];

var calcPosTxt = [
    [ "calcPosTab", 0, 0 ]
];

// 0: element id
// 1: special grayed-out font
// 2: special background color for inputs
// 3: don't disable or enable (for main selectors)
// 4: don't re-enable when active (for Next Match button)

var stdLocElems = [
    [ "stdLocType",          1, 0, 3, 0 ],		// select
    [ "stdLocPlace",         0, 2, 0, 0 ],
    [ "stdLocListPlaces",    0, 0, 3, 0 ],
    [ "CheckPlaces",         0, 0, 3, 0 ],
    [ "stdLocSearchPattern", 0, 2, 0, 0 ],
    [ "stdLocSearchPlaces",  0, 0, 0, 0 ],
    [ "stdLocNextPlace",     0, 0, 0, 4 ]
];

var cstmLocElems = [
    [ "cstmLocType",        1, 0, 3, 0 ],		// specify properties
    [ "cstmLocLookup",      0, 2, 0, 0 ],
    [ "cstmLocLookupGo",    0, 0, 0, 0 ],
    [ "cstmLocPlaceName",   0, 2, 0, 0 ],
    [ "cstmLocCopyPlace",   0, 0, 0, 0 ],
    [ "cstmLocClearCustom", 0, 0, 0, 0 ],
    [ "cstmLocLatitude",    0, 2, 0, 0 ],
    [ "cstmLocLatSign",     0, 2, 0, 0 ],
    [ "cstmLocTimeZone",    0, 2, 0, 0 ],
    [ "cstmLocLongitude",   0, 2, 0, 0 ],
    [ "cstmLocLongSign",    0, 2, 0, 0 ],
    [ "cstmLocUsesDST",     0, 2, 0, 0 ],
    [ "cstmLocElevation",   0, 2, 0, 0 ]
];

var calcTimesElems = [
    [ "calcTimesHeading",           1, 0, 3, 0 ],	// heading: Rise and Set Times
    [ "calcTimesCalcType",          0, 0, 3, 0 ],	// radio button (rise and set)
    [ "calcTimesStartDay",          0, 2, 0, 0 ],	// select
    [ "calcTimesStartMonth",        0, 2, 0, 0 ],	// select
    [ "calcTimesStartYear",         0, 2, 0, 0 ],	// text box
    [ "calcTimesCopyPositionsDate", 0, 0, 0, 0 ],	// button
    [ "calcTimesEndTypeDate",       0, 0, 0, 0 ],	// radio button
    [ "calcTimesEndDay",            0, 2, 0, 0 ],	// select
    [ "calcTimesEndMonth",          0, 2, 0, 0 ],	// select
    [ "calcTimesEndYear",           0, 2, 0, 0 ],	// text box
    [ "calcTimesCopyStartDate",     0, 0, 0, 0 ],	// button
    [ "calcTimesEndTypeOffset",     0, 0, 0, 0 ],	// radio button
    [ "calcTimesDateOffset",        0, 2, 0, 0 ],	// text box
    [ "calcTimesDateOffsetUnits",   0, 2, 0, 0 ],	// select
    [ "calcTimesDateInterval",      0, 2, 0, 0 ],	// text box
    [ "calcTimesDateIntervalUnits", 0, 2, 0, 0 ],	// select
    [ "calcTimesRiseSetCriteria",   0, 0, 0, 0 ]	// button
];

var calcPosElems = [
    [ "calcPosHeading",              1, 0, 3, 0 ],	// heading: Sun and Moon Positions
    [ "calcPosCalcType",             0, 0, 3, 0 ],	// radio button (positions)
    [ "calcPosCalcDay",              0, 2, 0, 0 ],	// select
    [ "calcPosCalcMonth",            0, 2, 0, 0 ],	// select
    [ "calcPosCalcYear",             0, 2, 0, 0 ],	// text box
    [ "calcPosDayDecrement",         0, 0, 0, 0 ],	// button
    [ "calcPosDayIncrement",         0, 0, 0, 0 ],	// button
    [ "calcPosCopyStartDate",        0, 0, 0, 0 ],	// button
    [ "calcPosStartTypeEvent",       0, 0, 0, 0 ],	// radio button
    [ "calcPosStartEventOffset",     0, 2, 0, 0 ],	// text box
    [ "calcPosStartEventOffsetSign", 0, 2, 0, 0 ],	// select (before/after)
    [ "calcPosStartEvent",           0, 2, 0, 0 ],	// select (event type)
    [ "calcPosStartTypeTime",        0, 0, 0, 0 ],	// radio button
    [ "calcPosStartTime",            0, 2, 0, 0 ],	// text box
    [ "calcPosEndTypeEnd",           0, 0, 0, 0 ],	// radio button
    [ "calcPosEndTimeEvent",         0, 0, 0, 0 ],	// radio button
    [ "calcPosEndEventOffset",       0, 2, 0, 0 ],	// text box
    [ "calcPosEndEventOffsetSign",   0, 2, 0, 0 ],	// select (before/after)
    [ "calcPosEndEvent",             0, 2, 0, 0 ],	// select (event type)
    [ "calcPosEndTimeTime",          0, 0, 0, 0 ],	// radio button
    [ "calcPosEndTime",              0, 2, 0, 0 ],	// text box
    [ "calcPosEndTypeOffset",        0, 0, 0, 0 ],	// radio button
    [ "calcPosTimeOffset",           0, 2, 0, 0 ],	// text box
    [ "calcPosTimeOffsetUnits",      0, 2, 0, 0 ],	// select (time units)
    [ "calcPosTimeInterval",         0, 2, 0, 0 ]	// select (time interval)
];

// toggle attributes to show selected/deselected states
function toggleAttrib(elmnts, elemType)
{
    var
	elem,
	elmnt,
	ndx,
	min = 0,
	max;

    var msg = "";

    max = elmnts.group1.length;

    // show selected group elements as active
    for (ndx = min; ndx < max; ndx++) {
	elmnt = elmnts.group1[ndx];
	elem = document.getElementById(elmnt[0]);
	if (elem) {
	    elem.style.color      = elemType.active_color;
	    elem.style.fontWeight = elemType.active_weight;
	    elem.style.fontStyle  = elemType.active_style;
	    elem.style.backgroundColor = elemType.active_bgcolor;
	    // don't re-enable Next Match button
	    if (elmnt[4] === 0)
		elem.disabled = false;
	}
	else {
	    if (msg)
		msg += LF;
	    msg += "Element " + elmnt[0] + " not found";
	}
    }

    // show text and background as active in selected area
    if (elmnts.box1) {
	max = elmnts.box1.length;
	for (ndx = min; ndx < max; ndx++) {
	    elmnt = elmnts.box1[ndx];
	    elem = document.getElementById(elmnt[0]);
	    if (elem) {
		if (elmnt[1] !== 0) {
		    elem.style.color      = elemType.active_color1;
		    elem.style.fontWeight = elemType.active_weight1;
		    elem.style.fontStyle  = elemType.active_style1;
		}
		else {
		    elem.style.color       = elemType.active_color;
		    elem.style.fontWeight  = elemType.active_weight;
		}
		elem.style.borderColor = elemType.active_border_color;
		elem.style.borderStyle = elemType.active_border_style;
		elem.style.borderWidth = elemType.active_border_width;
		elem.style.backgroundColor = elemType.active_bgcolor;
		elem.disabled = false;
	    }
	    else {
		if (msg)
		    msg += LF;
		msg += "Element " + elmnt[0] + " not found";
	    }
	}
    }

    max = elmnts.group2.length;

    // disable form elements in inactive group
    for (ndx = min; ndx < max; ndx++) {
	elmnt = elmnts.group2[ndx];
	elem = document.getElementById(elmnt[0]);
	if (elem) {
	    // for times/positions radio button text
	    if (elmnt[1] !== 0) {	// calc type heading
		elem.style.color      = elemType.inactive_color1;
		elem.style.fontWeight = elemType.inactive_weight1;
		elem.style.fontStyle  = elemType.inactive_style1;
	    }
	    if (elmnt[2] !== 0)
		elem.style.backgroundColor = elemType.inactive_input_bgcolor;
	    if (elmnt[3] === 0)
		elem.disabled = true;
	}
	else {
	    if (msg)
		msg += LF;
	    msg += "Element " + elmnt[0] + " not found";
	}
    }

    // gray out text and background in deselected area
    if (elmnts.box2) {
	max = elmnts.box2.length;
	for (ndx = min; ndx < max; ndx++) {
	    elmnt = elmnts.box2[ndx];
	    elem = document.getElementById(elmnt[0]);
	    if (elem) {
		if (elmnt[1] !== 0) {
		    elem.style.color      = elemType.inactive_color1;
		    elem.style.fontWeight = elemType.inactive_weight1;
		    elem.style.fontStyle  = elemType.inactive_style1;
		}
		else {
		    elem.style.color = elemType.inactive_color;
		    elem.style.fontWeight = elemType.inactive_weight;
		}
		if (elmnt[2] !== 0)
		    elem.style.border      = "none";
		else {
		    elem.style.borderColor = elemType.inactive_border_color;
		    elem.style.borderStyle = elemType.inactive_border_style;
		    elem.style.borderWidth = elemType.inactive_border_width;
		}
		elem.style.backgroundColor = elemType.inactive_bgcolor;
	    }
	    else {
		if (msg)
		    msg += LF;
		msg += "Element " + elmnt[0] + " not found";
	    }
	}
    }
    if (msg)
	alert(msg);
}

// toggle attributes for Place or Custom Location
// form elements to indicate which is selected
function setLocTypeAttrib()
{
    var elem, min, max, ndx;
    var
	locType = new Object(),
	elmnts   = new Object();

    elmnts.min   = 0;
    elmnts.max   = 14;

    locType.active_color1  = "navy";			// Select/Specify
    locType.active_weight1 = "bold";			// Select/Specify
    locType.active_style1  = "";			// Select/Specify
    locType.active_color   = "";
    locType.active_weight  = "";
    locType.active_style   = "";

    locType.inactive_color1  = "#aaa";			// Select/Specify
    locType.inactive_weight1 = "bold";			// Select/Specify
    locType.inactive_style1  = "";			// Select/Specify
    locType.inactive_color   = "#999";
    locType.inactive_weight  = "";
    locType.inactive_style1  = "";
    locType.inactive_style   = "";

    locType.active_border_color = "";
    locType.active_border_style = "";
    locType.active_border_width = "";
    locType.active_bgcolor      = "";
    locType.active_visibility   = "visible";

    locType.inactive_border_color = "";
    locType.inactive_border_style = "";
    locType.inactive_border_width = "";
    locType.inactive_bgcolor      = "";
    locType.inactive_bgcolor      = SUN_COLOR;
    locType.inactive_input_bgcolor = "#f7f7f7";
    locType.inactive_visibility   = "visible";

    switch(form.loc_type[0].checked) {
	case true:
	    elmnts.group1 = stdLocElems;
	    elmnts.box1   = stdLocTxt;
	    elmnts.group2 = cstmLocElems;
	    elmnts.box2   = cstmLocTxt;
	    break;
	case false:
	    elmnts.group1 = cstmLocElems;
	    elmnts.box1   = cstmLocTxt;
	    elmnts.group2 = stdLocElems;
	    elmnts.box2   = stdLocTxt;
	    break;
	default:
	    break;
    }

    toggleAttrib(elmnts, locType);
}

// set attributes for Calculate Times or Calculate Positions
// form elements to indicate which is selected
function setCalcTypeAttrib()
{
    var elem, min, max, ndx;
    var
	calcType = new Object(),
	elmnts   = new Object();

    elmnts.min   = 0;
    elmnts.max   = 24;

    calcType.active_color   = "";
    calcType.active_weight  = "";
    calcType.active_style   = "";

    calcType.inactive_color1  = "gray";			// Times/Positions headings
    calcType.inactive_weight1 = "normal";		// Times/Positions headings
    calcType.inactive_style1  = "";			// Times/Positions headings
    calcType.inactive_color   = "#999";
    calcType.inactive_weight  = "";
    calcType.inactive_style1  = "";
    calcType.inactive_style   = "";

    calcType.active_border_color = "";
    calcType.active_border_style = "";
    calcType.active_border_width = "";
    calcType.active_bgcolor      = "";
    calcType.active_visibility   = "visible";

    calcType.inactive_border_width = "1px";
    calcType.inactive_border_color = "#aaa";
    calcType.inactive_border_style = "dotted";
    calcType.inactive_bgcolor      = SUN_COLOR;
    calcType.inactive_input_color = "gray";
    calcType.inactive_input_bgcolor = "#f7f7f7";
    calcType.inactive_visibility   = "visible";

    switch(form.calc_type[0].checked) {
	case true:
	    elmnts.group1 = calcTimesElems;
	    elmnts.box1   = calcTimesTxt;
	    elmnts.group2 = calcPosElems;
	    elmnts.box2   = calcPosTxt;
	    break;
	case false:
	    elmnts.group1 = calcPosElems;
	    elmnts.box1   = calcPosTxt;
	    elmnts.group2 = calcTimesElems;
	    elmnts.box2   = calcTimesTxt;
	    break;
	default:
	    break;
    }

    toggleAttrib(elmnts, calcType);
    enable_inputs();
}

// disable inactive inputs in active area of main form
function enable_inputs()
{
    if (form.calc_type[0].checked === true)
	enable_input(form.end_date[0]);
    else {
	enable_input(form.time_start_type[0]);
	enable_input(form.end_time[0]);
    }
}

// disable/enable input in active area of main form
function enable_input(button)
{
    var
	group1, group2, enable, disable, check,
	elmts, elem, max, ndx,
	inactive_input_color = "gray",
	inactive_input_bgcolor = "#f7f7f7";

    var msg = "";

    check = null;
    switch (button.name) {
	case "end_date":
	    group1 = [ "EndDay", "EndMonth", "EndYear" ];
	    group2 = [ "DateOffset", "DateOffsetUnits" ];
	    if (form.end_date[0].checked === true) {
		enable = group1;
		disable = group2;
	    }
	    else {
		enable = group2;
		disable = group1;
	    }
	    break;
	case "time_start_type":
	    group1 = [ "StartEventOffset", "StartEventOffsetSign", "StartEvent" ];
	    group2 = [ "StartTime" ];
	    if (form.time_start_type[0].checked === true) {
		enable = group1;
		disable = group2;
	    }
	    else {
		enable = group2;
		disable = group1;
	    }
	    break;
	case "end_time":
	    group1 = [
	        "EndEventOffset", "EndEventOffsetSign",
		"EndEvent", "EndTime", "time_end_type"
	    ];
	    group2 = [ "TimeOffset", "TimeOffsetUnits" ];

	    if (form.end_time[0].checked === true) {
		enable = group1;
		disable = group2;
		check = form.time_end_type[0];
	    }
	    else {
		enable = group2;
		disable = group1;
	    }
	    break;
	case "time_end_type":
	    group1 = [ "EndEventOffset", "EndEventOffsetSign", "EndEvent" ];
	    group2 = [ "EndTime" ];

	    if (form.time_end_type[0].checked === true) {
		enable = group1;
		disable = group2;
	    }
	    else {
		enable = group2;
		disable = group1;
	    }
	    break;
	default:
	    break;
    }

    max = enable.length;
    for (ndx = 0; ndx < max; ndx++) {
	elmts = document.getElementsByName(enable[ndx]);
	if (elmts) {
	    for (ndx2 = 0; ndx2 < elmts.length; ndx2++) {
		elem = elmts[ndx2];
		elem.style.backgroundColor = "";
		elem.style.color = "";
		elem.disabled = false;
	    }
	}
	else {
	    if (msg)
		msg += LF;
	    msg += "Element " + enable[ndx] + " not found";
	}
    }

    max = disable.length;
    for (ndx = 0; ndx < max; ndx++) {
	elmts = document.getElementsByName(disable[ndx]);
	if (elmts) {
	    for (ndx2 = 0; ndx2 < elmts.length; ndx2++) {
		elem = elmts[ndx2];
		elem.style.color = inactive_input_color;
		elem.style.backgroundColor = inactive_input_bgcolor;
		if (flags.enable_inactive_inputs === false)
		    elem.disabled = true;
	    }
	}
	else {
	    if (msg)
		msg += LF;
	    msg += "Element " + disable[ndx] + " not found";
	}
    }
    if (msg)
	alert(msg);

    // call this function again to check inner groups of end time options
    if (check)
	arguments.callee(check);
}

// ******************** calculator state object and methods ****************************

// object to save certain properties in localStorage or a cookie
function CalcState(weeks)
{
    var msec;

    this.SMCalc_tag = "SMCalc_state";	// for legacy cookie methods
    this.SMCalcTag = "SMCalcState_";	// for localStorage methods
    this.version = "4.6.4";		// last version with changes to saved state
    this.vStr = "v" + this.version;

    // for cookie methods
    // set expiration date
    if (weeks)
	msec = weeks * 24 * 7 * 3600e3;
    else
	msec = 13 * 24 * 7 * 3600e3;	// 3 months

    this.expiration = new Date((new Date()).getTime() + msec);

    this.saved_data = [
	"loc_type",		// radio: built-in or specified/looked up
	"calc_type",		// radio: rise/set or positions

	// selected location
	"place",			// select

	// custom location
	"place_name",			// text
	"latitude",			// text
	"longitude",			// text
	"elevation",			// text
	"lat_sign",			// select
	"long_sign",			// select
	"timezone",			// select
	"uses_dst",			// select

	// misc
	"height",			// text
	"LocationLookup",		// select
	"WeatherLookup",		// select

	// User Preferences
	    // Window behavior
	"SepTimePosWindows",		// hidden
	"SepAllTimePosWindows",		// hidden
	"UsePopups",			// hidden
	"UseAllTabs",			// hidden

	    // Location search
	"ShowSearch",			// hidden
	"UseREs",			// hidden

	    // List locations report
	"ShowMagDec",			// hidden
	"ShowDSTRules",			// hidden
	"ShowDSTDates",			// hidden

	    // Time display
	"ShowAMPMTime",			// hidden
	"ShowDST",			// hidden
	"ShowUT",			// hidden

	    // Azimuth display
	"ShowMagNorth",			// hidden

	    // Elevation and height units
	"ElevationInFeet",		// hidden

	"ShowAllTwilight",		// hidden


	    // Miscellaneous options
	"InterpolateRSPositions",	// hidden
	"RSShowMoonSD",			// hidden

	"AlwaysShowWaxWane",		// hidden
	"ShowTdiffAllSearches",		// hidden
	"EnableInactiveInputs",		// hidden
	"ShowCheckPlaces",		// hidden
	// eliminated version 4.6.4
	// "ShowCopyDates",		// hidden
	"ShowAzAdjust",			// hidden
	"TimeProgram",			// hidden
	"UseFontSize",			// hidden
	"FontSize"			// text
    ];

    if (this.checkStorageType('localStorage') === true) {
	CalcState.prototype.write = writeLocalStorage;
	CalcState.prototype.read = readLocalStorage;
	// use to clear storage if necessary
	//this.clearLocalStorage();
    }
    else {
	CalcState.prototype.write = writeCookie;
	CalcState.prototype.read = readCookie;
    }
}

CalcState.prototype.checkStorageType = function(type)
{
    try {
	var storage = window[type], x = '__storage_test__';

	storage.setItem(x, x);
	storage.removeItem(x);
	return true;
    }
    catch(e) {
	return false;
    }
};

// --------- methods using local storage ----------------
// use to clear localStorage for testing
CalcState.prototype.clearLocalStorage = function()
{
    var ndx, prop, tag;

    prop = this.saved_data;
    tag = this.SMCalcTag;

    localStorage.removeItem(tag + 'version');

    for (ndx = 0; ndx < prop.length; ndx++)
	localStorage.removeItem(tag + prop[ndx]);
};

function writeLocalStorage(form)
{
    var name, ndx, prop, tag, value;

    prop = this.saved_data;
    tag = this.SMCalcTag;

    localStorage.setItem(tag + 'version', this.vStr);

    for (ndx = 0; ndx < prop.length; ndx++) {

	// location- and calculation-type radio buttons
	if (ndx < 2) {
	    name = tag + form[prop[ndx]][0].name;
	    value = form[prop[ndx]][0].checked;
	}
	else {
	    name = tag + form[prop[ndx]].name;
	    switch (form[prop[ndx]].type) {
		case "hidden":
		case "text":
		    value = form[prop[ndx]].value;
		    break;
		case "select-one":
		    value = form[prop[ndx]].selectedIndex;
		    break;
		default:
		    break;
	    }
	}
	localStorage.setItem(name, value);
    }
}

function readLocalStorage(form)
{
    var name, ndx, prop, tag, value;

    prop = this.saved_data;
    tag = "SMCalcState_";

    value = localStorage.getItem(tag + 'version');

    if (value === null) {
	alert("No saved data; using default values");
	return -2;
    }
    else if (value != this.vStr) {
	alert("Could not load saved data (wrong version); using default values");
	return -2;
    }

    for (ndx = 0; ndx < prop.length; ndx++) {
	name = tag + form[prop[ndx]].name;

	if (ndx < 2) {
	    // location- and calculation-type radio buttons
	    value = localStorage.getItem(tag + form[prop[ndx]][0].name);
	    if (value == "true")
		form[prop[ndx]][0].checked = true;
	    else
		form[prop[ndx]][1].checked = true;
	}
	else {
	    // everything else
	    value = localStorage.getItem(tag + form[prop[ndx]].name);
	    switch (form[prop[ndx]].type) {
		case "hidden":
		case "text":
		    form[prop[ndx]].value = value;
		    break;
		case "select-one":
		    form[prop[ndx]].selectedIndex = value;
		    break;
		default:
		    break;
	    }
	}
    }

    return 0;
}

// ------------- methods using cookie ----------------------
function writeCookie(form)
{
    var
	cookie, ndx, prop, prop_val, value;

    // location and calculation type
    cookie = this.SMCalc_tag + "=";
    cookie += this.vStr;

    prop = this.saved_data;
    for (ndx = 0; ndx < prop.length; ndx++) {
	// location- and calculation-type radio buttons
	if (ndx < 2) {
	    if (form[prop[ndx]][0].checked === true)
		prop_val = 0;
	    else
		prop_val = 1;
	    cookie += ":" + prop_val;
	}
	else {
	    switch (form[prop[ndx]].type) {
		case "hidden":
		case "text":
		    value = form[prop[ndx]].value;
		    if (value == "true")
			prop_val = "t";
		    else if (value == "false")
			prop_val = "f";
		    else
			prop_val = value;
		    cookie += ":" + escape(prop_val);
		    break;
		case "select-one":
		    cookie += ":" + escape(form[prop[ndx]].selectedIndex);
		    break;
		default:
		    break;
	    }
	}
    }

    cookie += "; expires=" + this.expiration.toUTCString();
    document.cookie = cookie;
}

// read and parse cookie for user preferences and location data
// returns 0 on success, -1 if no cookie, -2 if cookie cannot be read

function readCookie(form)
{
    var
	cookie = document.cookie,
	a, prop, prop_val, value,
	start, end;

    if (! cookie)
	return -1;

    start = cookie.indexOf(this.SMCalc_tag + "=");
    if (start == -1)   // no SMCalc info ...
	return -1;

    start += this.SMCalc_tag.length + 1;  // Skip name and equals sign.
    // check version
    if (cookie.substring(start, start + this.vStr.length) != this.vStr) {
	alert("Could not load saved data (wrong version); using default values");
	return -2;
    }
    start += this.vStr.length + 1;  // skip version string and colon

    end = cookie.indexOf(";", start);
    if (end == -1)
	end = cookie.length;

    // extract the SMCalc info
    cookie = cookie.substring(start, end);
    a = cookie.split(":");
    prop = this.saved_data;

    // one final test to see if cookie matches current format
    if (a.length != prop.length) {
	alert("Could not load saved data; using default values");
	return -2;
    }

    for(var ndx = 0; ndx < a.length; ndx++) {
	// location- and calculation-type radio buttons
	if (ndx < 2) {
	    prop_val = a[ndx];
	    if (prop_val == "0")
		form[prop[ndx]][0].checked = true;
	    else
		form[prop[ndx]][1].checked = true;
	}
	else {
	    // everything else
	    switch (form[prop[ndx]].type) {
		case "hidden":
		case "text":
		    prop_val = unescape(a[ndx]);
		    if (prop_val == "t")
			value = "true";
		    else if (prop_val == "f")
			value = "false";
		    else
			value = prop_val;
		    form[prop[ndx]].value = value;
		    break;
		case "select-one":
		    value = unescape(a[ndx]);
		    form[prop[ndx]].selectedIndex = value;
		    break;
		default:
		    break;
	    }
	}
    }

    return 0;
}

// ************************* button functions *******************

// ---------------- buttons in Location -------------------------

// 'List Locations' button
// show properties for all locations in location database
function list_places(type)
{
    flags.initFlags(form);
    if (flags.show_dst_rules === true || flags.show_dst_dates === true)
	flags.show_dst = true;	// force rule lookup

    if (type == "reformat") {
	flags.print = true;
	if (flags.use_font_size === true)
	    set_font_size();
    }

    place_list.name = "Places";
    place_list.build_doc_head();

    if (type != "reformat") {
	flags.print = false;

	// for timing program
	if (flags.time_program === true)
	    var program_start = new Date();

	var
	    year,		// calendar year for DST rules
	    month, day,
	    mag_dec_date;	// date for magnetic declination

	if (form.calc_type[0].checked === true) {
	    if (check_year(form.StartYear, "start") === false)
		return false;
	    year = form.StartYear.value;
	    month = form.StartMonth.selectedIndex;
	    day = form.StartDay.selectedIndex + 1;
	}
	else {
	    if (check_year(form.CalcYear, "positions") === false)
		return false;
	    year = form.CalcYear.value;
	    month = form.CalcMonth.selectedIndex;
	    day = form.CalcDay.selectedIndex + 1;
	}

	if (flags.show_mag_dec === true)
	    // don't worry about offsets from UTC
	    mag_dec_date = Date.UTC(year, month, day).MsecToDay();
	else
	    mag_dec_date = null;

	place_list.build_places_header(year, mag_dec_date);
	place_list.build_place_list(year, mag_dec_date);
	place_list.copyright = copyright;

	// for timing program
	if (flags.time_program === true)
	    place_list.prog_time = prog_time(program_start);
    }

    place_list.add_buttons();

    place_list.output();

    flags.print = false;

    return true;
}

// 'Check Locations' button
// check match between places select list and places array
// check for a DST rule for each place that uses DST
function check_places()
{
    var field, tag, year;

    flags.show_dst = true;	// force rule lookup

    // show DST rules for specified year
    if (form.calc_type[0].checked === true) {
	field = form.StartYear;
	tag = "start";
    }
    else {
	field = form.CalcYear;
	tag = "positions";
    }
    if (check_year(field, tag) === false)
	return false;
    else
	year = field.value;

    checkPlaces();
    checkDSTRules(year);
    debug_window.document.close();
    debug_window.focus();
    debug_window = null;	// force reopen as plain text

    return true;
}

// 'New Search' and 'Next Match' buttons
/*
    search location database for place matching pattern
    type: "backspace": perform search but give no error message
	  "next": search for next match
	  "new": New search from begging of database
*/
function search_places(type)
{
    var dis = search_places;
    var i, icase = true, ndx, n_places;
    var form, pattern, pattern0, place;
    var result;		// flag = true|false

    form = document.SunMoonCalc;

    if (dis.searchIndex === undefined)
	dis.searchIndex = 0;

    switch (type) {
	case "backspace":	// no error message on backspace
	case "new":		// 'New Search' button
	    dis.searchIndex = 0;
	    form.NextPlace.disabled = true;
	    break;
	default:
	    break;
    }

    pattern = form.search_pattern.value;
    pattern0 = pattern;		// save for error message
    n_places = places.length;

    if (pattern.search(/[A-Z]/) != -1)	// case sensitive with any capital letter
	icase = false;
    else			// case insensitive
	pattern = pattern.toLowerCase();

    ndx = dis.searchIndex;
    for (i = ndx; i < n_places; i++) {
	place = places[i][0];
	if (icase === true)
	    place = place.toLowerCase();

	found = false;
	if (flags.use_REs === true && place.search(pattern) != -1)
	    found = true;
	else if (flags.use_REs === false && place.indexOf(pattern) >= 0)
	    found = true;
	if (found === true) {
	    set_place(i);
	    dis.searchIndex = i + 1;	// remember for 'Next match' button
	    form.NextPlace.disabled = false;
	    break;
	}
    }

    if  (type == "backspace")
	return true; 		// don't give an error message on backspace

    if (i >= n_places) {	// search reached end of list
	if (ndx > 0) {
	    form.NextPlace.disabled = true;
	    alert("No other location matches '" + pattern0 + "'");
	    result = false;
	}
	else {
	    alert("No location matches '" + pattern0 + "'");
	    form.search_pattern.value = pattern0.replace(/.$/, "");
	    result = false;
	}
    }
    else
	result = true;

    return result;
}

// Sun/Moon Calculator Az/Alt/Distance tool
function az_alt_tool()
{
    var url = "AzAltDist.htm";
    var title = "AzAltTool";
    var length_units;
    var loc = new Place();
    var
	from_lat,	// latitude of 'from' marker
	from_lon,	// longitude of 'to' marker
	to_lat,		// latitude of 'from' marker
	to_lon,		// longitude of 'to' marker
	offset = 0.09,	// angular distance in deg between 'from' and 'to' markers
	zoom = 13;

    if (loc.valid === false)
	return;
    if (loc.setLocation(form) === false)
	return;

    if (flags.elevation_in_feet === true)
	length_units = "English";
    else
	length_units = "Metric";

    from_lat = to_lat = loc.latitude;	// keep line horizontal
    from_lon = loc.longitude;
    to_lon = from_lon + offset;

    // the user probably doesn't want a map in the middle of the Atlantic
    if (loc.latitude === 0 && loc.longitude === 0) {
	alert('Latitude or longitude must be nonzero');
	return;
    }
    else {
	// add "&fit=yes" to start with map fit to markers
	url += "?from=" + from_lat + "," + from_lon;
	url += "&to="   + to_lat   + "," + to_lon;
	url += "&zoom=" + zoom;
	url += "&units=" + length_units;
    }

    open_url(url, title);
}

// run The Photographer's Ephemeris Web app
function runPhotoEphemeris()
{
    var url = "http://app.photoephemeris.com/";
    var title = "TPE";
    var
	year, month, day,
	hour = 12,
	offset = 0.09,	// angular distance in deg between primary and secondary markers
	timezone,
	zoom = 13;
    var
	plat,	// latitude of 'from' marker
	plon,	// longitude of 'from' marker
	slat,	// latitude of 'to' marker
	slon;	// longitude of 'to' marker
    var
	CalcDate = new Date(),
	calc_date;

    var loc = new Place();

    if (loc.valid === false)
	return;
    if (loc.setLocation(form) === false)
	return;

    slat = plat = loc.latitude;
    plon = loc.longitude;
    slon = plon + offset;

    flags.initFlags(form);

    // rise and set times: uses first date in range
    if (form.calc_type[0].checked === true) {
	year = form.StartYear.value;
	month = form.StartMonth.selectedIndex + 1;
	day = form.StartDay.selectedIndex + 1;
    }
    // positions: use date
    else {
	year = form.CalcYear.value;
	month = form.CalcMonth.selectedIndex + 1;
	day = form.CalcDay.selectedIndex + 1;
    }

    calc_date = Date.UTC(year, month - 1, day, hour);
    CalcDate.setTime(calc_date);
    // US DST rules are used if this fails
    loc.getDSTLimits(year);

    timezone = Number(loc.timezone.toDMS().replace(/:/, ""));
    timezone += loc.isDST(CalcDate) * 100;
    timezone = timezone.toLeftZeroPadded(4);

    if (timezone.match(/^-/) === null)
	timezone = "+" + timezone;

    url += "?ll="  + plat + "," + plon;
    url += "&sll=" + slat + "," + slon;
    url += "&z=" + zoom;
    url += "&dt=" + year + month.toLeftZeroPadded(2) + day.toLeftZeroPadded(2) +
	(hour * 10e3) + encodeURIComponent(timezone);

    open_url(url, title);
}

// Copy Selected Location button
// set custom location properties to values for the selected location
function copy_place(form)
{
    var
	latitude,
	longitude,
	ndx,
	timezone,
	tz_ndx;
	
    ndx = form.place.selectedIndex;

    if (form.place.options[ndx].text != places[ndx][NAME]) {
	alert(
	    "Location lookup error:"
	    + "\n" + form.place.options[ndx].text
	    + "\n          vs."
	    + "\n" + places[ndx][NAME]
	);
	return false;
    }

    timezone = places[ndx][TZ];

    if ((tz_ndx = get_tz_ndx(timezone)) < 0) {
	alert("Invalid time zone: " + timezone);
	return false;
    }

    form.place_name.value = form.place.options[ndx].text;

    // don't show seconds if the database only has minutes
    if ((latitude = places[ndx][LAT].DMSto()) < 0) {
	if (places[ndx][LAT].match(/:/g).length == 1)	// [d]d:[m]m
	    form.latitude.value = (-latitude).toDMS(-1);
	else						// [d]d:[m]m:[s]s or decimal
	    form.latitude.value = (-latitude).toDMS(0);
	form.lat_sign.selectedIndex = 1;		// S
    }
    else {
	if (places[ndx][LAT].match(/:/g).length == 1)	// [d]d:[m]m
	    form.latitude.value = latitude.toDMS(-1);
	else						// [d]d:[m]m:[s]s or decimal
	    form.latitude.value = latitude.toDMS(0);
	form.lat_sign.selectedIndex = 0;		// N
    }
    if ((longitude = places[ndx][LONG].DMSto()) < 0) {
	if (places[ndx][LONG].match(/:/g).length == 1)	// [dd]d:[m]m
	    form.longitude.value = (-longitude).toDMS(-1);
	else						// [dd]d:[m]m:[s]s or decimal
	    form.longitude.value = (-longitude).toDMS(0);
	form.long_sign.selectedIndex = 1;		// W
    }
    else {
	if (places[ndx][LONG].match(/:/g).length == 1)	// [dd]d:[m]m
	    form.longitude.value = longitude.toDMS(-1);
	else						// [dd]d:[m]m:[s]s or decimal
	    form.longitude.value = longitude.toDMS(0);
	form.long_sign.selectedIndex = 0;		// E
    }

    // index 0 is for determining time zone from longitude
    form.timezone.selectedIndex = tz_ndx + 1;

    if (places[ndx][DST] == 1)
	form.uses_dst.selectedIndex = 1;
    else
	form.uses_dst.selectedIndex = 0;

    if (flags.elevation_in_feet === true)
	form.elevation.value = addCommas(places[ndx][ELEV].MtoFT().toFixed(0));
    else
	form.elevation.value = addCommas(places[ndx][ELEV]);

    SaveState.write(form);

    return true;
}

// Clear button
// clear custom location properties
function clear_custom_location(form)
{
    form.place_name.value = "";

    form.latitude.value = 0;
    form.lat_sign.selectedIndex = 0;	// N
    form.longitude.value = 0;
    form.long_sign.selectedIndex = 1;	// W

    form.timezone.selectedIndex = 0;
    form.uses_dst.selectedIndex = 0;

    form.elevation.value = 0;

    SaveState.write(form);

    return true;
}

// Weather 'Go' button
function weather_lookup(ndx)
{
    var place_name, url;

		// location in database
    if (form.loc_type[0].checked === true) {
	var place_ndx = form.place.options.selectedIndex;
	place_name = form.place[place_ndx].text;
    }
    else	// user-specified location
	place_name = form.place_name.value;

    switch (ndx) {
	case 0:
	    url = "http://www.srh.noaa.gov/";
	    if (place_name !== "")
		url += "zipcity.php?inputstring=" + escape(place_name);
	    break;
	case 1:
	    url = "http://www.wunderground.com/";
	    if (place_name !== "")
		url += "cgi-bin/findweather/getForecast?query=" + escape(place_name);
	    break;
	case 2:
	    url = "https://www.bbc.co.uk/weather/";
	    break;
	default:
	    break;
    }
    open_url(url);
}

// ----------- buttons in Rise and Set Times area ---------------

// 'Copy Positions Date' button
// copy date for calculating positions to start date
function copy_positions_date(form)
{
    form.StartDay.selectedIndex = form.CalcDay.selectedIndex;
    form.StartYear.value = form.CalcYear.value;
    form.StartMonth.selectedIndex = form.CalcMonth.selectedIndex;

    check_dates(form, "start");
}

// 'Copy Start Date' button in Rise and Set Times
// copy start date to end date
function copy_start_date_to_end(form)
{
    form.EndDay.selectedIndex = form.StartDay.selectedIndex;
    form.EndYear.value = form.StartYear.value;
    form.EndMonth.selectedIndex = form.StartMonth.selectedIndex;
}

// 'Rise/Set Criteria...' button
function get_rs_criteria()
{
    var
	OptionsWindow,
	url = "SMCalcRSCriteria.htm",
	title = "Options",
	scale = screen.height / 768,
	wid,
	ht = 320 * scale,
	xpos = 20,
	ypos = 100;

    if (form.RSShowMoonSD.value == "true")
	wid = 980 * scale;
    else
	wid = 920 * scale;

    if (screen.availWidth < 1.1 * wid)
	xpos = 0;

    if (flags.use_all_tabs === false) {
	var
	    win_size = "height=" + ht + ",width=" + wid,
	    win_pos = "left=" + xpos + "," + "top=" + ypos,
	    win_attribs = "resizable=1,menubar=0,toolbar=0,status=0,scrollbars=0",
	    win_features = win_size + "," + win_pos + "," + win_attribs;

	OptionsWindow = window.open(url, title, win_features);
    }
    else
	OptionsWindow = window.open(url, title);
    OptionsWindow.focus();
}

// --------- buttons in Sun and Moon Positions area --------------

// '- 1 day' and '+ 1 day' buttons
function increment_calc_date(form, increment)
{
    var
	CalcDate = new Date(),
	calc_date,
	year = form.CalcYear.value,
	month = form.CalcMonth.selectedIndex,
	day = form.CalcDay.selectedIndex + 1;

    calc_date = Date.UTC(year, month, day);
    CalcDate.setTime(calc_date + increment.DayToMsec());

    form.CalcDay.selectedIndex = CalcDate.getUTCDate() - 1;
    form.CalcYear.value = CalcDate.getUTCFullYear();
    form.CalcMonth.selectedIndex = CalcDate.getUTCMonth();
}

// 'Copy Start Date' button in Sun and Moon Positions
// copy start date to date for calculating positions
function copy_start_date(form)
{
    form.CalcDay.selectedIndex = form.StartDay.selectedIndex;
    form.CalcYear.value = form.StartYear.value;
    form.CalcMonth.selectedIndex = form.StartMonth.selectedIndex;
}

// ------ bottom-of-form buttons (except 'Display' and 'Print') ------

// 'Reset' button
function reset_form(form, flag)
{
    // allow suppression of warning if called noninteractively
    if (form.loaded === true && arguments.length < 2) {
	if (confirm('Reset all values to defaults?') === false)
	    return;
    }

    flags.initFlags(form);

    form.reset();
    form.NextPlace.disabled = true;
    setLocTypeAttrib();
    setCalcTypeAttrib();
    reset_date(form);
    initialize_times(form);

    //loc = new Place();
    SaveState.write(form);
}

// 'Set Current Date' button
// set date to today
function reset_date(form)
{
    var Today = new Date();

    Today.setZeroHours();
    form.StartDay.selectedIndex = Today.getDate() - 1;
    form.StartYear.value = Today.getFullYear();
    form.StartMonth.selectedIndex = Today.getMonth();

    form.EndDay.selectedIndex = form.StartDay.selectedIndex;
    form.EndMonth.selectedIndex = form.StartMonth.selectedIndex;
    form.EndYear.value = form.StartYear.value;

    form.CalcDay.selectedIndex = Today.getDate() - 1;
    form.CalcYear.value = Today.getFullYear();
    form.CalcMonth.selectedIndex = Today.getMonth();

    form.end_date[0].checked = true;
    form.loaded = true;		// mark as loaded
}

// 'Preferences...' button
// Open user preferences form
function get_preferences()
{
    var
	PreferencesWindow,
	url = "SMCalcPreferences.htm",
	title = "Preferences",
	scale = screen.height / 768,
	wid = 575,		// window is narrow; screen width shouldn't matter
	ht = 660 * scale,
	xpos = 15,
	ypos = 10;

    if (screen.availWidth < 1.1 * wid)
	xpos = 0;
    if (screen.availHeight < 1.1 * ht)
	ypos = 0;

    if (flags.use_all_tabs === false) {
	var
	    win_size = "height=" + ht + ",width=" + wid,
	    win_pos = "left=" + xpos + "," + "top=" + ypos,
	    win_attribs = "resizable=1,menubar=0,toolbar=0,status=0,scrollbars=1",
	    win_features = win_size + "," + win_pos + "," + win_attribs;

	PreferencesWindow = window.open(url, title, win_features);
    }
    else
	PreferencesWindow = window.open(url, title);
    PreferencesWindow.focus();
}

// control appearance of top-of-page buttons
function onSMCalcTopMouseOver(id) {
    var elem = document.getElementById(id);

    elem.className = 'SMCalcTopMouseOver';
}

function onSMCalcTopMouseDown(id) {
    var elem = document.getElementById(id);

    elem.className = 'SMCalcTopMouseDown';
}

function onSMCalcTopMouseUp(id) {
    var elem = document.getElementById(id);

    elem.className = 'SMCalcTopMouseOver';
}

function onSMCalcTopMouseOut(id) {
    var elem = document.getElementById(id);

    elem.className = 'SMCalcTop';		// normal appearance
}

// 'Help' button
function help(topic)
{
    var
	HelpWindow,
	url = "SunMoonCalcHelp.htm",
	title = "Help",
	wid = 0.9 * screen.availWidth,
	ht = 0.87 * screen.availHeight,
	xpos = 0.02 * screen.availWidth,
	ypos = 0.005 * screen.availHeight;

    if (topic)
	url += "#" + topic;

    if (flags.use_popups === true) {
	var
	    win_size = "height=" + ht + ",width=" + wid,
	    win_pos = "left=" + xpos + "," + "top=" + ypos,
	    win_attribs = "resizable=1,menubar=1,toolbar=1,status=1,scrollbars=1",
	    win_features = win_size + "," + win_pos + "," + win_attribs;

	HelpWindow = window.open(url, title, win_features);
    }
    else
	HelpWindow = window.open(url, title);

    HelpWindow.focus();

    return true;
}

// 'Tutorial' button
function open_tutorial()
{
    var
	TutorialWindow,
	url = "SMCalcTutorial.htm",
	title = "Tutorial";

    if (flags.use_popups === true) {
	var
	    wid = 0.9 * screen.availWidth,
	    ht = 0.87 * screen.availHeight,
	    xpos = 0.02 * screen.availWidth,
	    ypos = 0.005 * screen.availHeight,
	    win_size = "height=" + ht + ",width=" + wid,
	    win_pos = "left=" + xpos + "," + "top=" + ypos,
	    win_attribs = "resizable=1,menubar=1,toolbar=1,status=1,scrollbars=1",
	    win_features = win_size + "," + win_pos + "," + win_attribs;

	TutorialWindow = window.open(url, title, win_features);
    }
    else
	TutorialWindow = window.open(url, title);
}

// ******************* main calculation section *********************

// 'Display' and 'Print' buttons
// calculate rise/set times or Sun and Moon positions
// output_type: "display" | "print"
function calculate(output_type)
{
    var
	calc_params = new CalcParams(),
	doc_title,
	sun = new Object(),
	moon = new Object(),
	loc = new Place(),
	results,
	rs_opts = new RSCriteria(form),
	time_zone,
	msg;

    if (loc.valid === false)
	return;
    if (loc.setLocation(form) === false)
	return;

    // ensure that user-specified rise/set alts do not fall in
    // "forbidden" range that results from application of refraction
    // correction when body becomes visible
    // get true topocentric altitudes for rise and set
    rs_opts.getTrueAlts(loc);

    // get true topocentric altitude limits
    if (rs_opts.alt_sr_range === true || rs_opts.alt_ss_range === true ||
       rs_opts.tdiff_mr_check === true || rs_opts.tdiff_ms_check === true) 
	rs_opts.getTrueAltLimits(loc);

    if (rs_opts.rs_alts === true) {
	if (check_rs_alts(rs_opts, loc) === false)
	    return;
    }

    flags.initFlags(form);

    if (flags.use_popups === true)
	SCRIPT = SCRIPT.replace(/flags.use_popups *= *false/, "flags.use_popups=true");

    if (output_type == "print") {
	flags.print = true;
	if (flags.use_font_size === true)
	    set_font_size();
    }
    else
	flags.print = false;

    if (calc_params.getCalcParams(form, loc) === false)
	return;

    if (rs_opts.selections === true && calc_params.date_step != 1) {
	msg = 'Search parameters are given but date interval is ' +
	      calc_params.date_step + ' days. Continue?';
	if (confirm(msg) === false)
	    return;
    }

    loc.mag_dec_mean = mag_model.calcMagDec(loc, loc.mag_dec_date);

    if (calc_params.calc_type == POSITIONS) {
	flags.interpolate_rs_positions = false;		// don't bother for only one day
	loc.mag_dec = loc.mag_dec_mean;
	results = positions_results;
    }
    else
	results = times_results;

    // for timing program
    if (flags.time_program === true)
	var program_start = new Date();

    results.calculate_times(calc_params, sun, moon, rs_opts, loc);
    results.build_times_header(rs_opts);

    if (calc_params.calc_type == POSITIONS) {

	calc_params.getCalcTimes(sun, moon, loc);

	// if start time is > 24h LCT, the start event did not occur, so don't bother
	if (calc_params.events_occur === true && calc_params.start_time <= calc_params.ut_24h) {
	    results.calculate_positions(calc_params, sun, moon, loc);
	    results.build_positions_header();
	}
	// show positions from 0h to 24h if sunrise and sunset are
	// specified (default) and they do not occur
	else if (calc_params.checkSunNoPhenom(sun) === true) {
	    msg = calc_params.eventMessage();

	    calc_params.setCalcTimes24h(sun, moon, loc);
	    results.calculate_positions(calc_params, sun, moon, loc);
	    results.build_positions_header(calc_params.SunNoPhenomMessage(sun));
	}
	// if event(s) other than default are specified, assume their
	// occurrence is important to the user; don't show positions if
	// either event does not occur
	else {
	    results.positions.length = 0;
	    results.positions_header= calc_params.eventMessage();
	}
	results.rs_criteria = null;
    }
    else
	results.add_rs_criteria(calc_params, rs_opts);

    if (flags.sep_all_time_pos_windows === true)
	results.name = "";				// every result to a new window
    // if false, both times and positions results to "Results" window
    else if (flags.sep_time_pos_windows === true) {	// separate windows for positions and times
	if (calc_params.calc_type == POSITIONS)
	    results.name = "Positions";
	else
	    results.name = "Times";
    }
    else
	results.name = "Results";	// results from one overwrite results from the other

    if (calc_params.calc_type == POSITIONS)
	doc_title = "Positions";
    else
	doc_title = "Times";

    // add unique identifier for each result window
    if (flags.sep_all_time_pos_windows === true)
	doc_title += makeWindowTag(calc_params.calc_type);

    results.build_doc_head(doc_title);
    results.build_page_top(calc_params, rs_opts, loc);
    results.copyright = copyright;
    results.add_buttons();

    // for timing program
    if (flags.time_program === true)
	results.prog_time = prog_time(program_start);
    else
	results.prog_time = null;

    results.output();

    flags.print = false;
}

/*
 ****************************************************************************
    Rise/Set Criteria, Flags, and Calculaton Parameters
 
 ****************************************************************************
*/

// ********************* Rise/set Criteria object ***************************

function RSCriteria(form)
{
    var
	sr_event = (form.Sunrise.value == "true"),
	ss_event = (form.Sunset.value == "true");

    this.mr_event = (form.Moonrise.value == "true");
    this.ms_event = (form.Moonset.value == "true");

    this.rs_alts = false;
    this.selections = false;
    this.mr_check = false;
    this.ms_check = false;
    this.phase_check = false;
    this.sd_check = false;
    this.show_phase_sd = "transit";

    // ****************** sunrise ********************
    // sunrise altitude
    if (sr_event === true && form.SunriseAltRange.value == "true") {
	this.alt_sr_check = true;
	this.alt_sr_min = form.SunriseAltMin.value.DMSto();
	this.alt_sr_max = form.SunriseAltMax.value.DMSto();
	if (this.alt_sr_min != this.alt_sr_max)
	    this.alt_sr_range = true;
	this.alt_sr_align = form.SunriseAltType.value;
    }
    else {
	this.alt_sr_range = false;
	this.alt_sr_check = false;
	this.alt_sr_min = this.alt_sr_max = 0;
	this.alt_sr_align = "top";
    }
    // mean of nominal altitudes
    this.alt_sr = (this.alt_sr_min + this.alt_sr_max) / 2;

    // sunrise azimuth
    if (sr_event === true && form.SunriseAzRange.value == "true") {
	this.az_sr_check = true;
	this.az_sr_min = form.SunriseAzMin.value.DMSto();
	this.az_sr_max = form.SunriseAzMax.value.DMSto();
    }
    else {
	this.az_sr_check = false;
	this.az_sr_min = 0;
	this.az_sr_max = 180;
    }

    // ****************** sunset ********************
    // sunset altitude
    if (ss_event === true && form.SunsetAltRange.value == "true") {
	this.alt_ss_check = true;
	this.alt_ss_min = form.SunsetAltMin.value.DMSto();
	this.alt_ss_max = form.SunsetAltMax.value.DMSto();
	if (this.alt_ss_min != this.alt_ss_max)
	    this.alt_ss_range = true;
	this.alt_ss_align = form.SunsetAltType.value;
    }
    else {
	this.alt_ss_range = false;
	this.alt_ss_check = false;
	this.alt_ss_min = this.alt_ss_max = 0;
	this.alt_ss_align = "top";
    }
    // mean of nominal altitudes
    this.alt_ss = (this.alt_ss_min + this.alt_ss_max) / 2;

    // sunset azimuth
    if (ss_event === true && form.SunsetAzRange.value == "true") {
	this.az_ss_check = true;
	this.az_ss_min = form.SunsetAzMin.value.DMSto();
	this.az_ss_max = form.SunsetAzMax.value.DMSto();
    }
    else {
	this.az_ss_check = false;
	this.az_ss_min = 180;
	this.az_ss_max = 360;
    }

    // ****************** moonrise ********************
    // moonrise altitude
    if (this.mr_event === true && form.MoonriseAltRange.value == "true") {
	this.alt_mr_check = true;
	this.alt_mr_min = form.MoonriseAltMin.value.DMSto();
	this.alt_mr_max = form.MoonriseAltMax.value.DMSto();
	if (this.alt_mr_min != this.alt_mr_max)
	    this.alt_mr_range = true;
	this.alt_mr_align = form.MoonriseAltType.value;
    }
    else {
	this.alt_mr_range = false;
	this.alt_mr_check = false;
	this.alt_mr_min = this.alt_mr_max = 0;
	this.alt_mr_align = "top";
    }
    // mean of nominal altitudes
    this.alt_mr = (this.alt_mr_min + this.alt_mr_max) / 2;

    // moonrise azimuth
    if (this.mr_event === true && form.MoonriseAzRange.value == "true") {
	this.az_mr_check = true;
	this.az_mr_min = form.MoonriseAzMin.value.DMSto();
	this.az_mr_max = form.MoonriseAzMax.value.DMSto();
    }
    else {
	this.az_mr_check = false;
	this.az_mr_min = 0;
	this.az_mr_max = 180;
    }

    // moonrise phase
    if (this.mr_event === true && form.MoonrisePhaseRange.value == "true") {
	this.phase_mr_check = true;
	this.phase_mr_min = Number(form.MoonrisePhaseMin.value);
	this.phase_mr_max = Number(form.MoonrisePhaseMax.value);

	// RSCriteria form prevents both from being true
	this.phase_mr_waxing = (form.MoonrisePhaseWaxing.value == "true");
	this.phase_mr_waning = (form.MoonrisePhaseWaning.value == "true");
    }
    else {
	this.phase_mr_check = false;
	this.phase_mr_min = 0;
	this.phase_mr_max = 1;
	this.phase_mr_waxing = this.phase_mr_waning = false;
    }

    // moonrise semidiameter
    // ignore if it isn't shown on the Rise/Set Criteria form
    if (flags.rs_show_moon_sd === true)
	this.sd_mr_check = false;
    else if (this.mr_event === true && form.MoonriseSDRange.value == "true") {
	this.sd_mr_check = true;
	this.sd_mr_min = Number(form.MoonriseSDMin.value);
	this.sd_mr_max = Number(form.MoonriseSDMax.value);
    }
    else
	this.sd_mr_check = false;

    // moonrise/Sun event time diff
    if (this.mr_event === true && form.MoonriseTdiff.value == "true")
	this.tdiff_mr_check = true;
    else
	this.tdiff_mr_check = false;

    // control whether add_rs_criteria() indicates time difference--do
    // so if the box is actually checked, but not if tdiff is set to
    // zero by the program
    this.tdiff_mr_specified = this.tdiff_mr_check;

    this.tdiff_mr_min = Number(form.MoonriseTdiffMin.value);
    this.tdiff_mr_max = Number(form.MoonriseTdiffMax.value);
    this.tdiff_mr_type = form.MoonriseTdiffType.value;

    // ****************** moonset *********************
    // moonset altitude
    if (this.ms_event === true && form.MoonsetAltRange.value == "true") {
	this.alt_ms_check = true;
	this.alt_ms_min = form.MoonsetAltMin.value.DMSto();
	this.alt_ms_max = form.MoonsetAltMax.value.DMSto();
	if (this.alt_ms_min != this.alt_ms_max)
	    this.alt_ms_range = true;
	this.alt_ms_align = form.MoonsetAltType.value;
    }
    else {
	this.alt_ms_range = false;
	this.alt_ms_check = false;
	this.alt_ms_min = this.alt_ms_max = 0;
	this.alt_ms_align = "top";
    }
    // mean of nominal altitudes
    this.alt_ms = (this.alt_ms_min + this.alt_ms_max) / 2;

    // moonset azimuth
    if (this.ms_event === true && form.MoonsetAzRange.value == "true") {
	this.az_ms_check = true;
	this.az_ms_min = form.MoonsetAzMin.value.DMSto();
	this.az_ms_max = form.MoonsetAzMax.value.DMSto();
    }
    else {
	this.az_ms_check = false;
	this.az_ms_min = 180;
	this.az_ms_max = 360;
    }

    // moonset phase
    if (this.ms_event === true && form.MoonsetPhaseRange.value == "true") {
	this.phase_ms_check = true;
	this.phase_ms_min = Number(form.MoonsetPhaseMin.value);
	this.phase_ms_max = Number(form.MoonsetPhaseMax.value);

	// RSCriteria form prevents both from being true
	this.phase_ms_waxing = (form.MoonsetPhaseWaxing.value == "true");
	this.phase_ms_waning = (form.MoonsetPhaseWaning.value == "true");
    }
    else {
	this.phase_ms_check = false;
	this.phase_ms_min = 0;
	this.phase_ms_max = 1;
	this.phase_ms_waxing = this.phase_ms_waning = false;
    }

    // moonset semidiameter
    // ignore if it isn't shown on the Rise/Set Criteria form
    if (flags.rs_show_moon_sd === true)
	this.sd_ms_check = false;
    else if (this.ms_event === true && form.MoonsetSDRange.value == "true") {
	this.sd_ms_check = true;
	this.sd_ms_min = Number(form.MoonsetSDMin.value);
	this.sd_ms_max = Number(form.MoonsetSDMax.value);
    }
    else
	this.sd_ms_check = false;

    // moonset/Sun event time diff
    if (this.ms_event === true && form.MoonsetTdiff.value == "true")
	this.tdiff_ms_check = true;
    else
	this.tdiff_ms_check = false;

    // control whether add_rs_criteria() indicates time difference--do
    // so if the box is actually checked, but not if tdiff is set to
    // zero by the program
    this.tdiff_ms_specified = this.tdiff_ms_check;

    this.tdiff_ms_min = Number(form.MoonsetTdiffMin.value);
    this.tdiff_ms_max = Number(form.MoonsetTdiffMax.value);
    this.tdiff_ms_type = form.MoonsetTdiffType.value;

    // ************ flags determined by other flags  ****************
    // flag for non-zero rise or set altitudes or rise/set at center
    if (this.alt_sr_check === true) {
	if (this.alt_sr !== 0 || this.alt_sr_align != "top")
	    this.rs_alts = true;
    }
    if (this.alt_ss_check === true) {
	if (this.alt_ss !== 0 || this.alt_ss_align != "top")
	    this.rs_alts = true;
    }
    if (this.alt_mr_check === true) {
	if (this.alt_mr !== 0 || this.alt_mr_align != "top")
	    this.rs_alts = true;
    }
    if (this.alt_ms_check === true) {
	if (this.alt_ms !== 0 || this.alt_ms_align != "top")
	    this.rs_alts = true;
    }

    // check declination if azimuth limits are given;
    // don't check if only an altitude range is given
    this.decl_sr_check = this.decl_ss_check = false;
    this.decl_mr_check = this.decl_ms_check = false;
    if (this.az_sr_check === true)
	this.decl_sr_check = true;
    if (this.az_ss_check === true)
	this.decl_ss_check = true;
    if (this.az_mr_check === true)
	this.decl_mr_check = true;
    if (this.az_ms_check === true)
	this.decl_ms_check = true;

    // Sun alt range given with moonrise OR moonset event box checked
    this.moon_s_range = false;
    if (((this.mr_event === true && this.ms_event === false) ||
        (this.mr_event === false && this.ms_event === true)) &&
	(this.alt_sr_range === true || this.alt_ss_range === true))
	this.moon_s_range = true;

    if (this.moon_s_range === true) {
	if (this.alt_sr_range === true) {
	    this.alt_moon_s_range = this.alt_sr;
	    // other alignments make little sense
	    this.alt_moon_s_range_align = "center";
	    // use standard values for actual sunrise
	    this.alt_sr = 0;
	    this.alt_sr_align = "top";
	    this.moon_s_range_type = "R";
	}
	else {
	    this.alt_moon_s_range = this.alt_ss;
	    // other alignments make little sense
	    this.alt_moon_s_range_align = "center";
	    // use standard values for actual sunset
	    this.alt_ss = 0;
	    this.alt_ss_align = "top";
	    this.moon_s_range_type = "S";
	}
    }

    this.show_tdiff = null;
    // check and show time diff if Sun alt range is given with ONE Moon event
    if (this.moon_s_range === true) {
	if (this.mr_event === true && this.tdiff_ms_check === false) {
	    this.mr_check = true;
	    if (this.moon_s_range_type == "R")
		this.tdiff_mr_type = "sunrise";
	    else
		this.tdiff_mr_type = "sunset";
	}
	else if (this.ms_event === true && this.tdiff_mr_check === false) {
	    this.ms_check = true;
	    if (this.moon_s_range_type == "R")
		this.tdiff_ms_type = "sunrise";
	    else
		this.tdiff_mr_type = "sunset";
	}
    }

    if (this.phase_mr_check === true || this.phase_ms_check === true)
	this.phase_check = true;

    if (this.sd_mr_check === true || this.sd_ms_check === true)
	this.sd_check = true;

    if (this.decl_mr_check === true || this.phase_mr_check === true ||
      this.sd_mr_check === true || this.tdiff_mr_check === true)
	this.mr_check = true;

    if (this.decl_ms_check === true || this.phase_ms_check === true ||
      this.sd_ms_check === true || this.tdiff_ms_check === true)
	this.ms_check = true;

    // TODO: add this feature?
    if (flags.show_tdiff_all_searches === true) {
	if (this.mr_check === true && this.ms_check === false)
	    this.show_tdiff = "rise";
	else if (this.mr_check === false && this.ms_check === true)
	    this.show_tdiff = "set";
    }
    else {
	if (this.tdiff_mr_check === true && this.tdiff_ms_check === false)
	    this.show_tdiff = "rise";
	else if (this.tdiff_mr_check === false && this.tdiff_ms_check === true)
	    this.show_tdiff = "set";
	if (this.moon_s_range === true && this.mr_check === true)
	    this.show_tdiff = "rise";
	else if (this.moon_s_range === true && this.mr_check === true)
	    this.show_tdiff = "set";
    }
	

    // ****** Sun altitude range rather than Moon-Sun time difference ******

    // if azimuth or phase criteria are given, and no time difference is
    // given but a Sun altitude range is given, set the time difference to
    // zero; override sunset/sunrise buttons in tdiff areas
    if (this.mr_check === true && this.tdiff_mr_check === false) {
	if (this.alt_ss_range === true) {
	    this.tdiff_mr_type = "sunset";
	    this.tdiff_mr_check = true;
	    this.tdiff_mr_min = this.tdiff_mr_max = 0;
	}
	else if (this.alt_sr_range === true) {
	    this.tdiff_mr_type = "sunrise";
	    this.tdiff_mr_check = true;
	    this.tdiff_mr_min = this.tdiff_mr_max = 0;
	}
    }

    if (this.ms_check === true && this.tdiff_ms_check === false) {
	if (this.alt_sr_range === true) {
	    this.tdiff_ms_type = "sunrise";
	    this.tdiff_ms_check = true;
	    this.tdiff_ms_min = this.tdiff_ms_max = 0;
	}
	else if (this.alt_ss_range === true) {
	    this.tdiff_ms_type = "sunset";
	    this.tdiff_ms_check = true;
	    this.tdiff_ms_min = this.tdiff_ms_max = 0;
	}
    }

    // show phase and SD for the appropriate event (rise or set) if
    // possible; othewise show it for transit
    if (this.mr_check === true && this.ms_check === false)
	this.show_phase_sd = "rise";
    else if (this.ms_check === true && this.mr_check === false)
	this.show_phase_sd = "set";

    // Sun azimuth
    if (this.decl_sr_check === true || this.decl_ss_check === true)
	this.selections = true;
    // Moon azimuth or phase
    if (this.mr_check === true || this.ms_check === true)
	this.selections = true;
    // Moon event - Sun event time difference
    if (this.tdiff_mr_check === true || this.tdiff_ms_check === true)
	this.selections = true;
}

// altitudes apply to center of body; adjusted later if necessary
RSCriteria.prototype.getTrueAlts = function(loc)
{
    // true topocentric altitudes
    this.sr_true_alt = appAltToTrueAlt(this.alt_sr, loc);
    this.ss_true_alt = appAltToTrueAlt(this.alt_ss, loc);
    // Sun altitude range for Moon criteria
    if (this.moon_s_range === true)
	this.moon_s_range_true_alt = appAltToTrueAlt(this.alt_moon_s_range, loc);
    this.mr_true_alt = appAltToTrueAlt(this.alt_mr, loc);
    this.ms_true_alt = appAltToTrueAlt(this.alt_ms, loc);
};

// altitudes apply to center of body; adjusted later if necessary
RSCriteria.prototype.getTrueAltLimits = function(loc)
{
    // true topocentric altitudes
    this.sr_true_alt_min = appAltToTrueAlt(this.alt_sr_min, loc);
    this.sr_true_alt_max = appAltToTrueAlt(this.alt_sr_max, loc);

    this.ss_true_alt_min = appAltToTrueAlt(this.alt_ss_min, loc);
    this.ss_true_alt_max = appAltToTrueAlt(this.alt_ss_max, loc);

    this.mr_true_alt_min = appAltToTrueAlt(this.alt_mr_min, loc);
    this.mr_true_alt_max = appAltToTrueAlt(this.alt_mr_max, loc);
    
    this.ms_true_alt_min = appAltToTrueAlt(this.alt_ms_min, loc);
    this.ms_true_alt_max = appAltToTrueAlt(this.alt_ms_max, loc);
};

// get topocentric declination limits for Sun and Moon rise and set
// always refer to center of body
RSCriteria.prototype.getDeclLimits = function(type, loc)
{
    var limits = new Object();
    
    switch (type) {
	case "sunrise":
	    limits.alt_min = this.alt_sr_min;
	    limits.alt_max = this.alt_sr_max;
	    limits.az_min = this.az_sr_min;
	    limits.az_max = this.az_sr_max;
	    break;
	case "sunset":
	    limits.alt_min = this.alt_ss_min;
	    limits.alt_max = this.alt_ss_max;
	    limits.az_min = this.az_ss_min;
	    limits.az_max = this.az_ss_max;
	    break;
	case "moonrise":
	    limits.alt_min = this.alt_mr_min;
	    limits.alt_max = this.alt_mr_max;
	    limits.az_min = this.az_mr_min;
	    limits.az_max = this.az_mr_max;
	    break;
	case "moonset":
	    limits.alt_min = this.alt_ms_min;
	    limits.alt_max = this.alt_ms_max;
	    limits.az_min = this.az_ms_min;
	    limits.az_max = this.az_ms_max;
	    break;
	default:
	    break;
    }

    /*
	convert to true north using magnetic declination for middle of
	calculation period if magnetic north display specified
    */
    if (flags.show_mag_north === true) {
	limits.az_min += loc.mag_dec_mean;
	limits.az_max += loc.mag_dec_mean;
    }

    // true topocentric altitude
    limits.alt_min = appAltToTrueAlt(limits.alt_min, loc);
    limits.alt_max = appAltToTrueAlt(limits.alt_max, loc);

    calcDeclLimits(loc, limits);

    switch (type) {
	case "sunrise":
	    this.decl_sr_min = limits.decl_min;
	    this.decl_sr_max = limits.decl_max;
	    break;
	case "sunset":
	    this.decl_ss_min = limits.decl_min;
	    this.decl_ss_max = limits.decl_max;
	    break;
	case "moonrise":
	    this.decl_mr_min = limits.decl_min;
	    this.decl_mr_max = limits.decl_max;
	    break;
	case "moonset":
	    this.decl_ms_min = limits.decl_min;
	    this.decl_ms_max = limits.decl_max;
	    break;
	default:
	    break;
    }

    return 0;
};

// rate of change dA/dh of azimuth with altitude
function calc_dAdh(alt, az, loc)
{
    var lat, dAdh;

    lat = loc.latitude;

    lat = lat.DtoR();
    alt = alt.DtoR();
    az  = az.DtoR();

    dAdh = Math.tan(lat) / Math.sin(az) - Math.tan(alt) / Math.tan(az);

    return dAdh;
}

// rate of change dh/dt of altitude with time
function calc_dhdt(body, az, loc)
{
    var d_GHA, dhdt;
    var cos_lat = loc.cos_lat;

    if (body == "Sun")
	d_GHA = 15;
    else
	d_GHA = 14.493;

    az = az.DtoR();

    // from Yallop and Hohenkerk (1992, 489)
    // rate of change of altitude with time
    dhdt = cos_lat * Math.sin(az) * d_GHA;

    return dhdt;	// deg/hr
}

// alt in deg
// returns hour angle in hours, 0-12
function calcHourAngleFromAlt(alt, sin_decl, cos_decl, sin_lat, cos_lat)
{
    var arg;

    alt = alt.DtoR();

    arg = (Math.sin(alt) - sin_lat * sin_decl) / (cos_lat * cos_decl);
    if (arg > 1)
	return 0;
    else if (arg < -1)
	return 12;
    else
	return Math.acos(arg).RtoH();
}

// az in deg; returns hour angle in hours, -12 to 0 for rise, 0-12 for set
// adapted from Yallop, Hohenkerk, & Bell (2013, 518, Eq. 12.21)
function calcHourAngleFromAz(az, decl, sin_decl, cos_decl, loc, HA)
{
    var
	tan_az = Math.tan(az.DtoR()),
	tan_decl = sin_decl / cos_decl,
	a, b, dscr,
	sign;

    var arg, arg1, arg2, nroots;

    var
	sin_lat = loc.sin_lat,
	cos_lat = loc.cos_lat;

    a = sin_lat * tan_az;
    b = -cos_lat * tan_decl * tan_az;
    dscr = 1 + Math.square(a) - Math.square(b);

    // assume rounding error; fix it
    if (dscr < 0 && Math.abs(dscr) < 1e-12)
	dscr = 0;

    if (dscr < 0) {	// no roots: az is not reached
	HA[0] = HA[1] = -999;
	nroots = 0;
    }
    else if (Math.abs(decl.RtoD()) > Math.abs(loc.latitude) && dscr > 0) {	// two roots
	arg1 = (-a * b + Math.sqrt(dscr)) / (1 + Math.square(a));
	arg2 = (-a * b - Math.sqrt(dscr)) / (1 + Math.square(a));

	if (arg1 > 1)
	    HA[0] = 0;
	else if (arg1 < -1)
	    HA[0] = 12;
	else
	    HA[0] = Math.acos(arg1).RtoH();

	if (arg2 > 1)
	    HA[1] = 0;
	else if (arg2 < -1)
	    HA[1] = 12;
	else
	    HA[1] = Math.acos(arg2).RtoH();

	nroots = 2;
    }
    else {	// one root
	if (az == 90 || az == 270)
	    arg = -b / a;
	else {
	    // for south transit
	    if (az > 90 && az < 270)
		sign = 1;
	    else
		sign = -1;

	    // reverse sign of radical for north transit
	    if (decl.RtoD() > loc.latitude)
		sign = -sign;

	    arg = (-a * b + sign * Math.sqrt(dscr)) / (1 + Math.square(a));
	}

	if (arg > 1)
	    HA[0] = 0;
	else if (arg < -1)
	    HA[0] = 12;
	else
	    HA[0] = Math.acos(arg).RtoH();
	HA[1] = HA[0];		// should not be necessary, but just in case ...
	nroots = 1;
    }
    // reverse sign(s) to give as -12h to 0h
    if (az < 180) {
	switch (nroots) {
	    case 0:
		break;
	    case 2:
		HA[0] = -HA[0];
		HA[1] = -HA[1];
		break;
	    case 1:
		HA[0] = -HA[0];
		break;
	    default:
		break;
	}
    }

    return nroots;
}

//FIXME? not used ...
function calcAzFromHourAngle(lha, sin_lat, cos_lat, sin_decl, cos_decl)
{
    lha = lha.DtoR();
    var sinH = Math.sin(lha);
    var cosH = Math.cos(lha);
    var az;

    az = Math.atan2(-cos_decl * sinH,
		     cos_lat * sin_decl - sin_lat * cos_decl * cosH).RtoD();
    return az.setRange(360);
}

// determine minimum and maximum azimuths that occur for rise or set for
// given latitude and declination
function calcMinMaxAz(decl, sin_decl, cos_decl, loc, type, minmax)
{
    var cosH, lha, lat, sin_lat, cos_lat, tan_lat, tan_decl, az_limit;
    var eps = 1e-12;

    lat = loc.latitude;
    // all azimuths reached
    if (Math.abs(decl.RtoD()) < Math.abs(lat)) {
	if (type == "R") {
	    minmax[0] = 0;
	    minmax[1] = 180;
	}
	else {
	    minmax[0] = 180;
	    minmax[1] = 360;
	}
    }
    // not all azimuths reached
    // not a likely occurrence ...
    else if (Math.abs(decl.RtoD()) == Math.abs(lat)) {
	// north transit--az = 90-270
	if (decl.RtoD() >= lat) {
	    if (type == "R") {
		minmax[0] = 90;
		minmax[1] = 180;
	    }
	    else {
		minmax[0] = 180;
		minmax[1] = 270;
	    }
	}
	// south transit--az = 0-90 rise, 270-360 set
	else {
	    if (type == "R") {
		minmax[0] = 0;
		minmax[1] = 90;
	    }
	    else {
		minmax[0] = 270;
		minmax[1] = 360;
	    }
	}
    }
    // not all azimuths reached
    else {
	sin_lat = loc.sin_lat;
	cos_lat = loc.cos_lat;
	tan_lat  = sin_lat  / cos_lat;
	tan_decl = sin_decl / cos_decl;

	cosH = tan_lat / tan_decl;	// hour angle of zero of dA/dH

	lha = Math.abs(Math.acos(cosH));
	if (type == "R")
	    lha = -lha;

	// azimuth at zero of dA/dH
	// atan2() returns -PI to PI; add 180 deg to make it 0 to 360
	az_limit = Math.atan2(Math.sin(lha), sin_lat * cosH - cos_lat * tan_decl).RtoD() + 180;

	// north transit; az jumps from 0 to 360 deg @ H=0
	// zero is local maximum for rise, local minimum for set
	if (decl.RtoD() >= lat) {
	    if (type == "R") {
		minmax[0] = 0;
		minmax[1] = az_limit - eps;		// arbitrary cushion
	    }
	    else {
		minmax[0] = az_limit + eps;		// arbitrary cushion
		minmax[1] = 360;
	    }
	}
	// south transit; az curve continuous as it crosses 180 deg @ H=0
	// zero is minimum for rise, maximum for set
	else {
	    if (type == "R") {
		minmax[0] = az_limit + eps;		// arbitrary cushion
		minmax[1] = 180;
	    }
	    else {
		minmax[0] = 180;
		minmax[1] = az_limit - eps;		// arbitrary cushion
	    }
	}
    }
}

/*
    Times for body to move between az/alt limits.
    Used for Moon az/alt range and Sun az/alt range given with Moon
    az/alt range.

    returns
	t_limits[0] = time of entering az/alt range
	t_limits[1] = time of leaving az/alt range
*/
RSCriteria.prototype.getLimitTimes = function(body, pos, type, loc, t_limits)
{
    var
	d_GHA,			// hour angle change, deg/hr
	alt, alt_min, alt_max,	// altitudes in degrees
	alt_rs_align,		// "top"|"center"|"bottom"
	alt_time,		// time of midpoint altitude crossing
	az,			// azimuth at altitude crossing
	az_min, az_max,		// minimum and maximum altitudes
	az_check,		// true|false
	sd;			// semidiameter at rise or set

    // "fudge factor" to compensate for inaccuracy of expansions over
    // wide ranges of altitude, azimuth, or both
    var dt_h_fudge, dt_A_fudge;

    if (body.name == "Sun") {
	dt_h_fudge = 1;
	dt_A_fudge = 1;
    }
    else {
	dt_h_fudge = 1.02;
	dt_A_fudge = 1.02;
    }

    var
	sin_lat = loc.sin_lat,
	cos_lat = loc.cos_lat;

    if (body.name == "Sun") {
	d_GHA = 15;		// deg/hr--mean value
	if (type == "R") {	// sunrise
	    alt_min = this.sr_true_alt_min;
	    alt_max = this.sr_true_alt_max;

	    // approximate midpoint of Sun altitude range given with
	    // Moon az/alt range
	    // only one event--rise OR set--for any given search
	    // should always be true when this method is called
	    if (this.moon_s_range === true) {
		//alt     = this.moon_s_range_true_alt;
		alt     = this.moon_s_range_true_alt_adj;
		alt_rs_align = this.alt_moon_s_range_align;
	    }
	    else {	// normal sunrise
		// should never get here ...
		alt     = this.sr_true_alt;
		alt_rs_align = this.alt_sr_align;
	    }

	    az_min = this.az_sr_min;
	    az_max = this.az_sr_max;
	    az_check = this.az_sr_check;
	}
	else {			// sunset
	    alt_min = this.ss_true_alt_min;
	    alt_max = this.ss_true_alt_max;

	    // Sun altitude range given with Moon az range
	    // only one event--rise or set--for any given search
	    // should always be true when this method is called
	    if (this.moon_s_range === true) {
		alt     = this.moon_s_range_true_alt_adj;
		alt_rs_align = this.alt_moon_s_range_align;
	    }
	    else {	// normal sunset
		// should never get here ...
		alt     = this.ss_true_alt;
		alt_rs_align = this.alt_ss_align;
	    }

	    az_min = this.az_ss_min;
	    az_max = this.az_ss_max;
	    az_check = this.az_ss_check;
	}
    }
    else {			// Moon
	d_GHA = 14.493;		// deg/hr--mean value
	if (type == "R") {	// moonrise
	    alt_min = this.mr_true_alt_min;
	    alt_max = this.mr_true_alt_max;
	    alt     = this.mr_true_alt;
	    alt_rs_align = this.alt_mr_align;
	    az_min = this.az_mr_min;
	    az_max = this.az_mr_max;
	    az_check = this.az_mr_check;
	}
	else {			// moonset
	    alt_min = this.ms_true_alt_min;
	    alt_max = this.ms_true_alt_max;
	    alt     = this.ms_true_alt;
	    alt_rs_align = this.alt_ms_align;
	    az_min = this.az_ms_min;
	    az_max = this.az_ms_max;
	    az_check = this.az_ms_check;
	}
    }

    var
	decl, sin_decl, cos_decl,	// declination in radians
	lha0,
	lha, lha_h_high, lha_h_low;	// hour angles in hours
    var t_h1, t_h2;			// times of altitude limit crossings
    var jday;
    var minalt, maxalt;			// min, max alts reached during day

    // topocentric values
    // Sun altitude range given with Moon az range
    // only one event--rise or set--for any given search
    if (body.name == "Sun" && this.moon_s_range === true) {
	az   = body.az_moon_s_range;
	sd   = body.sd_moon_s_range;
	decl = body.decl_moon_s_range;
	alt_time = body.moon_s_range_mid;
    }

    // for Sun or Moon
    else if (type == "R") {
	az   = body.az_rise;
	sd   = body.sd_r;
	decl = body.decl_rise;
	alt_time = body.rise;
    }
    else {	// set
	az   = body.az_set;
	sd   = body.sd_s;
	decl = body.decl_set;
	alt_time = body.set;
    }
    minalt = body.minalt_true;
    maxalt = body.maxalt_true;

    // adjust for semidiameter if necessary
    if (alt_rs_align == "top") {
	alt_min -= sd;
	alt_max -= sd;
	alt     -= sd;
    }
    else if (alt_rs_align == "bottom") {
	alt_min += sd;
	alt_max += sd;
	alt     += sd;
    }

    jday = body.jday;
    sin_decl = Math.sin(decl);
    cos_decl = Math.cos(decl);

    // ******************* times for altitude limits  *************************

    // topocentric hour angle of altitude crossings
    lha         = calcHourAngleFromAlt(alt,     sin_decl, cos_decl, sin_lat, cos_lat);
    // if alt_min < min alt for body, H is that of min alt
    lha_h_low   = calcHourAngleFromAlt(alt_min, sin_decl, cos_decl, sin_lat, cos_lat);
    // if alt_max > max alt for body, H is that of max alt
    lha_h_high  = calcHourAngleFromAlt(alt_max, sin_decl, cos_decl, sin_lat, cos_lat);

    // returned LHA is 0-12h, so signs for rise are reversed
    if (type == "R") {
	lha = -lha;
	lha_h_low = -lha_h_low;
	lha_h_high = -lha_h_high;
    }

    // get the times to move between alt and alt_max, and alt_min and alt
    // returned LHA is 0-12h, so alt always decreases with increasing LHA
    dt_h_low   = (lha_h_low  - lha).HtoD() / d_GHA;	// neg for rise, pos for set
    dt_h_high  = (lha_h_high - lha).HtoD() / d_GHA;	// pos for rise, neg for set

    if (type == "R") {		// rise; dh/dt > 0; low altitude reached first
	dt_h1 = dt_h_low;
	dt_h2 = dt_h_high;
    }
    else {			// set; dh/dt < 0; high altitude reached first
	dt_h1 = dt_h_high;
	dt_h2 = dt_h_low;
    }
    dt_h1 *= dt_h_fudge;
    dt_h2 *= dt_h_fudge;

    t_h1 = alt_time + dt_h1;	// time of entering alt range
    t_h2 = alt_time + dt_h2;	// time of leaving alt range

    // ******************* times for azimuth limits ***************************

    // azimuth not checked--use times of altitude limit crossings
    if (az_check === false) {
	t_limits[0] = t_h1;
	t_limits[1] = t_h2;
    }
    else { 	// azimuth checked--find az limit times
	var
	    dA1, dA2,
	    dt_A1, dt_A2,
	    dt_A_min,
	    dt_A_max,
	    lha_A_min,
	    lha_A_max,
	    az_day_minmax = [];	// min/max az reached on given day
	var
	    nroots,
	    HA = [],		// min, max az crossings
	    HA_min = [],	// min az crossings
	    HA_max = [];	// max az crossings
	var t_az_min, t_az_max;
	var t_A1, t_A2;
	var transit;		// N|S
	var az_type;		// min|max

	// compute LHAs at azimuth limit crossings; declination is that
	// at time of altitude crossing

	// ---------- abs(decl) > abs(lat) --------------------------
	// azimuth range restricted; each azimuth occurs twice

	var az_pad = 0.5; // deg

	// az_min = specified lower az limit
	// az_max = specified upper az limit
	// min az = minimum azimuth that occurs on date
	// max az = maximum azimuth that occurs on date

	// "transit" is somewhat of a misnomer because the declination
	// is that at the time of altitude crossing rather than transit
	if (Math.abs(decl.RtoD()) > Math.abs(loc.latitude)) {
	    if (decl.RtoD() < loc.latitude)
		transit = "S";
	    else
		transit = "N";

	    switch (transit + type) {
		case "SR":
		case "NS":
		    az_type = "min";
		    break;
		case "SS":
		case "NR":
		    az_type = "max";
		    break;
		default:
		    az_type = "invalid";// FIXME? what to do if this happens?
		    break;
	    }

	    calcMinMaxAz(decl, sin_decl, cos_decl, loc, type, az_day_minmax);

	    // not in azimuth range: can this ever happen if az/alt criteria are met?
	    if (az_day_minmax[1] < az_min  || az_day_minmax[0] > az_max)
		return false;

	    // az has minimum value: rise for south transit or set for north transit
	    if (az_type == "min") {
		if (az_day_minmax[0] < az_min - az_pad) {	// two intervals
		    // LHAs of az_min crossing
		    nroots = calcHourAngleFromAz(az_min, decl, sin_decl, cos_decl, loc, HA_min);
		    if (nroots === 0)	// should not happen ...
			return false;
		}
		// else min not needed--use LHAs of max az crossing

		// LHA(s) of az_max crossing
		nroots = calcHourAngleFromAz(az_max, decl, sin_decl, cos_decl, loc, HA_max);
		if (nroots === 0)	// should not happen ...
		    return false;

		// max az reached = az_max--presumably a rare occurrence
		if (nroots == 1)
		    lha_A_min = lha_A_max = HA_min[0];
		// one continuous interval if min az reached is > az_min; also treat as such
		// if min az reached not more than az_pad < az_min
		else if (az_day_minmax[0] >= az_min - az_pad) {
		    lha_A_min = HA_max[0];
		    lha_A_max = HA_max[1];
		}
		else {			// two intervals; pick one
		    // choose az_min crossing closest to alt crossing
		    if (Math.abs(lha - HA_min[0]) <= Math.abs(lha - HA_min[1])) {
			lha_A_min = HA_max[0];
			lha_A_max = HA_min[0];
		    }
		    else {
			lha_A_min = HA_min[1];
			lha_A_max = HA_max[1];
		    }
		}
	    }
	    // az has maximum value: rise for north transit or set for south transit
	    else {
		if (az_day_minmax[1] > az_max + az_pad) {	// two intervals
		    // LHAs of az_max crossing
		    nroots = calcHourAngleFromAz(az_max, decl, sin_decl, cos_decl, loc, HA_max);
		    if (nroots === 0)	// should not happen ...
			return false;
		}
		// else max not needed--use LHAs of min az crossing

		// LHA(s) of az_min crossing
		nroots = calcHourAngleFromAz(az_min, decl, sin_decl, cos_decl, loc, HA_min);
		if (nroots === 0)	// should not happen ...
		    return false;

		// min az reached = az_min--presumably a rare occurrence
		if (nroots == 1)
		    lha_A_min = lha_A_max = HA_min[0];
		// one continuous interval if max az < az_max; also treat as such
		// if max az reached is not more than az_pad > az_max
		else if (az_day_minmax[1] <= az_max + az_pad) {
		    lha_A_min = HA_min[0];
		    lha_A_max = HA_min[1];
		}
		else {			// two intervals; pick one
		    // choose az_min crossing closest to alt crossing
		    if (Math.abs(lha - HA_max[0]) <= Math.abs(lha - HA_max[1])) {
			lha_A_min = HA_min[0];
			lha_A_max = HA_max[0];
		    }
		    else {
			lha_A_min = HA_max[1];
			lha_A_max = HA_min[1];
		    }
		}
	    }
	}
	// ---------- abs(decl) <= abs(lat) -------------------------
	// az range not restricted; azimuths occur once
	else {
	    calcHourAngleFromAz(az_min, decl, sin_decl, cos_decl, loc, HA);
	    lha_A_min = HA[0];
	    calcHourAngleFromAz(az_max, decl, sin_decl, cos_decl, loc, HA);
	    lha_A_max = HA[0];
	}

	// get times from hour angles

	// times to move from alt crossing to min and max az limits
	dt_A_min = (lha_A_min - lha).HtoD() / d_GHA;
	dt_A_max = (lha_A_max - lha).HtoD() / d_GHA;

	// min azimuth reached first; dA/dt > 0
	if (lha_A_max > lha_A_min) {
	    dt_A1 = dt_A_min;
	    dt_A2 = dt_A_max;
	}
	// max azimuth reached first; dA/dt < 0
	else {
	    dt_A1 = dt_A_max;
	    dt_A2 = dt_A_min;
	}

	// LHA always increases with time, but values above
	// are always returned 0-12 hr, so values for rise have sign
	// reversed

	dt_A1 *= dt_A_fudge;
	dt_A2 *= dt_A_fudge;
	t_A1 = alt_time + dt_A1;
	t_A2 = alt_time + dt_A2;

	t_limits[0] = Math.max(t_h1, t_A1);
	t_limits[1] = Math.min(t_h2, t_A2);
    }

    return true;
};

// find dates that meet specified criteria for rise and set
RSCriteria.prototype.select = function(jday, sun, moon, spos, mpos, loc)
{
    var
	t_limits = [],
	t_min, t_max,		// min,max times for Moon criteria to be met
	t_moon_min, t_moon_max;	// min,max times when Moon is within az/alt range

    var cos_lat = loc.cos_lat;

    if (this.selections === false)
	return true;

    if (this.decl_sr_check === true) {
	if (sun.az_rise === null)
	    return false;
	else if (sun.decl_rise < this.decl_sr_min || sun.decl_rise > this.decl_sr_max)
	    return false;
    }

    if (this.decl_ss_check === true) {
	if (sun.az_set === null)
	    return false;
	else if (sun.decl_set < this.decl_ss_min || sun.decl_set > this.decl_ss_max)
	    return false;
    }

    // ********* moonrise ****************
    if (this.mr_check === true) {
	if (moon.az_rise === null)	// no moonrise
	    return false;

	// moonrise altitude/azimuth
	if (this.decl_mr_check === true) {
	    if (moon.decl_rise < this.decl_mr_min || moon.decl_rise > this.decl_mr_max)
		return false;
	}

	// moonrise phase
	if (this.phase_mr_check === true) {
	    if (moon.phase_r < this.phase_mr_min || moon.phase_r > this.phase_mr_max)
		return false;
	    if (this.phase_mr_waxing === true && moon.waxing_r === false)
		return false;
	    if (this.phase_mr_waning === true && moon.waxing_r === true)
		return false;
	}

	// moonrise semidiameter
	if (this.sd_mr_check === true) {
	    if (moon.sd_r < this.sd_mr_min || moon.sd_r > this.sd_mr_max)
		return false;
	}

	// moonrise-Sun event time difference or Sun altitude range
	if (this.tdiff_mr_check === true) {
	    if (this.tdiff_mr_type == "sunset") {	// moonrise - sunset
		if (sun.az_set === null)		// no sunrise
		    return false;

		// time limits for which Sun is within alt/az range
		if (this.moon_s_range === true) {
		    if (getRangeAltCrossing(jday, sun, spos, this, loc) === false)
			return false;
		    if (this.getLimitTimes(sun, spos, "S", loc, t_limits) === false)
			return false;
		    t_min = t_limits[0];
		    t_max = t_limits[1];
		}
		// time difference from sunset
		else {
		    t_min = sun.set + this.tdiff_mr_min / 60;
		    t_max = sun.set + this.tdiff_mr_max / 60;
		}
	    }
	    else {					// moonrise - sunrise
		if (sun.az_rise === null)		// no sunrise
		    return false;

		// time limits for which Sun is within alt/az range
		if (this.moon_s_range === true) {
		    if (getRangeAltCrossing(jday, sun, spos, this, loc) === false)
			return false;
		    if (this.getLimitTimes(sun, spos, "R", loc, t_limits) === false)
			return false;
		    t_min = t_limits[0];
		    t_max = t_limits[1];
		}
		// time difference from sunrise
		else {
		    t_min = sun.rise + this.tdiff_mr_min / 60;
		    t_max = sun.rise + this.tdiff_mr_max / 60;
		}
	    }
	    // time limits for which Moon is within az/alt range
	    if (this.alt_mr_range === true) {
		if (this.getLimitTimes(moon, mpos, "R", loc, t_limits) === false)
		    return false;
		t_moon_min = t_limits[0];
		t_moon_max = t_limits[1];
	    }
	    else	// single Moon altitude
		t_moon_min = t_moon_max = moon.rise;

	    // Moon and Sun time ranges must overlap
	    if (t_moon_min > t_max || t_moon_max < t_min)
		return false;
	}
    }

    // ********* moonset ****************
    if (this.ms_check === true) {
	if (moon.az_set === null)	// no moonset
	    return false;

	// moonset altitude/azimuth
	if (this.decl_ms_check === true) {
	    if (moon.decl_set < this.decl_ms_min || moon.decl_set > this.decl_ms_max)
		return false;
	}
	
	// moonset phase
	if (this.phase_ms_check === true) {
	    if (moon.phase_s < this.phase_ms_min || moon.phase_s > this.phase_ms_max)
		return false;
	    if (this.phase_ms_waxing === true && moon.waxing_s === false)
		return false;
	    if (this.phase_ms_waning === true && moon.waxing_s === true)
		return false;
	}

	// moonset semidiameter
	if (this.sd_ms_check === true) {
	    if (moon.sd_s < this.sd_ms_min || moon.sd_s > this.sd_ms_max)
		return false;
	}

	// moonset-Sun event time difference or Sun altitude range
	if (this.tdiff_ms_check === true) {
	    if (this.tdiff_ms_type == "sunset") {	// moonset - sunset
		if (sun.az_set === null)		// no sunset
		    return false;

		// time limits for which Sun is within alt/az range
		if (this.moon_s_range === true) {
		    if (getRangeAltCrossing(jday, sun, spos, this, loc) === false)
			return false;
		    if (this.getLimitTimes(sun, spos, "S", loc, t_limits) === false)
			return false;
		    t_min = t_limits[0];
		    t_max = t_limits[1];
		}
		else {
		    // time difference from sunset
		    t_min = sun.set + this.tdiff_ms_min / 60;
		    t_max = sun.set + this.tdiff_ms_max / 60;
		}
	    }
	    else {					// moonset - sunrise
		if (sun.az_rise === null)		// no sunrise
		    return false;

		// time limits for which Sun is within alt/az range
		if (this.moon_s_range === true) {
		    if (getRangeAltCrossing(jday, sun, spos, this, loc) === false)
			return false;
		    if (this.getLimitTimes(sun, spos, "R", loc, t_limits) === false)
			return false;
		    t_min = t_limits[0];
		    t_max = t_limits[1];
		}
		else {
		    // time difference from sunrise
		    t_min = sun.rise + this.tdiff_ms_min / 60;
		    t_max = sun.rise + this.tdiff_ms_max / 60;
		}
	    }

	    // time limits for which Moon is within az/alt range
	    if (this.alt_ms_range === true) {
		if (this.getLimitTimes(moon, mpos, "S", loc, t_limits) === false)
		    return false;
		t_moon_min = t_limits[0];
		t_moon_max = t_limits[1];
	    }
	    else	// single Moon altitude
		t_moon_min = t_moon_max = moon.set;

	    // Moon and Sun time ranges must overlap
	    if (t_moon_min > t_max || t_moon_max < t_min)
		return false;
	}
    }

    return true;
};

// ********************* Flag object ***************************

function initFlags(form)
{
    var ndx;

    // position calculations extend to next day(s)
    this.next_day = false;	// set by getCalcTimes()
    
    // window behavior
    this.sep_time_pos_windows = (form.SepTimePosWindows.value == "true");

    this.sep_all_time_pos_windows = (form.SepAllTimePosWindows.value == "true");

    this.use_popups = (form.UsePopups.value == "true");

    this.use_all_tabs = (form.UseAllTabs.value == "true");

    // location search
    this.show_search = (form.ShowSearch.value == "true");

    this.use_REs = (form.UseREs.value == "true");

    // List Locations report
    this.show_mag_dec = (form.ShowMagDec.value == "true");

    this.show_dst_rules = (form.ShowDSTRules.value == "true");

    this.show_dst_dates = (form.ShowDSTDates.value == "true");

    // time format
    this.show_am_pm_time = (form.ShowAMPMTime.value == "true");

    // time display options
    this.show_dst = (form.ShowDST.value == "true");

    this.show_ut = (form.ShowUT.value == "true");

    // azimuth display
    this.show_mag_north = (form.ShowMagNorth.value == "true");

    // elevation and height units
    this.elevation_in_feet = (form.ElevationInFeet.value == "true");

    // show times of astronomical and nautical twilight
    this.show_all_twilight = (form.ShowAllTwilight.value == "true");


    // calculation options
    this.interpolate_rs_positions = (form.InterpolateRSPositions.value == "true");

    // Rise/Set Criteria options
    this.rs_show_moon_sd = (form.RSShowMoonSD == "true");

    // always indicate whether Moon is waxing or waning by appending '+'
    // or '-' to phase
    this.always_show_wax_wane = (form.AlwaysShowWaxWane.value == "true");

    // show Moon-Sun time difference for all searches
    this.show_tdiff_all_searches = (form.ShowTdiffAllSearches.value == "true");

    // miscellaneous options
    this.enable_inactive_inputs = (form.EnableInactiveInputs.value == "true");

    // obsolte--eliminated in version 4.6.4
    //this.show_copy_dates = (form.ShowCopyDates.value == "true");
    this.show_copy_dates = false;

    this.show_check_places = (form.ShowCheckPlaces.value == "true");

    this.show_az_adjust = (form.ShowAzAdjust.value == "true");

    this.time_program = (form.TimeProgram.value == "true");

    this.use_font_size = (form.UseFontSize.value == "true");

    this.font_size = form.FontSize.value;
}

function Flag()
{
    ;
}

Flag.prototype.initFlags = initFlags;

// ********************* calculation parameters object ***************************

function CalcParams()
{
    // maximum number of calculations for rise/set time
    this.MAX_DAY_CALC = 36525;		// 100 years for 1-day steps

    // for event times
    this.start_date = -999999;
    this.end_date = -999999;
    this.date_step = 1;

    // for Sun and Moon positions
    this.time_start_type = -99;		// event or specified time
    this.time_end_type = -99;		// event or specified time
    this.start_time = -99;
    this.end_time = -99;
    this.time_step = 1;
}

CalcParams.prototype.getCalcParams = getCalcParams;

CalcParams.prototype.getEvent = function(type, sun, moon)
{
    var event;

    switch(type) {
	case 1:
	    event = sun.dawn;
	    break;
	case 2:
	    event = sun.rise;
	    break;
	case 3:
	    event = sun.transit;
	    break;
	case 4:
	    event = sun.set;
	    break;
	case 5:
	    event = sun.dusk;
	    break;
	case 6:
	    event = moon.rise;
	    break;
	case 7:
	    event = moon.transit;
	    break;
	case 8:
	    event = moon.set;
	    break;
	default:
	    break;
    }

    return event;
};

CalcParams.prototype.getCalcTimes = function(sun, moon, loc)
{
    var
	CalcDate = new Date(),
	event_time,
	offset,
	start_date = this.start_date,
	ut_offset,
	time_step = this.time_step;

    if (this.time_start_type > 0) { 	// time relative to event
	event_time = this.getEvent(this.time_start_type, sun, moon);
	if (Math.abs(event_time) > F_TEST_NO_EVENT)
	    this.start_time = null;
	else {
	    offset = this.start_event_offset;
	    this.start_time = event_time + offset;
	    // apply rounding to local time rather than UT so that
	    // fractional time zones work properly
	    this.start_time += loc.ut_offset;
	    if (time_step > 1 / 60 || offset === 0)
		this.start_time = Math.floor(this.start_time / time_step) * time_step;
	    else
		// round to nearest minute
		this.start_time = Math.round(this.start_time / time_step) * time_step;
	    // restore to UT
	    this.start_time -= loc.ut_offset;
	}
    }

    if (this.time_end_type == -1)		// offset to start time
	this.end_time = this.start_time + this.t_offset;
    else if (this.time_end_type > 0) { 	// time relative to event
	event_time = this.getEvent(this.time_end_type, sun, moon);
	if (Math.abs(event_time) > F_TEST_NO_EVENT)
	    this.end_time = null;
	else if (event_time > this.ut_24h)
	    this.end_time = this.ut_24h;
	else {
	    offset = this.end_event_offset;
	    this.end_time = event_time + offset;
	    // apply rounding to local time rather than UT so that
	    // fractional time zones work properly
	    this.end_time += loc.ut_offset;
	    if (time_step > 1 / 60 || offset === 0)
		this.end_time = Math.ceil(this.end_time / time_step) * time_step;
	    else
		// round to nearest minute
		this.end_time = Math.round(this.end_time / time_step) * time_step;
	    // restore to UT
	    this.end_time -= loc.ut_offset;
	}
    }

    if (this.start_time === null || this.end_time === null)
	this.events_occur = false;
    else {
	this.events_occur = true;
	// if end time precedes start, assume it refers to the next day
	if (this.start_time > this.end_time)
	    this.end_time += 24;
    }

    // earliest start time is noon LCT on previous day
    CalcDate.setTime((start_date + (-loc.timezone - 12) / 24).DayToMsec());
    ut_offset = loc.getTimeOffset(CalcDate);	// adjust for DST if necessary
    if (this.start_time + ut_offset < -12)
	this.start_time = -ut_offset - 12;

    // latest end time is midnight LCT on following day
    CalcDate.setTime((start_date + (-loc.timezone + 48) / 24).DayToMsec());
    ut_offset = loc.getTimeOffset(CalcDate);	// adjust for DST if necessary
    if (this.end_time + ut_offset > 48)
	this.end_time = -ut_offset + 48;

    // end time occurs on next day
    if (this.end_time + loc.ut_offset >= 24)
	flags.next_day = true;
};

// set limits for positions calculations to 0h and 24h
CalcParams.prototype.setCalcTimes24h = function(sun, moon, loc)
{
    var
	CalcDate = new Date(),
	ut_offset;

    this.time_start_type = 0;
    this.start_time = 0;
    this.start_time -= loc.timezone;	// in UT

    CalcDate.setTime((this.start_date + this.start_time / 24).DayToMsec());
    // start time is offset from local standard time; adjust to offset
    // from local "wall-clock" time
    if (CalcDate.checkTimeAdjustDST(loc) === true)
	this.start_time -= 1;

    // get UT of 24h LCT (end of local day)
    this.ut_24h = 24 - loc.timezone;
    //FIXME??
    CalcDate.setTime((this.start_date + 1 - loc.timezone / 24).DayToMsec());
    // LCT - UT
    ut_offset = loc.getTimeOffset(CalcDate);
    if (ut_offset != loc.timezone)		// DST in effect
	this.ut_24h = 24 - ut_offset;

    this.time_end_type = 0;
    this.end_time = 24;
    this.end_time -= loc.timezone;	// in UT

    CalcDate.setTime((this.start_date + this.end_time / 24).DayToMsec());
    // end time is offset from local standard time; adjust to offset
    // from local "wall-clock" time
    if (CalcDate.checkTimeAdjustDST(loc) === true)
	this.end_time -= 1;

    this.time_step = 1;
};

// check for default events (sunrise and sunset) and Sun that never rises or sets
CalcParams.prototype.checkSunNoPhenom = function(sun)
{
    // type 2 = sunrise; type 4 = sunset
    if (this.time_start_type == 2 && this.time_end_type == 4 &&
      Math.abs(sun.rise) >= F_CIRCUMPOLAR && Math.abs(sun.set) >= F_CIRCUMPOLAR)
	return true;
    else
	return false;
};

// message that Sun never rises or sets
CalcParams.prototype.SunNoPhenomMessage = function(sun)
{
    var msg = "";

    if (sun.rise <= -F_CIRCUMPOLAR && sun.set <= -F_CIRCUMPOLAR)
	msg = '****' + SP + 'Sun never rises' + SP + '****';
    else if (sun.rise >= F_CIRCUMPOLAR && sun.set >= F_CIRCUMPOLAR)
	msg = '****' + SP + 'Sun never sets' + SP + '****';

    if (msg)
	msg = BR + SP2 + msg.big().bold() + BR + BR + LF;

    return msg;
};

// message that specified Sun or Moon event did not occur
CalcParams.prototype.eventMessage = function()
{
    var names = [
	"dawn",
	"sunrise",
	"Sun transit",
	"sunset",
	"dusk",
	"moonrise",
	"Moon transit",
	"moonset"
    ];
    var msg = "";

    if (this.start_time === null)
	msg = '****' + SP + 'No ' + names[this.time_start_type - 1];

    if (this.time_end_type != this.time_start_type && this.end_time === null) {
	if (! msg)
	    msg = '****' + SP + 'No ';
	else
	    msg += ' or ';
	msg += names[this.time_end_type - 1];
    }
    if (msg)
	msg = BR + SP2 + (msg + SP + '****').big().bold() + BR + LF;
    
    return msg;
};

function getCalcParams(form, loc)
{
    var
	year, month, day,
	StartDate, EndDate,
	n_calcs,
	ndx,
	start_date, end_date, date_offset, date_step,
	start_time, end_time, time_offset, multiplier, time_step,
	ut_offset,
	mag_date = new Date();

    if (form.calc_type[0].checked === true) {
	// **************** Calculate Rise/Set Times *********************
	    // ---------------- set dates (0h LCT) --------------------
	this.calc_type = TIMES;

	year = form.StartYear.value;
	month = form.StartMonth.selectedIndex;
	day = form.StartDay.selectedIndex + 1;

	if (check_year(form.StartYear, "start") === false)
	    return false;
	StartDate = new Date();
	StartDate.setTime(Date.UTC(year, month, day));

	// JavaScript extrapolates Gregorian calendar ...
	if (StartDate.getJulian() < 2299160.5) {
	    alert("Earliest date is 15 October 1582");
	    if (flags.isMozilla === false)
		form.StartDay.focus();
	    return false;
	}

	if (loc.getDSTLimits(StartDate.getUTCFullYear()) === false)
	    return false;

	// JD of 0h UT - J1970
	start_date = StartDate.getTime().MsecToDay();

	if (form.end_date[1].checked === true) {	// offset to start date
	    if (check_nonnegative(form.DateOffset, "date offset") === false)
		return false;
	    else {
		date_offset = form.DateOffset.value - 0;
		ndx = form.DateOffsetUnits.selectedIndex;
		end_date = start_date + date_offset * form.DateOffsetUnits.options[ndx].value;
	    }
	}
	else {						// calendar date
	    if (check_year(form.EndYear, "end") === false)
		return false;

	    year = form.EndYear.value;
	    month = form.EndMonth.selectedIndex;
	    day = form.EndDay.selectedIndex + 1;
	    EndDate = new Date();
	    EndDate.setTime(Date.UTC(year, month, day));

	    end_date = EndDate.getTime().MsecToDay();

	    // ensure that end_date differs from start_date by an
	    // integral number of days
	    date_offset = Math.round(end_date - start_date);
	    end_date = start_date + date_offset;
	}

	if (check_dates(form, "start") === false) {
	    EndDate = new Date(form.EndYear.value,
				 form.EndMonth.selectedIndex,
				 form.EndDay.selectedIndex + 1);
	    end_date = EndDate.getTime().MsecToDay();
	}

	ndx = form.DateIntervalUnits.selectedIndex;
	// ensure that date interval is a positive integer
	if (check_date_step(form.DateStep, form.DateIntervalUnits) === false)
	    return false;
	else
	    date_step = form.DateStep.value - 0;

	// silly to calculate times more than once for a date
	date_step *= form.DateIntervalUnits.options[ndx].value;
	if (date_step < 1) {
	    date_step = 1;
	    if (form.DateIntervalUnits.options[ndx].value == 1)
		form.DateStep.value = 1;
	}

	n_calcs = Math.round((end_date - start_date) / date_step);
	if (n_calcs > this.MAX_DAY_CALC) {
	    alert("Too many calculations (" + n_calcs + ")--maximum is "
		  + this.MAX_DAY_CALC);
	    return false;
	}

	this.start_date = start_date;	// JD of 0h UT - J1970
	this.end_date = end_date;	// JD of 0h UT - J1970
	this.date_step = date_step;
	this.date_step_units_ndx = form.DateIntervalUnits.selectedIndex;
	this.date_step_units_value = form.DateIntervalUnits.options[ndx].value;

	EndDate = new Date();
	EndDate.setTime(end_date.DayToMsec());

	var
	    start_mag_valid = check_mag_date(this.start_date),
	    end_mag_valid   = check_mag_date(this.end_date);

	if (start_mag_valid === true && end_mag_valid === true)
	    loc.mag_dec_valid = true;
	else
	    loc.mag_dec_valid = false;
	// date for which to calc mag dec for document header
	loc.mag_dec_date = (this.start_date + this.end_date) / 2;
    }
    else {
	// **************** Calculate Sun and Moon Positions *********************
	    // ---------------- set date (0h LCT) --------------------
	this.calc_type = POSITIONS;

	year = form.CalcYear.value;
	month = form.CalcMonth.selectedIndex;
	day = form.CalcDay.selectedIndex + 1;

	if (check_year(form.CalcYear, "positions") === false)
	    return false;

	this.start_date = Date.UTC(year, month, day);
	StartDate = new Date();
	StartDate.setTime(this.start_date);

	// JavaScript extrapolates Gregorian calendar prior to 1582
	if (StartDate.getJulian() < 2299160.5) {
	    alert("Earliest date is 15 October 1582");
	    form.CalcDay.focus();
	    return false;
	}

	if (loc.getDSTLimits(StartDate.getUTCFullYear()) === false)
	    return false;

	// JD of 0h UT - J1970
	this.start_date = this.start_date.MsecToDay();

	this.end_date = this.start_date;

	ndx = form.TimeStep.selectedIndex;
	time_step = form.TimeStep.options[ndx].value;

	// start time is event
	if (form.time_start_type[0].checked === true) {
	    this.time_start_type = form.StartEvent.selectedIndex + 1;
	    if (check_event_time_offset(form.StartEventOffset, "start") === false)
		return false;
	    else {
		this.start_event_offset = Number(form.StartEventOffset.value) / 60;
		if (form.StartEventOffsetSign.selectedIndex === 0)
		    this.start_event_offset *= -1;
	    }
	}
	else {			// start time specified
	    this.time_start_type = 0;
	    if ((this.start_time = form.StartTime.value.parseTime("start")) === null)
		return false;
	    if (flags.show_ut === false) {
		this.start_time -= loc.timezone;	// convert to UT

		StartDate.setDateDecimalTime(year, month, day, this.start_time);
		// start time is local standard time; adjust to local "wall-clock" time
		if (StartDate.checkTimeAdjustDST(loc) === true)
		    this.start_time -= 1;
	    }
	}

	// get UT of 24h LCT (end of local day)
	this.ut_24h = 24 - loc.timezone;
	//FIXME??
	StartDate.setTime(Date.UTC(year, month, day + 1, -loc.timezone));
	ut_offset = loc.getTimeOffset(StartDate);
	if (ut_offset != loc.timezone)		// DST in effect
	    this.ut_24h = 24 - ut_offset;

	// end time or event
	if (form.end_time[0].checked === true) {
	    if (form.time_end_type[0].checked === true)
		this.time_end_type = form.EndEvent.selectedIndex + 1;
	    else {		// end time specified
		this.time_end_type = 0;
		if ((this.end_time = form.EndTime.value.parseTime("end")) === null)
		    return false;
		if (this.end_time === 0)		// interpret 0 or 12 am as end of day
		    this.end_time = 24;
		if (flags.show_ut === false) {
		    this.end_time -= loc.timezone;	// convert to UT

		    StartDate.setDateDecimalTime(year, month, day, this.end_time);
		    // end time is offset from local standard time; adjust
		    // to offset from local "wall-clock" time
		    if (StartDate.checkTimeAdjustDST(loc) === true)
			this.end_time -= 1;
		}
	    }
	    if (check_event_time_offset(form.EndEventOffset, "end") === false)
		return false;
	    else {
		this.end_event_offset = Number(form.EndEventOffset.value) / 60;
		if (form.EndEventOffsetSign.selectedIndex === 0)
		    this.end_event_offset *= -1;
	    }
	}
	// time offset from start
	else {
	    if (check_time_offset(form) === false)
		return false;
	    else {
		time_offset = form.TimeOffset.value - 0;
		ndx = form.TimeOffsetUnits.selectedIndex;
		multiplier = form.TimeOffsetUnits.options[ndx].value;
	    }

	    this.time_end_type = -1;
	    this.t_offset = time_offset / multiplier;
	}
	this.time_step = time_step / 60;

	// reset to 0h UT (Why do we care?)
	StartDate.setTime(Date.UTC(year, month, day));

	// date for which to calc mag dec for document header
	loc.mag_dec_date = this.start_date;
	loc.mag_dec_valid = check_mag_date(loc.mag_dec_date);
    }

    mag_date.setTime(loc.mag_dec_date.DayToMsec());
    loc.mag_date_str = mag_date.toLocDateStr(0);
    // validity on date for which to show magnetic declination
    loc.mag_dec_date_valid = check_mag_dec_date(loc.mag_dec_date);

    return true;
}

/*
 *****************************************************************************
    location functions and methods
 *****************************************************************************
*/

var
	// indices to places array
    NAME = 0,
    LAT = 1,
    LONG = 2,
    TZ = 3,
    DST = 4,				// uses DST? yes=1, no=0
    ELEV = 5,				// elevation above MSL
    HEIGHT = 6;				// height above local horizon

// *************** Place object *****************************

// initialize new object
function Place(place)
{
    if (arguments.length) {
	this.name = place[NAME];
	this.valid = this.getCountry();	// false = unrecognized state or province

	this.latitude = place[LAT].DMSto();
	this.longitude = place[LONG].DMSto();
	this.timezone = place[TZ].DMSto();
	this.uses_dst = (Number(place[DST]) == 1 ? true : false);
	this.dst_offset = 0;			// start with standard time
	this.elevation = Number(place[ELEV]);
	if (place[HEIGHT])
	    this.height = Number(place[HEIGHT]);
	else
	    this.height = 0;
	this.calcObserverCoord();
	this.calcDensities();
	this.calcRSAlt();
    }

    return true;
}

// initialize existing object
Place.prototype.Init = function(place)
{
    if (arguments.length) {
	this.name = place[NAME];
	this.valid = this.getCountry();	// false: unrecognized state or province

	this.latitude = place[LAT].DMSto();
	this.longitude = place[LONG].DMSto();
	this.timezone = place[TZ].DMSto();
	this.uses_dst = (Number(place[DST]) == 1 ? true : false);
	this.dst_offset = 0;			// start with standard time
	this.elevation = Number(place[ELEV]);
	if (place[HEIGHT])
	    this.height = Number(place[HEIGHT]);
	else
	    this.height = 0;
	this.sin_lat = Math.sin(this.latitude.DtoR());
	this.cos_lat = Math.cos(this.latitude.DtoR());
	this.calcObserverCoord();
	this.calcDensities();
	this.calcRSAlt();
    }

    return true;	//FIXME? what good is this?
};

// initialize from form data
Place.prototype.setLocation = function(form)
{
    var
	errors = 0,
	ndx,
	place = new Array(),
	timezone;

    if (form.loc_type[0].checked === true) {	// look up location
	ndx = form.place.selectedIndex;
	if (form.place.options[ndx].text != places[ndx][NAME]) {
	    alert(
		"Location lookup error:"
		+ "\n" + form.place.options[ndx].text
		+ "\n          vs."
		+ "\n" + places[ndx][NAME]
	    );
	    errors++;
	}
	else
	    place = places[ndx];
    }
    else {					// get user-specified properties from form

	if (form.place_name.value)
	    place[NAME] = form.place_name.value;
	else
	    place[NAME] = "Unknown";

	if (check_latitude(form, form.latitude) === false)
	    errors++;
	else {
	    place[LAT] = form.latitude.value.DMSto();
	    ndx = form.lat_sign.selectedIndex;
	    place[LAT] *= form.lat_sign.options[ndx].value;
	}

	if (check_longitude(form, form.longitude) === false)
	    errors++;
	else {
	    place[LONG] = form.longitude.value.DMSto();
	    ndx = form.long_sign.selectedIndex;
	    place[LONG] *= form.long_sign.options[ndx].value;
	}

	timezone = form.timezone.value;

	if (timezone === "")		// calculate from longitude
	    place[TZ] = Math.round(place[LONG] / 15);
	else if (isNaN((place[TZ] = timezone.DMSto()))) {
	    alert("Invalid time zone (" + timezone + ")");
	    errors++;
	}
	// keep in sync with main form!
	else if (place[TZ] < -12) {
	    alert("Invalid time zone (" + timezone + ")");
	    errors++;
	}
	// keep in sync with main form!
	else if (place[TZ] > 14) {
	    alert("Invalid time zone (" + timezone + ")");
	    errors++;
	}

	ndx = form.uses_dst.selectedIndex;
	place[DST] = form.uses_dst.options[ndx].value;

	if (check_elevation(form.elevation) === false)
	    errors++;
	else {
	    place[ELEV] = Number(rmCommas(form.elevation.value));
	    if (flags.elevation_in_feet === true)
		place[ELEV] = place[ELEV].FTtoM();
	}
    }

    if (check_height(form, form.height) === false)
	errors++;
    else {
	place[HEIGHT] = Number(rmCommas(form.height.value));
	if (flags.elevation_in_feet === true)
	    place[HEIGHT] = place[HEIGHT].FTtoM();
    }

    if (errors > 0)
	return false;

    this.Init(place);
    if (this.valid === false)	// couldn't get DST rules
	return false;

    return true;
};

// get country name from U.S. state or Canadian province
Place.prototype.getCountry = function()
{
    if ((this.country = this.name.replace(/.*,\s*/, "")) == this.name)
	this.country = "Unknown";	// no country given
    else if (this.country.length === 0)
	this.country = "Unknown";	// terminal comma
    else if (this.country.search(/[^-A-Za-z ]/) != -1)
	this.country = "Unknown";	// probably something other than a country

    // assume these are the only two-letter country names
    else if (this.country == "UK")
	this.country = "United Kingdom";
    else if (this.country == "NZ")
	this.country = "New Zealand";
 
    else if (this.country == "England" || this.country == "Scotland")
	this.country = "United Kingdom";

    else if (this.country == "Wales" || this.country == "Northern Ireland")
	this.country = "United Kingdom";

    else if (this.country == "USA" || this.country == "US")
	this.country = "United States";

    // USA and Canada: state or province abbreviation rather than country name
    else if (this.country.length < 3) {
	var
	    provinces = "AB|BC|MB|NB|NL|NS|NT|NU|ON|PE|QC|SK|YT",
	    states = "AK|AL|AR|AS|AZ|CA|CO|CT|DC|DE|FL|GA|HI|IA|ID|IL|IN|KS";

	states += "|KY|LA|MA|MD|ME|MI|MN|MO|MS|MT|NC|ND|NE|NH|NJ|NM|NV|NY|OH";
	states += "|OK|OR|PA|PR|RI|SC|SD|TN|TX|UT|VA|VI|VT|WA|WI|WV|WY";

	var
	    province = new RegExp(provinces),
	    state = new RegExp(states);

	if (province.test(this.country) === true)
	    this.country = "Canada";
	else if (state.test(this.country) === true)
	    this.country = "United States";
	else {
	    alert('Unrecognized state or province: ' + this.country + ' (' + this.name + ')');
	    return false;
	}
    }
    // USA and Canada: state or province rather than country name
    else {
	switch (this.country) {
	    case "Alberta":
	    case "British Columbia":
	    case "Manitoba":
	    case "New Brunswick":
	    case "Newfoundland and Labrador":
	    case "Northwest Territories":
	    case "Nova Scotia":
	    case "Nunavut":
	    case "Ontario":
	    case "Prince Edward Island":
	    case "Quebec":
	    case "Saskatchewan":
	    case "Yukon Territory":
		this.country = "Canada";
		break;
	    case "Alabama":
	    case "Alaska":
	    case "American Samoa":
	    case "Arizona":
	    case "Arkansas":
	    case "California":
	    case "Colorado":
	    case "Connecticut":
	    case "Delaware":
	    case "Florida":
	    case "Georgia":
	    case "Guam":
	    case "Hawaii":
	    case "Idaho":
	    case "Illinois":
	    case "Indiana":
	    case "Iowa":
	    case "Kansas":
	    case "Kentucky":
	    case "Louisiana":
	    case "Maine":
	    case "Maryland":
	    case "Massachusetts":
	    case "Michigan":
	    case "Minnesota":
	    case "Mississippi":
	    case "Missouri":
	    case "Montana":
	    case "Nebraska":
	    case "Nevada":
	    case "New Hampshire":
	    case "New Jersey":
	    case "New Mexico":
	    case "New York":
	    case "North Carolina":
	    case "North Dakota":
	    case "Ohio":
	    case "Oklahoma":
	    case "Oregon":
	    case "Pennsylvania":
	    case "Puerto Rico":
	    case "Rhode Island":
	    case "South Carolina":
	    case "South Dakota":
	    case "Tennessee":
	    case "Texas":
	    case "U.S. Virgin Islands":
	    case "US Virgin Islands":
	    case "Utah":
	    case "Vermont":
	    case "Virginia":
	    case "Virgin Islands":
	    case "Washington":
	    case "West Virginia":
	    case "Wisconsin":
	    case "Wyoming":
		this.country = "United States";
		break;
	    default:
		// not a state or province
		break;
	}
    }

    return true;
};

// time zone names for Canada and U.S.
Place.prototype.tzName = new Array();
Place.prototype.tzName[0] = "GMT";			// UTC
Place.prototype.tzName[6] = "Greenland";		// UTC-3
Place.prototype.tzName[7] = "Newfoundland";		// UTC-3.5
Place.prototype.tzName[8] = "Atlantic";			// UTC-4
Place.prototype.tzName[10] = "Eastern";			// UTC-5
Place.prototype.tzName[12] = "Central";			// UTC-6
Place.prototype.tzName[14] = "Mountain";		// UTC-7
Place.prototype.tzName[16] = "Pacific";			// UTC-8
Place.prototype.tzName[18] = "Alaska";			// UTC-9
Place.prototype.tzName[20] = "Hawaii-Aleutian";		// UTC-10
Place.prototype.tzName[22] = "Samoa";			// UTC-11

Place.prototype.getTimezone = function()
{
    var
	tz_name,
	tz_ndx = -2 * this.timezone;

    switch (this.country) {
	case "Canada":
	case "Greenland":
	case "United States":
	    if (tz_ndx > 22 || ! this.tzName[tz_ndx])
		tz_name = null;
	    else
		tz_name = this.tzName[tz_ndx];
	    break;
	default:
	    if (tz_ndx === 0)
		tz_name = this.tzName[tz_ndx];
	    else
		tz_name = null;
	    break;
    }
    return tz_name;
};

// determine daylight saving status
// 1 hr DST offset used in all cases
Place.prototype.isDST = function(date)
{
    var
	dst_offset,
	time = date.getTime();

    if (this.uses_dst === false || flags.show_dst === false)	// from database
	dst_offset = 0;
    else if (this.dst_start === null || this.dst_end === null)	// from DST rule
	dst_offset = 0;

    // reverse for southern hemisphere
    else if (this.latitude < 0) {
	if (time >= this.dst_start || time < this.dst_end)
	    dst_offset = 1;
	else
	    dst_offset = 0;
    }
    else {
	if (time >= this.dst_start && time < this.dst_end)
	    dst_offset = 1;
	else
	    dst_offset = 0;
    }

    return dst_offset;
};

// get time offset from UT: LCT - UT
Place.prototype.getTimeOffset = function(date)
{
    var ut_offset = this.timezone;
    if (this.uses_dst === true && flags.show_dst === true)
	ut_offset += this.isDST(date);
    this.ut_offset = ut_offset;

    return (ut_offset * 1);
};

// show rule for DST start or end
function showDSTRule(changeStr)
{
    var
	change = new Array(),
	RuleStr;

    change = changeStr.split(":");

    var
	change_month = (change[0] - 0),
	change_day =   (change[1] - 0),
	change_week =  (change[2] - 0),	// # week after change date
	change_DoW =   (change[3] - 0);

    if (change_week === 0) {	// absolute date
	RuleStr = change_day + ' ' + months[change_month - 1];

	return RuleStr;
    }

    switch (change_week) {
	case 1:
	    RuleStr = "1st";
	    break;
	case 2:
	    RuleStr = "2nd";
	    break;
	case 3:
	    RuleStr = "3rd";
	    break;
	case 4:
	    RuleStr = "4th";
	    break;
	case 5:
	    RuleStr = "Last";
	    break;
	default:
	    break;
    }

    RuleStr += ' ' + day_of_week[change_DoW];

    if (change_week == 5)
	RuleStr += ' of ' + months[change_month - 1];
    else if (change_day > 1)
	RuleStr += ' after ' + change_day + ' ' + months[change_month - 1];
    else
	RuleStr += ' of ' + months[change_month - 1];

    return RuleStr;
}

/*
    <change_week> determines meaning of <change_date> and <change_DoW>:
      0   = <change_date> is actual day of month of change
      1-4 = change on <change_week> occurrences of <change_DoW>
	    on or after <change_date>
      5   = change on last occurrence of <change_DoW> on or before
	    <change_date>
*/

// show DST rule as date
function showDSTDate(changeStr, year)
{
    var
	DateStr,
	dayStr,
	change = new Array();

    change = changeStr.split(":");

    var
	change_month = (change[0] - 0),
	change_day =   (change[1] - 0),	// initial day of month for change
	change_week =  (change[2] - 0),	// # occurrences after change date
	change_DoW =   (change[3] - 0);	// DoW of change date

    if (change_week > 0) {	// # occurrrences of DoW after change date
	change_day = getDSTChangeDate(year, changeStr);
	dayStr = day_of_week[change_DoW];
    }
    else {		// change on specified date; need to find DoW
	var date;

	date = new Date(Date.UTC(year, change_month - 1, change_day, 12));
	dayStr = day_of_week[date.getUTCDay()];
    }

    DateStr = dayStr + ' ' + change_day + ' ' + months[change_month - 1];

    return DateStr;
}

function getDSTChangeDate(year, changeStr)
{
    var
	change = new Array();

    change = changeStr.split(":");

    var
	change_month = (change[0] - 0),
	change_day =   (change[1] - 0),	// nominal day of month for change
	change_week =  (change[2] - 0),	// # occurrences after change date
	change_DoW =   (change[3] - 0),	// DoW of actual change date
	change_time =  (change[4] - 0),
	weekday,			// DoW of initial change date
	day_adj = 0;


    var DST_change = new Date(Date.UTC(year, change_month - 1, change_day, 12));
    weekday = DST_change.getUTCDay();

    // actual change date is last occurrence of DoW before initial
    // change date (usually last day of month)
    if (change_week == 5) {
	// FIXME?  Forces initial date to last day of month; comment out to
	// have last occurrence on or before specified initial change date
	change_day = monthdays[isleap(year)][change_month - 1];

	if (weekday != change_DoW) {
	    if ((day_adj = weekday - change_DoW) < 0)
		day_adj += 7;
	    change_day -= day_adj;
	}

    }
    // actual change date is change_week occurrences of DoW after initial change date
    else if (change_week > 0) {
	if (weekday != change_DoW) {
	    if ((day_adj = change_DoW - weekday) < 0)
		day_adj += 7;
	    change_day += day_adj;
	}
	change_day += ((change_week - 1) * 7);
    }
    // else initial change date is actual day of month; don't bother
    // with DoW

    return (change_day);
}

// get daylight saving time start and end times
Place.prototype.getDSTLimits = function(year)
{
    if (this.uses_dst === false || flags.show_dst === false)
	return true;

    if (this.getDSTRule(year) === false)
	return false;

    var
	start = this.DSTStartStr.split(":"),
	end = this.DSTEndStr.split(":");

    var
	ut_offset,
	start_month = (start[0] - 0),
	start_day =   (start[1] - 0),
	start_week =  (start[2] - 0),
	start_DoW =   (start[3] - 0),
	start_time =  (start[4] - 0),
	start_type =  start[5],
	end_month =   (end[0] - 0),
	end_day =     (end[1] - 0),
	end_week =    (end[2] - 0),
	end_DoW =     (end[3] - 0),
	end_time =    (end[4] - 0),
	end_type =    end[5];

    if (start_month === 0 || end_month === 0) {
	this.dst_start = this.dst_end = null;
	return true;
    }

    if (start_type == "u")		// Universal Time
	ut_offset = 0;
    else
	ut_offset = this.timezone;	// standard time

    // find the specified occurrence of DoW
    if (start_week > 0)
	start_day = getDSTChangeDate(year, this.DSTStartStr);
    // else just use the date

    // convert to UT
    start_time -= ut_offset;

    // msec since J1970
    this.dst_start = Date.UTC(year, start_month - 1, start_day,
			      Math.ipart(start_time), Math.fpart(start_time) * 60);

    if (end_type == "u")		// Universal Time
	ut_offset = 0;
    else if (end_type == "w")		// "wall-clock time" (DST in this case)
	ut_offset = this.timezone + 1;	// assume DST offset is always 1h
    else				// standard time
	ut_offset = this.timezone;

    // find the specified occurrence of DoW
    if (end_week > 0)
	end_day = getDSTChangeDate(year, this.DSTEndStr);
    // else just use the date

    // convert to UT
    end_time -= ut_offset;

    // msec since J1970
    this.dst_end = Date.UTC(year, end_month - 1, end_day,
			    Math.ipart(end_time), Math.fpart(end_time) * 60);

    // days since J1970
    this.dst_start_date = (this.dst_start - start_time.HtoMsec()).MsecToDay();
    this.dst_end_date = (this.dst_end - end_time.HtoMsec()).MsecToDay();

    // shouldn't be necessary, but ...
    this.dst_start_date = Math.round(this.dst_start_date);
    this.dst_end_date = Math.round(this.dst_end_date);

    return true;
};
// check match between places select list and places array
function checkPlaces()
{
    var
	warnings = 0,
	errors = 0,
	loc = new Place(),
	latitude, longitude, lon_val, timezone, dst_flag,
	ndx;
  
    // save current settings
    var
	from_database = form.loc_type[0].checked,
	loc_ndx = form.place.selectedIndex;

    if (form.place.length != places.length) {
	if (form.place.length > places.length)
	    write_db('More locations on form than in database:');
	else
	    write_db('Fewer locations on form than in database:');
	write_db('  ' + form.place.length + ' vs. '  + places.length);
	errors++;
    }
    form.loc_type[0].checked = true;
    for (ndx = 0; places[ndx] && ndx < form.place.length; ndx++) {
	form.place.selectedIndex = ndx;
	if (form.place.options[ndx].text != places[ndx][NAME]) {
	    write_db('Location lookup error:',
		       '  ' + form.place.options[ndx].text
		     + ' vs. ' + places[ndx][NAME]);
	    errors++;
	}
	latitude = places[ndx][LAT];
	if (Math.abs(latitude.DMSto()) > 90) {
	    write_db(places[ndx][NAME] + ": invalid latitude (" + latitude + ")");
	    errors++;
	}
	longitude = places[ndx][LONG];
	if (Math.abs(lon_val = longitude.DMSto()) > 180) {
	    write_db(places[ndx][NAME] + ": invalid longitude (" + longitude + ")");
	    errors++;
	}
	timezone = places[ndx][TZ];
	//if (Math.abs(timezone.DMSto()) > 12) {
	if (get_tz_ndx(timezone) < 0) {
	    write_db(places[ndx][NAME] + ": invalid time zone (" + timezone + ")");
	    errors++;
	}
	else if (lon_val * timezone < 0) {
	    write_db(places[ndx][NAME] + ": warning: longitude-time zone mismatch ("
		     + longitude + " " + "<->" + " " + timezone + ")");
	    warnings++;
	}
	dst_flag = places[ndx][DST];
	if (dst_flag !== 0 && dst_flag != 1) {
	    write_db(places[ndx][NAME] + ": invalid DST flag (" + dst_flag + ")");
	    errors++;
	}
    }

    // restore initial settings
    if (from_database === true)
	form.loc_type[0].checked = true;
    else
	form.loc_type[1].checked = true;
    form.place.selectedIndex = loc_ndx;

    write_db(form.place.options.length + ' locations');

    if (warnings == 1)
	write_db(warnings + ' location warning');
    else if (warnings > 1)
	write_db(warnings + ' location warnings');

    if (errors == 1)
	write_db(errors + ' location error');
    else
	write_db(errors + ' location errors');
}

// check for a DST rule for each place that uses DST
function checkDSTRules(year)
{
    var
	errors = 0,
	loc,
	ndx;

    for (ndx = 0; places[ndx]; ndx++) {
	if (places[ndx][DST] == 1) {
	    loc = new Place(places[ndx]);
	    if (loc.valid === false)
		errors++;
	    if (loc.checkDSTLimits(year) === false)
		errors++;
	}
    }
    if (errors == 1)
	write_db(errors + ' DST rule error');
    else
	write_db(errors + ' DST rule errors');
}

// sanity check daylight saving time begin and end dates
Place.prototype.checkDSTLimits = function(year)
{
    var errors = 0;

    if (this.uses_dst === false || flags.show_dst === false)
	return true;

    if (this.getDSTRule(year) === false) {
	write_db('No DST rule for ' + this.name);
	return false;
    }

    if (this.checkDSTChangeDate(this.DSTStartStr, "start") === false)
	errors++;
    if (this.checkDSTChangeDate(this.DSTEndStr, "end") === false)
	errors++;

    if (this.getDSTLimits(year) === false) {
	write_db(this.name + ": cannot get DST start/end dates");
	errors++;
    }

    if (this.dst_start !== null && this.dst_end !== null) {
	var dst_diff = this.dst_end - this.dst_start;
	// difference and latitude should be opposite in sign
	if (this.latitude / dst_diff < 0) {
	    write_db(this.name + ": DST start/end reversed?");
	    errors++;
	}
    }

    if (errors > 0)
	return false;
    else
	return true;
};
 
// sanity check daylight saving time change date
Place.prototype.checkDSTChangeDate = function(changeStr, tag)
{
    var
	errors = 0,
	change = changeStr.split(":");

    var
	change_month =   (change[0] - 0),
	change_day =     (change[1] - 0),
	change_week =    (change[2] - 0),
	change_DoW =     (change[3] - 0),
	change_time =    (change[4] - 0),
	change_type =    change[5];

    if (change_month === 0)	// no DST; don't bother with further checks
	return true;

    if (isNaN(change[0]) || change_month < 0 || change_month > 12) {
	write_db(this.name + ": invalid " + tag + " month (" + change[0] +")");
	errors++;
    }
    if (isNaN(change[1]) || change_day < 1 ||
      change_day > monthdays[1][change_month - 1]) {
	write_db(this.name + ": invalid " + tag + " day (" + change[1] + " "
	                   + months[change_month - 1] +")");
	errors++;
    }
    if (isNaN(change[2]) || change_week < 0 || change_week > 5) {
	write_db(this.name + ": invalid " + tag + " week (" + change[2] +")");
	errors++;
    }
    if (isNaN(change[3]) || change_DoW < 0 || change_DoW > 6) {
	write_db(this.name + ": invalid " + tag + " DoW (" + change[3] +")");
	errors++;
    }
    if (isNaN(change[4]) || change_time < 0 || change_time > 24) {
	write_db(this.name + ": invalid " + tag + " time (" + change[4] +")");
	errors++;
    }
    if (change_type.search(/[suw]/) < 0) {
	write_db(this.name + ": invalid " + tag + " time type (" + change_type +")");
	errors++;
    }

    if (errors > 0)
	return false;
    else
	return true;
};

// ******* built-in location lookup and check functions *************

// filter keys for place search pattern input
// this must be the event handler for both keypress and keyup
function searchKeyFilter(event)
{
    var
	BACKSPACE = 8,
	RETURN = 13,
	e = window.event || event,
	code = e.keyCode || e.charCode;

    // perform search as each character is entered
    switch (e.type) {
	case "keyup":
	    // don't give an error message when backspacing
	    if (code == BACKSPACE)
		search_places("backspace");
	    else if (code >= 32)
		search_places("new");
	    break;
	case "keypress":
	    if (code == RETURN) {
		search_places("next");
		return false;	// prevent submit on Enter
	    }
	    break;
	default:
	    break;
    }
    return true;
}

function get_lat_lon(coords)
{
    if (check_latitude(form, form.latitude) === true) {
	coords.lat = form.latitude.value.DMSto();
	if (form.lat_sign.selectedIndex == 1)
	    coords.lat = -coords.lat;
    }
    else
	return false;

    if (check_longitude(form, form.longitude) === true) {
	coords.lon = form.longitude.value.DMSto();
	if (form.long_sign.selectedIndex == 1)
	    coords.lon = -coords.lon;
    }
    else
	return false;

    return true;
}

// get the time limits, in UT, in which events must occur
Place.prototype.getEventUTLimits = function(calc_date)
{
    var
	STD = 0, DST_START = 1, DST = 2, DST_END = 4,
	status;

    if (this.uses_dst === false || flags.show_dst === false)
	status = STD;
    else if (calc_date == this.dst_start_date)
	status = DST_START;
    else if (calc_date == this.dst_end_date)
	status = DST_END;

    else if (this.latitude >= 0) {	// northern hemisphere
	if (calc_date > this.dst_start_date && calc_date < this.dst_end_date)
	    status = DST;
	else
	    status = STD;
    }
    else {				// southern hemisphere
	if (calc_date > this.dst_end_date && calc_date < this.dst_start_date)
	    status = STD;
	else
	    status = DST;
    }

    switch (status) {
	case STD:
	    this.ut_min =  0 - this.timezone;
	    this.ut_max = 24 - this.timezone;
	    break;
	case DST_START:
	    this.ut_min =  0 - this.timezone;
	    this.ut_max = 24 - this.timezone - 1;
	    break;
	case DST:
	    this.ut_min =  0 - this.timezone - 1;
	    this.ut_max = 24 - this.timezone - 1;
	    break;
	case DST_END:
	    this.ut_min =  0 - this.timezone - 1;
	    this.ut_max = 24 - this.timezone;
	    break;
	default:
	    break;
    }

    this.ut_offset_start = -this.ut_min;	// UT offset at beginning of day
};

/*
 *****************************************************************************
    astromomical calculation functions
 *****************************************************************************
*/

// ************** event time and positions functions ****************

// Sun and Moon event times
function calculate_times(calc_params, sun, moon, rs_opts, loc)
{
    var
	CalcDate = new Date(),
	start_date = calc_params.start_date,
	end_date = calc_params.end_date,
	calc_step = calc_params.date_step,
	mag_dec_date = null;	// date of last calculation of magnetic declination
    var
	found_one = false,
	hours,
	jday,			// Julian day number (JD)
	year,
	last_year,
	ndx = 0,		// index of times[] array
	spos = new SunPos(),	// Sun position
	mpos = new MoonPos(),	// Moon position
	alt_rs,			// altitude crossing
	sun_dist,		// Sun distance in AU at transit
	dst_offset,
	opt = rs_opts,
	t_offset;

    CalcDate.setTime(start_date.DayToMsec());

    last_year = CalcDate.getUTCFullYear();

    this.times.length = 0;

    // check Sun/Moon rise/set declination limits if required
    if (opt.decl_sr_check === true)
	opt.getDeclLimits("sunrise", loc);
    if (opt.decl_ss_check === true)
	opt.getDeclLimits("sunset", loc);
    if (opt.decl_mr_check === true)
	opt.getDeclLimits("moonrise", loc);
    if (opt.decl_ms_check === true)
	opt.getDeclLimits("moonset", loc);
    if (opt.t_diff_mr_check === true)
	opt.getTopoAltLimits("moonrise", loc);

    // calc_date = JD - J1970
    for (var calc_date = start_date; calc_date <= end_date + 1.001 / 24; calc_date += calc_step) {
	// round calc_date to handle 1/12-year date increments
	calc_date = Math.round(calc_date);

	// set noon local standard time
	CalcDate.setTime((calc_date - loc.timezone / 24 + 0.5).DayToMsec());

	// get the DST start and end times if it's a new year
	if ((year = CalcDate.getUTCFullYear()) != last_year) {
	    if (loc.getDSTLimits(year) === false)
		return false;
	    last_year = year;
	}

	/*
	    Get the UT limits in which events must occur.  On the day of
	    transition to DST, events must occur in a 23-hour window; on
	    the day of transition from DST, the events have a 25-hour
	    window. All other days have a 24-hour window.
	*/
	loc.getEventUTLimits(calc_date);

	// reset to 0h UT
	CalcDate.setTime(calc_date.DayToMsec());
	jday = CalcDate.getJulian();

	calcObliquity(jday, spos, mpos);
	calcNutation(jday, spos, mpos);
	calcDeltaT(jday, spos, mpos);

	/* calculate positions at 0h, 12h, and 24h LCT */
	if (flags.interpolate_rs_positions === true) {
	    spos.initPosArray(jday, loc);
	    mpos.initPosArray(jday, loc);
	}

	    // Sun
	sun.name = "Sun";
	sun.jday = jday;
	sun.cdate = CalcDate;//FIXME?
	if (flags.show_all_twilight === true) {
	    sun.adawn = spos.getEventTime(jday, loc, "M", -18, "");
	    sun.ndawn = spos.getEventTime(jday, loc, "M", -12, "");
	}
	sun.dawn = spos.getEventTime(jday, loc, "M", -6, "");

	sun.rise = spos.getEventTime(jday, loc, "R", opt.sr_true_alt, opt.alt_sr_align);
	if (sun.rise.testEvent() === true) {
	    // ignore parallax
	    sun.az_rise = spos.getAzRS(loc, "R", "geo");
	    sun.sd_r = spos.sd0;
	    // adjust to match Sun's upper or lower limb if necessary
	    // FIXME? should this be done regardless of 1st criterion?
	    if (opt.decl_sr_check === true && opt.alt_sr_align != "center")
		spos.adjustDecl(sun.az_rise, sun.sd_r, opt.alt_sr_align, loc, "geo");
	    sun.decl_rise = spos.declination;
	}
	else
	    sun.az_rise = null;

	sun.transit = spos.getEventTime(jday, loc, "T", -99, "");
	sun.maxalt = spos.getMaxAlt(loc);	// apparent
	sun.maxalt_true = spos.altitude;
	sun.minalt = spos.getMinAlt(loc);	// apparent; decl is that at upper transit
	sun.minalt_true = spos.altitude;
	sun.decl_trans = spos.declination;
	sun_dist = spos.dist;

	sun.set = spos.getEventTime(jday, loc, "S", opt.ss_true_alt, opt.alt_ss_align);
	if (sun.set.testEvent() === true) {
	    // ignore parallax
	    sun.az_set = spos.getAzRS(loc, "S", "geo");
	    // adjust to match Sun's upper or lower limb if necessary
	    sun.sd_s = spos.sd0;
	    if (opt.decl_ss_check === true && opt.alt_ss_align != "center")
		spos.adjustDecl(sun.az_set, sun.sd_s, opt.alt_ss_align, loc, "geo");
	    sun.decl_set = spos.declination;
	}
	else
	    sun.az_set = null;

	sun.dusk = spos.getEventTime(jday, loc, "E", -6, "");
	if (flags.show_all_twilight === true) {
	    sun.ndusk = spos.getEventTime(jday, loc, "E", -12, "");
	    sun.adusk = spos.getEventTime(jday, loc, "E", -18, "");
	}

	sun.day = spos.getDayLen(sun.rise, sun.set);

	    // Moon
	moon.name = "Moon";
	moon.jday = jday;
	moon.cdate = CalcDate;//FIXME?
	moon.rise = mpos.getEventTime(jday, loc, "R", opt.mr_true_alt, opt.alt_mr_align);
	if (moon.rise.testEvent() === true) {
	    mpos.calcPhase(sun_dist, loc);		// topocentric; from ecl coords
	    moon.phase_r = mpos.phase;
	    moon.waxing_r = mpos.waxing;
	    moon.sin_hp_r = mpos.sin_hp;
	    moon.sd_r = mpos.getTopoSD();		// from geocentric alt

	    mpos.geoToTopo(loc);
	    moon.az_rise = mpos.getAzRS(loc, "R");	// topocentric
	    // adjust to match Moon's upper or lower limb if necessary
	    if (opt.decl_mr_check === true && opt.alt_mr_align != "center")
		mpos.adjustDecl(moon.az_rise, moon.sd_r, opt.alt_mr_align, loc);
	    moon.decl_rise = mpos.declination;
	}
	else
	    moon.az_rise = moon.phase_r = moon.sd_r = null;

	moon.transit = mpos.getEventTime(jday, loc, "T", -99, "");
	if (moon.transit.testEvent() === true) {
	    mpos.calcPhase(sun_dist, loc);
	    moon.phase_t = mpos.phase;
	    moon.waxing_t = mpos.waxing;
	    moon.sd_t = mpos.getTopoSD();
	    moon.decl_trans = mpos.declination;
	}
	else
	    moon.phase_t = moon.sd_t = moon.maxalt = null;
	//FIXME? what if there is no transit?
	moon.maxalt = mpos.getMaxAlt(loc);
	moon.maxalt_true = mpos.altitude;
	moon.minalt = mpos.getMinAlt(loc);
	moon.minalt_true = mpos.altitude;

	moon.set = mpos.getEventTime(jday, loc, "S", opt.ms_true_alt, opt.alt_ms_align);
	if (moon.set.testEvent() === true) {
	    mpos.calcPhase(sun_dist, loc);
	    moon.phase_s = mpos.phase;
	    moon.waxing_s = mpos.waxing;
	    moon.sin_hp_s = mpos.sin_hp;
	    moon.sd_s = mpos.getTopoSD();

	    mpos.geoToTopo(loc);
	    moon.az_set = mpos.getAzRS(loc, "S");	// topocentric
	    // adjust to match Moon's upper or lower limb if necessary
	    if (opt.decl_ms_check === true && opt.alt_ms_align != "center")
		mpos.adjustDecl(moon.az_set, moon.sd_s, opt.alt_ms_align, loc);
	    moon.decl_set = mpos.declination;
	}
	else
	    moon.az_set = moon.phase_s = moon.sd_s = null;

	if (flags.show_mag_north === true) {
	    // calc magnetic declination every 30 days
	    if (mag_dec_date === null || calc_date - mag_dec_date >= 30) {
		loc.mag_dec = mag_model.calcMagDec(loc, calc_date);
		mag_dec_date = calc_date;
	    }

	    if (sun.az_rise !== null)
		sun.az_rise = (sun.az_rise - loc.mag_dec).setRange(360);
	    if (sun.az_set !== null)
		sun.az_set = (sun.az_set - loc.mag_dec).setRange(360);
	    if (moon.az_rise !== null)
		moon.az_rise = (moon.az_rise - loc.mag_dec).setRange(360);
	    if (moon.az_set !== null)
		moon.az_set = (moon.az_set - loc.mag_dec).setRange(360);
	}

	// don't apply selection criteria if showing Sun and Moon
	// positions on a given date
	if (calc_params.calc_type == POSITIONS ||
	  rs_opts.select(jday, sun, moon, spos, mpos, loc) === true) {
	    found_one = true;
	    this.times[ndx++] = format_times(CalcDate, calc_params.calc_type,
					     sun, moon, rs_opts, t_offset, loc);
	}
    }

    rs_opts.matches = ndx;

    return found_one;
}

// Sun and Moon positions
function calculate_positions(calc_params, sun, moon, loc)
{
    var
	altitude,
	calc_time,
	ndx = 0,		// index of positions[] array
	path_angle,		// angle of Sun or Moon path with horizontal
	places,			// decimal places for azimuth and altitude display
	spos = new SunPos(),	// Sun position
	mpos = new MoonPos(),	// Moon position

	CalcDate = new Date(),
	jday,			// JD of 0h UT
	start_date = calc_params.start_date;

    var
	ncalcs,
	start_time = calc_params.start_time,	// UT
	end_time = calc_params.end_time,	// UT
	time_step = calc_params.time_step;	// hours

    end_time += 1e-4;				// handle rounding errors

    var line;					// formatted output line for positions

    // 0h UT
    CalcDate.setTime(start_date.DayToMsec());
    jday = CalcDate.getJulian();

    calcObliquity(jday, spos, mpos);
    calcNutation(jday, spos, mpos);
    calcDeltaT(jday, spos, mpos);

    this.positions.length = 0;

    ncalcs = 0;
    places = 2;
    for (calc_time = start_time; calc_time <= end_time; calc_time += time_step) {
	if (++ncalcs > 2880)	// two days @ 1-minute interval
	    break;		// prevent a runaway just in case ...

	// round to nearest minute to prevent accumulation of rounding errors
	calc_time = Math.round(calc_time * 60) / 60;

	spos.calcPos(jday, calc_time);
	spos.geoToTopo(loc);
	spos.calcAltAz(loc);		// true altitude
	spos.addRefraction(loc);	// apparent altitude
	spos.calcDecl(loc);		// apparent

	mpos.calcPos(jday, calc_time);
	mpos.calcPhase(spos.dist, loc);	// topocentric
	mpos.geoToTopo(loc);		// calculates SD as well
	mpos.calcAltAz(loc);		// true topocentric altitude
	mpos.addRefraction(loc);	// apparent topocentric altitude
	mpos.calcDecl(loc);		// apparent topocentric

	if (flags.show_mag_north === true) {
	    spos.azimuth = (spos.azimuth - loc.mag_dec).setRange(360);
	    mpos.azimuth = (mpos.azimuth - loc.mag_dec).setRange(360);
	}

	CalcDate.setTime((start_date + calc_time / 24).DayToMsec());

	// time
	line = TR + LF;
	line += TD;

	// show every hour in bold if time step < 30 minutes
	if (time_step < 0.5 && Math.rnd(calc_time + loc.ut_offset, 3) % 1 === 0)
	    line += calc_time.showPosTime(CalcDate, loc).bold();
	else
	    line += calc_time.showPosTime(CalcDate, loc);

	line += TDE + LF;

	// Sun
	line += TD + spos.azimuth.toFixed(places+1) + SP2 + TDE + LF;
	if ((altitude = spos.altitude) < 0)
	    line += TD + MINUS + (-altitude).toFixed(places+1);
	else
	    line += TD + altitude.toFixed(places+1);
	line += SP2 + TDE + LF;

	// angle of path with parallel of altitude
	if ((path_angle = spos.getPathAngle(loc)) > 90)
	    line += TD + SP + (180 - path_angle).toFixed(3) + MINUS + SP + TDE + LF;
	else
	    line += TD + SP + path_angle.toFixed(3) + SP2 + TDE + LF;

	// shadow length
	if (altitude > 0) {
	    var shadow_len = (1 / Math.tan(altitude.DtoR() ));
	    // don't differentiate values > 100
	    if (shadow_len > 1e100)
		line += TD_C + ">" + " 100" + TDE + LF;
	    else
		line += TD + shadow_len.toFixed(3) + SP + TDE + LF;
	}
	else
	    line += TD_C + MDASH + TDE + LF;

	// Moon
	line += TD + mpos.azimuth.toFixed(places+1) + SP2 + TDE + LF;
	if ((altitude = mpos.altitude) < 0)
	    line += TD + MINUS + (-altitude).toFixed(places+1);
	else
	    line += TD + altitude.toFixed(places+1);
	line += SP2 + TDE + LF;

	// angle of path with parallel of altitude
	if ((path_angle = mpos.getPathAngle(loc)) > 90)
	    line += TD + SP + (180 - path_angle).toFixed(3) + MINUS + SP + TDE + LF;
	else
	    line += TD + SP + path_angle.toFixed(3) + SP2 + TDE + LF;

	line += TD + mpos.phase.toFixed(5);

	if (flags.always_show_wax_wane) {
	    if (mpos.waxing === true)
		line += WAXING;
	    else
		line += WANING;
	}
	line += SP + TDE + LF;

	line += TD + SP + mpos.sd.toFixed(5) + SP + TDE + LF;

	line += TRE + LF;

	this.positions[ndx++] = line;
    }

    return true;
}

// ********************* location characteristics *****************

// observer's coordinates for parallax correction
// Meeus (1991) Ch 10, p 78
Place.prototype.calcObserverCoord = function()
{
    var
	earth_rad = EARTH_RADIUS * 1e3,	// in meters
	elevation = this.elevation,	// in meters
	latitude = this.latitude.DtoR(),
	ratio = 0.99664719,		// polar radius to equatorial
	u;

    u = Math.atan(ratio * Math.tan(latitude));
    this.rhoSinPhi = ratio * Math.sin(u) + elevation / earth_rad * Math.sin(latitude);
    this.rhoCosPhi = Math.cos(u) + elevation / earth_rad * Math.cos(latitude);
    this.rho = Math.sqrt(Math.square(this.rhoSinPhi) + Math.square(this.rhoCosPhi));
};

// density correction factors for refraction at base elevation and at observer's height
Place.prototype.calcDensities = function()
{
    var
	elevation = this.elevation,	// m
	height    = this.height,	// m
	lapse_rate = 6.5e-3,		// K/m
	ndx = 4.256,
	std_temp = 273.15 + 10;		// K

    // density relative to sea level at observer's elevation
    this.density = calcDensity(elevation);

    // density relative to sea level at elevation of horizon
    this.density_gnd = calcDensity(elevation - height);
};

// density relative to sea level at given elevation
// based on troposphere of 1976 U.S. standard atmosphere
calcDensity = function(elevation)
{
    var
	lapse_rate = 6.5e-3,	// K/m
	ndx = 4.256,
	temp0 = 273.15 + 10;	// K

    return Math.pow(1 - lapse_rate / temp0 * elevation, ndx);
};

// ray curvature at given elevation,
// based on troposphere of 1976 U.S. standard atmosphere
function calc_k(elevation)
{
    var
	lapse_rate = 6.5e-3,	// K/m
	ndx = 3.256,
	temp0 = 273.15 + 10;	// K

    return K_REFR * Math.pow(1.0 - lapse_rate / temp0 * elevation, ndx);
}

// calculate refraction, dip, rise/set alt at horizon
/*
    density        Relative to sea level at observer's elevation and height
    density_gnd    Relative to sea level at elevation of horizon
    refr_0h_elev   Refraction at zero alt, observer's elevation and height
    refr_0h	   Refraction at zero alt, sea level
    refr_0h_gnd	   Refraction at zero alt, at elevation of horizon
    dip		   Dip of the horizon
    horizon_true   True negative altitude of the horizon
    rs_alt	   True topocentric r/s alt of upper limb = -(horizon_true + refr_0h_gnd)
*/
Place.prototype.calcRSAlt = function()
{
    var
	refr_0h_gnd,	// refraction at horizon at elevation of horizon
	horizon_true;	// true depression of visible horizon

    // astronomical refraction at zero alt at the horizon and at observer's height
    refr_0h_gnd = this.refr_0h_elev = refraction_app(0, this);

    // astronomical refraction at zero alt, with elevation correction
    // removed (i.e., sea level)
    this.refr_0h  = this.refr_0h_elev / this.density;

    // astronomical refraction at the horizon at ground level--use
    // ground-level air density
    if (this.height > 0)
	refr_0h_gnd *= this.density_gnd / this.density;

    // true topocentric rise/set alt of *upper limb* for observer at
    // elevation of horizon
    this.rs_alt = -refr_0h_gnd;

    // for ground-level observer
    this.dip = 0;

    // elevated observer
    // rough empirical approximation to methods of Sweer (1938)
    if (this.height > 0) {
	var
	    density,		// air density relative to sea level
	    k,			// ray curvature, in Earth radii
	    r_E;		// Earth radius in meters

	density = this.density;
	k = calc_k(this.elevation - 2 * this.height / 3);
	r_E = EARTH_RADIUS * 1e3 * this.rho;

	// dip of the horizon (apparent negative altitude of horizon)
	this.dip = Math.sqrt(2 * (1 - k) * this.height / r_E).RtoD();
	// true negative altitude of horizon
	horizon_true = this.dip / (1 - k);
	// true topocentric rise/set alt for elevated observer
	this.rs_alt -= horizon_true;
    }
};

// ********** general astronomical calculation functions **************

// obliquity of the ecliptic in radians
// Meeus (1991, 135)
function calcObliquity(jday, sun, moon)
{
    var
	T, T2, T3,
	obliquity;

    T = (jday - J2000) / 36525;
    T2 = T * T;
    T3 = T2 * T;
    //obliquity = (23.4393 - 0.013 * T).DtoR();

    obliquity = -46.8150   * T
	        - 0.00059  * T2
	        + 0.001813 * T3;

    obliquity /= 3600.0;
    obliquity += 23.43929111;
    obliquity = obliquity.DtoR();

    sun.obliquity = moon.obliquity = obliquity;
}

// calculate nutation and equation of the equinoxes in radians
// requires obliquity to be calculated first!
// Meeus (1991, 131-132)
function calcNutation(jday, sun, moon)
{
    var
	T,		// Julian centuries since J2000
	T2,
	L_s,		// Sun's mean longitude
	G_s,		// Sun's mean anomaly
	L_m,		// Moon's mean longitude
	N_m,		// longitude of Moon's ascending node
	nut_lon,	// nutation in longitude; for comparing with MICA
	nut_obl,	// nutation in obliquity
	eq_equinoxes;	// equation of the equinoxes

    T = (jday - J2000) / 36525;
    T2 = T * T;

    /* fundamental arguments in revolutions */
    L_s = 0.77907196 +  100.00213759 * T + 0.00000084 * T2;
    G_s = 0.99312619 +   99.99735956 * T - 0.00000044 * T2;
    L_m = 0.60643382 + 1336.85522267 * T - 0.00000313 * T2;
    N_m = 0.34734264 -    5.37260713 * T + 0.00000579 * T2;

    /* normalize to 0-1 and convert to radians */
    L_s = L_s.setRange(1) * Math.PI2;
    G_s = G_s.setRange(1) * Math.PI2;
    L_m = L_m.setRange(1) * Math.PI2;
    N_m = N_m.setRange(1) * Math.PI2;

    nut_lon = -17.200 * Math.sin(N_m)
              - 1.319 * Math.sin(2 * L_s)
	      - 0.227 * Math.sin(2 * L_m)
	      + 0.206 * Math.sin(2 * N_m)
	      + 0.143 * Math.sin(G_s);

    nut_obl =   9.203 * Math.cos(N_m)
	      + 0.574 * Math.cos(2 * L_s)
	      + 0.098 * Math.cos(2 * L_m)
	      - 0.090 * Math.cos(2 * N_m);
    
    nut_lon = (nut_lon / 3600).DtoR();
    nut_obl = (nut_obl / 3600).DtoR();
    eq_equinoxes = nut_lon * Math.cos(sun.obliquity + nut_obl);
    
    // results in radians
    sun.nut_lon = moon.nut_lon = nut_lon;
    sun.nut_obl = moon.nut_obl = nut_obl;
    sun.eq_equinoxes = moon.eq_equinoxes = eq_equinoxes;
}

// difference between terrestrial time (TT) and universal time (UT)
// from Espenak/Meeus, 2006, Five Millennium Canon of Solar Eclipses: -1999 to +3000
function calcDeltaT(jday, sun, moon)
{

    var
	deltaT,		// time difference in seconds
	T, 		// Julian centuries since J2000
	t,
	u,
	year;		// calendar year

    T = (jday - J2000) / 36525;

    year = 2000 + 100 * T;

    // current: 2005 to
    if (year >= 2005) {
	if (year < 2050) {
	    t = year - 2000;
	    deltaT = 62.92 + 0.32217 * t + 0.005589 * Math.square(t);
	}
	else if (year < 2150) {
	    t = (year - 1820) / 100;
	    deltaT = -20 + 32 * Math.square(t) - 0.5628 * (2150 - year);
	}
	else {	// >= 2150; guestimate
	    u = (year - 1820) / 100;
	    deltaT = -20 + 32 * Math.square(u);
	}
    }

    // historical: 1582 to 1985

    // 1986-2004
    else if (year >= 1986) {
	t = year - 2000;
	deltaT = 63.86 + 0.3345 * t - 0.060374 * Math.square(t)
		+ 0.0017275 * Math.pow(t, 3) + 0.000651814 * Math.pow(t, 4)
		+ 0.00002373599 * Math.pow(t, 5);
    }
    // 1961-1985
    else if (year >= 1961) {
	t = year - 1975;
	deltaT = 45.45 + 1.067 * t - Math.square(t) / 260 - Math.pow(t, 3) / 718;
    }
    // 1941-1960
    else if (year >= 1941) {
	t = year - 1950;
	deltaT = 29.07 + 0.407 * t - Math.square(t) / 233 + Math.pow(t, 3) / 2547;
    }
    // 1920-1940
    else if (year >= 1920) {
	t = year - 1920;
	deltaT = 21.20 + 0.84493 * t - 0.076100 * Math.square(t)
		+ 0.0020936 * Math.pow(t, 3);
    }
    // 1900-1919
    else if (year >= 1900) {
	t = year - 1900;
	deltaT = -2.79 + 1.494119 * t - 0.0598939 * Math.square(t)
		+ 0.0061966 * Math.pow(t, 3) - 0.000197 * Math.pow(t, 4);
    }
    // 1860-1899
    else if (year >= 1860) {
	t = year - 1860;
	deltaT = 7.62 + 0.5737 * t - 0.251754 * Math.square(t)
		+ 0.01680668 * Math.pow(t, 3) - 0.0004473624 * Math.pow(t, 4)
		+ Math.pow(t, 5) / 233174;
    }
    // 1800-1859
    else if (year >= 1800) {
	t = year - 1800;
	deltaT = 13.72 - 0.332447 * t + 0.0068612 * Math.square(t)
		+ 0.0041116 * Math.pow(t, 3) - 0.00037436 * Math.pow(t, 4) 
		+ 0.0000121272 * Math.pow(t, 5) - 0.0000001699 * Math.pow(t, 6)
		+ 0.000000000875 * Math.pow(t, 7);
    }
    // 1700-1799
    else if (year >= 1700) {
	t = year - 1700;
	deltaT = 8.83 + 0.1603 * t - 0.0059285 * Math.square(t)
		+ 0.00013336 * Math.pow(t, 3) - Math.pow(t, 4) / 1174000;
    }
    // 1600-1699
    else if (year >= 1600) {
	t = year - 1600;
	deltaT = 120 - 0.9808 * t - 0.01532 * Math.square(t) + Math.pow(t, 3) / 7129;
    }
    // 1582-1599
    else {
	u = (year - 1000) / 100;
	deltaT = 1574.2 - 556.01 * u + 71.23472 * Math.square(u)
		+ 0.319781 * Math.pow(u, 3) - 0.8503463 * Math.pow(u, 4)
		- 0.005050998 * Math.pow(u, 5) + 0.0083572073 * Math.pow(u, 6);
    }

    sun.deltaT = moon.deltaT = deltaT / 86400;	// in days
}

// ------------------------ sidereal time -----------------------------

// convert universal time (UT) to Greenwich sidereal time (GST)
// Meeus (1991, 83)
function GSTofUT(jday, ut)
{
    var
	T,		// Julian centuries since J2000
	T2, T3,
	gst0,		// GST of 0 h UT on jday
	gst;

    T = (jday - J2000) / 36525.0;
    T2 = T * T;
    T3 = T2 * T;

    // in hours
    gst0 = 6.697374558 + 2400.05133691 * T + 0.000025862 * T2 - 1.72e-9 * T3;

    return (gst0 + ut.UTtoST()).setRange(24);
}

// ---------------- refraction and parallax functions --------------------

// refraction in degrees from apparent altitude
// from G.G. Bennett (1982), also cited in Meeus (1991)
function refraction_app(alt, loc)
{
    var refraction;

    // avoid singularity
    if (alt < -4.3425 || alt > 89.9225)
	return 0;

    refraction = 1 / Math.tan((alt + 7.31 / (alt + 4.4)).DtoR());
    refraction *= loc.density;

    return refraction / 60;
}

// refraction in degrees from true altitude
function refraction_true(alt, loc)
{
    var refr0, refr;

    // avoid singularity in Saemundsson formula
    if (alt < -5.0016 || alt > 89.891)
	refr = 0;

    /*  iterate using Bennett (1982) formula (Meeus 1991)
	Results from Bennett and Saemundsson formulas at low altitudes
	aren't quite interchangeable if density has been adjusted for
	elevation. Differences are insignificant at altitudes > 5 deg.
    */
    else if (Math.abs(loc.elevation) > 1e-6 && alt <= 5) {
	refr0 = -1;
	refr  =  0;

	while (Math.abs(refr - refr0) > 0.01) {
	    refr0 = refr;
	    // avoid singularity
	    if (alt < -4.3425 || alt > 89.9225)
		return 0;

	    refr = 1 / Math.tan((alt + refr + 7.31 / (alt + refr + 4.4)).DtoR());
	    refr *= loc.density;
	    refr /= 60;
	}
    }
    // use Saemundsson (1986) formula
    else {
	refr = 1.02 / Math.tan((alt + 10.3 / (alt + 5.11)).DtoR());
	refr *= loc.density;
	refr /= 60;
    }

    return refr;
}

// parallax in degrees from geocentric altitude in degrees
function parallax_geo(alt, sin_hp, loc)
{
    var num, denom;

    num = loc.rho * sin_hp * Math.cos(alt.DtoR());
    denom = 1.0 - loc.rho * sin_hp * Math.sin(alt.DtoR());

    return Math.atan2(num, denom).RtoD();
}

// parallax in degrees from true topocentric altitude in degrees
function parallax_topo(alt, sin_hp, loc)
{
    return Math.asin(loc.rho * sin_hp * Math.cos(alt.DtoR())).RtoD();
}

// topocentric semidiameter from geocentric altitude
function getTopoSD()
{
    return this.sd0 * (1 + Math.sin(this.altitude.DtoR()) * this.sin_hp);
}

function addParallax(loc)
{
    if (this.sin_hp > 0)
	this.altitude += parallax_topo(this.altitude, this.sin_hp, loc);
}

// compute geocentric altitude from apparent topocentric altitude
function getGeoAlt(loc)
{
    var sin_hp = this.sin_hp;

    // subtract refraction
    alt = appAltToTrueAlt(this.altitude, loc);

    // correct for parallax
    if (sin_hp > 0)
	alt += parallax_topo(alt, sin_hp, loc);

    return alt;
}

// compute true topocentric altitude from geocentric altitude
function getTopoAlt(loc)
{
    var
	alt = this.altitude,
	sin_hp = this.sin_hp;
    var alt0 = alt;

    // correct for parallax
    if (sin_hp > 0)
	alt -= parallax_geo(alt, sin_hp, loc);

    return alt;
}

// compute apparent topocentric altitude from geocentric altitude
// doesn't handle negative altitudes for elevated observer
function getAppAlt(loc)
{
    var
	alt = this.altitude,
	sin_hp = this.sin_hp,
	sd = this.sd0 * (1 + Math.sin(alt.DtoR()) * sin_hp);

    // correct for parallax
    if (sin_hp > 0)
	alt -= parallax_geo(alt, sin_hp, loc);
	
    // correct for refraction if that would put the upper limb above the horizon
    if (alt + sd >= loc.rs_alt)
	alt += refraction_true(alt, loc);

    return alt;
}

// compute apparent altitude from geometric topocentric altitude
// doesn't alter object property
// doesn't handle negative altitudes for elevated observer
function getRefrAlt(loc)
{
    var
	alt = this.altitude,
	refraction;

    // correct for refraction if that would put the center above the horizon
    refraction = refraction_true(alt, loc);
    if (alt + refraction >= 0)
	alt += refraction;

    return alt;
}

// compute apparent altitude from geometric topocentric altitude
// changes object property
addRefraction = function(loc)
{
    this.altitude = trueAltToAppAlt(this.altitude, this.sd, loc);
};

// compute apparent altitude from geometric topocentric altitude
function trueAltToAppAlt(altitude, sd, loc)
{
    if (loc.height > 0) {
	/*
	    Elevated observer: combination of astronomical refraction
	    and refraction of the horizon.  Assume light ray travels in
	    circular arc; for altitude > rs_alt, arc passes through
	    virtual "horizon" that moves up and closer to observer as
	    altitude increases.  See Cameron et. al. (1963)
	*/
	// above horizon but alt <= 0: special handling of refraction
	if (altitude + sd >= loc.rs_alt && altitude + sd <= -loc.refr_0h_elev) {
	    var
		alt,
		density_vh,	// relative air density at elevation
		elev_vh,	// elevation of virtual horizon
		elevation,	// elevation at observer
		k,		// ray curvature in 1 / Earth radii
		r_E,		// Earth radius in meters
		y_diff;		// elevation difference

	    elevation = loc.elevation;
	    r_E = (EARTH_RADIUS * 1e3 * loc.rho);

	// add astronomical refraction at the actual or virtual horizon
	    // rough empirical approximation to methods of Sweer (1938)

	    // initial estimate of altitude of virtual horizon:
	    // use ground-level astronomical refraction

	    alt = altitude + loc.refr_0h * loc.density_gnd;

	    var alt0 = -99;
	    // use ground level at horizon as initial estimate
	    elev_vh = loc.elevation - loc.height;
	    y_diff = loc.height;
	    while (Math.abs(alt - alt0) > 0.01) {
		alt0 = alt;

		// elevation difference that that would put virtual horizon at alt
		// empirical "representative" value of k
		k = calc_k(elev_vh + y_diff / 3);
		if (alt < 0)
		    y_diff = (1 - k) * r_E / 2 * Math.square(alt.DtoR());
		else
		    y_diff = 0;

		// density at elevation of virtual horizon
		elev_vh = elevation - y_diff;
		density_vh = calcDensity(elev_vh);

		alt = altitude + loc.refr_0h * density_vh;
	    }

	    // adjusted true altitude of virtual horizon
	    altitude = alt;

	// add terrestrial refraction of virtual horizon from observer's height
	    if (altitude < 0) {
		// "representative" value of k
		k = calc_k(elev_vh + y_diff / 3);
		// apparent altitude
		altitude *= (1 - k);
	    }
	}

	/*
	    If refraction is included for altitude <= -loc.refr_0h_elev, it
	    must be included for altitude > -loc.refr_0h_elev to avoid
	    decrease in apparent altitude as transition is crossed.
	*/
	else if (altitude + sd > -loc.refr_0h_elev)
	    altitude += refraction_true(altitude, loc);
    }

    // normal situation: ground-level observer, astronomical refraction
    // add refraction if it would make top of body visible
    else if (altitude + sd >= loc.rs_alt)
	altitude += refraction_true(altitude, loc);

    return altitude;
}

// compute geometric topocentric altitude from apparent altitude
function appAltToTrueAlt(alt_app, loc)
{
    var alt_true;

    // correct for refraction if body visible at specified altitude

    // no rise/set alt specified; ground-level or elevated observer
    if (Math.abs(alt_app) < 1e-9)
	alt_true = loc.rs_alt;

    // elevated observer; altitude above apparent horizon but < 0
    else if (loc.height > 0 && alt_app >= -loc.dip && alt_app < 0) {
	// rough empirical approximation to methods of Sweer (1938)

	var
	    density_vh,		// density at virtual horizon relative to sea level
	    elev_vh,		// elevation of virtual horizon
	    elevation,		// observer's elevation
	    k,			// curvature of ray path
	    r_E,		// Earth radius in meters
	    y_diff;		// elevation difference calculated from altitude

	elevation = loc.elevation;
	// initial estimate: elevation of horizon
	elev_vh = loc.elevation - loc.height;
	r_E = EARTH_RADIUS * 1e3 * loc.rho;

	y_diff = loc.height;
	// empirical "representative" value of k
	k = calc_k(elev_vh + y_diff / 3);

	// elevation difference corresponding to apparent alt
	y_diff = Math.square(alt_app.DtoR()) * r_E / (2 * (1 - k));

	// true topocentric altitude of virtual horizon
	alt_true = alt_app / (1 - k);

	// relative air density at elevation of virtual horizon
	elev_vh = elevation - y_diff;
	density_vh = calcDensity(elev_vh);

	// subtract astronomical refraction at virtual horizon
	alt_true -= loc.refr_0h * density_vh;
    }

    // ground-level or elevated observer; app altitude > 0
    else if (alt_app >= 0)
	alt_true = alt_app - refraction_app(alt_app, loc);
    else
	alt_true = alt_app;

    return alt_true;
}

// angle of path with parallel of altitude
function getPathAngle(loc)
{
    var
	alt = this.altitude.DtoR(),
	argument,
	declination = this.declination;

    argument = (loc.sin_lat - Math.sin(declination) * Math.sin(alt))
		   / (Math.cos(declination) * Math.cos(alt));

    if (argument > 1.0)
	return 0;
    else if (argument < -1)
	return 180;
    else
	return Math.acos(argument).RtoD();
}

// altitude, azimuth in degrees
// returns declination in radians
function calcDeclination(altitude, azimuth, loc)
{
    var alt, az, arg;

    alt = altitude.DtoR();
    az  = azimuth.DtoR();

    arg = Math.sin(alt) * loc.sin_lat + Math.cos(alt) * loc.cos_lat * Math.cos(az);

    return Math.asin(arg);
}

// declination in radians
function calcDecl(loc)
{
    this.declination = calcDeclination(this.altitude, this.azimuth, loc);
}

// -------------------- coordinate conversion ----------------------------

// get topocentric ecliptic coordinates
// Meeus (1991, Ch 39, 266)
function eclipticToTopo(loc)
{
    var
	num,
	denom,
	cos_obl,
	sin_obl,
	rhoCosPhi = loc.rhoCosPhi,
	rhoSinPhi = loc.rhoSinPhi,
	lambda_g = this.lambda,	// body's geocentric ecliptic longitude
	beta_g = this.beta,	// body's geocentric ecliptic latitude
	lambda_t,		// body's topocentric ecliptic longitude
	beta_t,			// body's topocentric ecliptic latitude
	cos_beta,
	lst,
	cos_lst,
	sin_lst,
	sin_hp = this.sin_hp;	// sine of horizontal parallax

    lst = (this.gst + loc.longitude / 15).setRange(24);

    // get topocentric ecliptic longitude and latitude
    cos_obl  = Math.cos(this.obliquity + this.nut_obl);
    sin_obl  = Math.sin(this.obliquity + this.nut_obl);
    cos_beta = Math.cos(beta_g);
    cos_lst  = Math.cos(lst.HtoR());
    sin_lst  = Math.sin(lst.HtoR());

    denom = Math.cos(lambda_g) * cos_beta - rhoCosPhi * sin_hp * cos_lst;

    // topocentric ecliptic longitude
    num = Math.sin(lambda_g) * cos_beta
	- sin_hp * (rhoSinPhi * sin_obl + rhoCosPhi * cos_obl * sin_lst);
    lambda_t = Math.atan2(num, denom);
    if (lambda_t < 0.0)
	lambda_t += Math.PI2;

    // topocentric ecliptic latitude
    num = Math.cos(lambda_t) * (Math.sin(beta_g)
	- sin_hp * (rhoSinPhi * cos_obl - rhoCosPhi * sin_obl * sin_lst));
    beta_t = Math.atan(num / denom);

    this.lambda_t = lambda_t;
    this.beta_t = beta_t;
}

// convert ecliptic coordinates to equatorial
// RA and declination in radians
function eclipticToEquat(obliquity)
{
    var 
	sin_long,
	cos_obl,
	sin_obl;

    sin_long = Math.sin(this.lambda);
    sin_obl =  Math.sin(obliquity);
    cos_obl =  Math.cos(obliquity);

    this.ra = Math.atan2(sin_long * cos_obl
		 - Math.tan(this.beta) * sin_obl, Math.cos(this.lambda));
    if (this.ra < 0.0)
	this.ra += Math.PI2;
    this.declination = Math.asin(Math.sin(this.beta) * cos_obl
		      + Math.cos(this.beta) * sin_obl * sin_long);
}

// convert geocentric equatorial coordinates to topocentric
// from Meeus (1991, Ch. 39, 264)
// "alternative" method: Eqs. 39.6, 39.7
function geoToTopo(loc)
{
    var
	lha = (this.gha + loc.longitude).DtoR(),	// Local hour angle
	cos_dec = Math.cos(this.declination),
	a = cos_dec * Math.sin(lha),
	b = cos_dec * Math.cos(lha) - loc.rhoCosPhi * this.sin_hp,
	c = Math.sin(this.declination) - loc.rhoSinPhi * this.sin_hp,
	q = Math.sqrt(Math.square(a) + Math.square(b) + Math.square(c));

    // topocentric values
    this.lha = Math.atan2(a, b);
    this.ra = (this.gst.HtoR() + loc.longitude.DtoR()) - this.lha;
    this.declination = Math.asin(c / q);
    this.sd = this.sd0 / q;
}

// convert GHA/declination to az/alt
// RA and declination in radians
// Meeus (1991, 89)
function calcAltAz(loc)
{
    var
	arg, num, denom,
	lha = this.gst.HtoR() + loc.longitude.DtoR() - this.ra,
	decl = this.declination;
    var
	sin_lat = loc.sin_lat,
	cos_lat = loc.cos_lat;

    num = Math.sin(lha);
    denom = Math.cos(lha) * sin_lat - Math.tan(decl) * cos_lat;
    // take azimuth from north (Meeus 1991, 89)
    this.azimuth = Math.atan2(num, denom).RtoD() + 180;

    arg = sin_lat * Math.sin(decl) + cos_lat * Math.cos(decl) * Math.cos(lha);
    this.altitude = Math.asin(arg).RtoD();
    this.zenith = 90 - this.altitude;	// for comparison with USNO MICA
}

// compute azimuth at time of altitude crossing
// ref: "geo" | "topo" | (omitted)
// declination (handled elsewhere) must match!
function getAzRS(loc, type, ref)
{
    var
	alt_rs,
	azimuth,
	cos_az,
	declination = this.declination;

    if (arguments.length > 2 && ref == "geo")
	alt_rs = this.altitude.DtoR();		// geocentric
    else
	alt_rs = this.getTopoAlt(loc).DtoR();	// true topocentric alt

    cos_az =
	(Math.sin(declination) - loc.sin_lat * Math.sin(alt_rs))
	 / (loc.cos_lat * Math.cos(alt_rs));
    if (cos_az > 1.0)
	azimuth = null;
    else if (cos_az < -1.0)
	azimuth = null;
    else
	azimuth = Math.acos(cos_az).RtoD();

    if (azimuth === null)
	return null;
    else
	return (type == "R" ? azimuth : 360 - azimuth).setRange(360);
}

// adjust declination of rise/set to match alignment with body's upper or lower limb
// declination in radians
function adjustDecl(azimuth, sd, alt_rs_align, loc, type)
{
    var alt_rs;

    if (arguments.length > 0 && type == "geo")
	alt_rs = this.altitude;
    else
	// get true topocentric alt from geocentric
	alt_rs = this.getTopoAlt(loc);

    // adjust for alignment if necessary
    if (alt_rs_align == "top")
	alt_rs += sd;
    else if (alt_rs_align == "bottom")
	alt_rs -= sd;

    this.declination = calcDeclination(alt_rs, azimuth, loc);
}

// get minimum and maximum possible altitudes for given latitude
function getMaxAltRange(body, loc, minmax)
{
    var
	decl_max,
	decl_alt_min, decl_alt_max;

    switch (body) {
	case "Sun":
	    decl_max = 23.5;
	    break;
	case "Moon":
	    decl_max = 28.98;	// maximum 1900-2900
	    break;
	default:
	    alert("Invalid body '" + body + "'");
	    break;
    }

    if (loc.latitude < 0)
	decl_alt_max = Math.max(loc.latitude, -decl_max);
    else
	decl_alt_max = Math.min(loc.latitude, decl_max);
    decl_alt_min = -decl_alt_max;

    minmax[0] = Math.abs(decl_alt_min + loc.latitude) - 90;	// min
    minmax[1] = 90 - Math.abs(decl_alt_max - loc.latitude);	// max
}

// compute approximate altitude at upper transit
function getMaxAlt(loc)
{
    var
	altitude;

    altitude = 90 - Math.abs(this.declination.RtoD() - loc.latitude);
    // geocentric altitude
    this.altitude = altitude;

    return this.getAppAlt(loc);
}

// compute approximate altitude at lower transit
function getMinAlt(loc)
{
    var
	altitude;

    altitude = Math.abs(this.declination.RtoD() + loc.latitude) - 90;
    // geocentric altitude
    this.altitude = altitude;

    return this.getAppAlt(loc);
}

//******************************************************************

// alt/az crossing functions

/*
    find time of altitude crossing within altitude range; adjust
    altitude if necessary to put it within min/max altitudes for the day
    but outside the "forbidden" range
*/

function getRangeAltCrossing(jday, sun, spos, opt, loc)
{
    var
	alt_min, alt_max,
	alt, alt_true;
    var
	align = opt.alt_moon_s_range_align,
	type  = opt.moon_s_range_type;

    alt = opt.alt_moon_s_range;
    alt_true = opt.moon_s_range_true_alt;

    //if (opt.alt_sr_range === true) {
    if (type == "R") {
	alt_min = opt.alt_sr_min;
	alt_max = opt.alt_sr_max;
    }
    //else if (opt.alt_ss_range === true) {
    else if (type == "S") {
	alt_min = opt.alt_ss_min;
	alt_max = opt.alt_ss_max;
    }

    // if the user-specified range and the range of altitudes for the
    // day don't overlap; crossing does not occur
    if (alt_min > sun.maxalt || alt_max < sun.minalt)
	return false;

    // if the midpoint altitude is outside the range of altitudes for
    // the day, move the midpoint alt to within range of alts that occur
    // on the day
    if (alt < sun.minalt || alt > sun.maxalt) {
	// move the altitude to the midpoint of the range for the day
	if (alt_min < sun.minalt)
	    alt_min = sun.minalt;
	else if (alt_max > sun.maxalt)
	    alt_max = sun.maxalt;
	alt = (alt_min + alt_max) / 2;

	// check the new alt against the "forbidden" range;
	// adjust if necessary
	alt_true = appAltToTrueAlt(alt, loc);
	alt_true = check_forbidden_alt(alt, alt_true, align, loc);
    }
    // needed by getLimitTimes()
    opt.moon_s_range_true_alt_adj = alt_true;

    sun.moon_s_range_mid = spos.getEventTime(jday, loc, type, alt_true, align);
    if (sun.moon_s_range_mid.testEvent() === true) {
	// ignore parallax
	sun.az_moon_s_range = spos.getAzRS(loc, type, "geo");
	sun.decl_moon_s_range = spos.declination;
	sun.sd_moon_s_range = spos.sd0;
	return true;
    }
    else
	return false;
}

//******************************************************************

// calculate UT of rise/set/transit morning/evening twilight
// returns: UT or +/- infinity if no event
// method of Yallop and Hohenkerk (1992, 487)
// alt_rs is TRUE topocentric for rise/set, geocentric for twilight
function getEventTime(jday, loc, type, alt_rs, alt_rs_align)
{
    var
	cos_H,		// cosine of local hour angle
	longitude = loc.longitude,
	ntries,
	eps,		// convergence criterion
	sign,
	sin_h,		// sine of rise/set altitude
	lha0,		// local hour angle for position calculation
	lha,		// local hour angle of event
	sd,		// semidiameter
	ut,
	ut0 = -1;

    var
	sin_lat = loc.sin_lat,
	cos_lat = loc.cos_lat;

    switch (type) {
	case "M":
	case "R":
	case "T":	// upper transit
	case "LT":	// lower transit
	    sign = 1;
	    break;
	case "S":
	case "E":
	    sign = -1;
	    break;
	default:
	    break;
    }

    switch (type) {
	case "M":
	case "E":
	    // twilight: altitude is geocentric, nothing further needed
	    sin_h = Math.sin(alt_rs.DtoR());
	    break;
	case "T":
	    // transit; alt is irrelevant
	    break;
	default:
	    // Get geocentric altitude from true topocentric altitude.
	    // Once per day is enough for the Sun; the Moon's distance
	    // changes enough that it must be calculated for every
	    // iteration.
	    if (this.body == "Sun") {
		this.altitude = alt_rs;		// true topocentric
		this.addParallax(loc);		// geocentric
		// adjust for semidameter
		if (alt_rs_align == "top")
		    this.altitude -= this.getTopoSD();	//FIXME? sin_hp is from twilight
		else if (alt_rs_align == "bottom")
		    this.altitude += this.getTopoSD();

		sin_h = Math.sin(this.altitude.DtoR());
	    }
	    break;
    }

    // hack to make things work at a few places (e.g., Navy Town, AK)
    // near the date line
    if (loc.timezone > 0 && longitude < 0)
	longitude += 360;
    else if (loc.timezone < 0 && longitude > 0)
	longitude -= 360;

    ut = 12 - loc.longitude / 15;	// approximate local mean noon

    lha = 0;
    ut0 = ut - 12;
    ntries = 0;
    eps = (18).SecToH();		// convergence criterion
    while (Math.abs(ut - ut0) > eps) {
	if (++ntries > 10)
	    break;
	ut0 = ut;

	    // calculate position
	if (flags.interpolate_rs_positions === true)
	    this.interpPos(jday, ut, loc);
	else
	    this.calcPos(jday, ut);

	    // LHA for which position was calculated
	lha0 = this.gha + longitude;

	if (this.body == "Moon") {
	    this.altitude = alt_rs;	// true topocentric
	    this.addParallax(loc);	// geocentric
	    // adjust for semidameter
	    if (alt_rs_align == "top")
		this.altitude -= this.getTopoSD();
	    else if (alt_rs_align == "bottom")
		this.altitude += this.getTopoSD();
	
	    sin_h = Math.sin(this.altitude.DtoR());
	}

	    // calculate hour angle
	switch (type) {
	    case "T":
		cos_H = 1;		// upper transit at H = 0
		break;
	    case "LT":
		cos_H = -1;		// lower transit at H = 12
		break;
	    default:
		cos_H = (sin_h - sin_lat * Math.sin(this.declination)) /
			(cos_lat * Math.cos(this.declination));
	    break;
	}

	if (cos_H > 1)		// circumpolar; never rises
	    lha = 0;
	else if (cos_H < -1)	// circumpolar; never sets
	    lha = 180;
	else
	    lha = Math.acos(cos_H).RtoD();

	// Yallop and Hohenkerk (1992, 487, Eq. 9.33-2)
	ut = ut0 - (lha0 + sign * lha) / 15;

	// put the time in the range 0h to 24h local time
	while (ut < loc.ut_min)
	    ut += 24;
	while (ut > loc.ut_max)
	    ut -= 24;
    }

    if (cos_H > 1)
	ut = Number.NEGATIVE_INFINITY;	// circumpolar; never rises
    else if (cos_H < -1)
	ut = Number.POSITIVE_INFINITY;	// circumpolar; never sets
    else if (ntries > 10)
	ut = F_SET_NO_EVENT;		// event does not occur on date

    return ut;
}

// -------------------- position interpolation ----------------------------

// create 2-dimensional array
function Array2D2(rows, cols)
{
    var a = new Array(rows);

    for (var i = 0; i < rows; i++)
	a[i] = new Array(cols);

    return a;
}

// calculate Sun and Moon positions at 0h, 12h, and 24h LCT
// position functions handle delta T
function initPosArray(jday, loc)
{
    var max = 7;

    this.pos = Array2D2(max, 3);

    for (i = 0; i <= 2; i++) {
	// use time offset at 0h LCT; except for DST start/end dates,
	// it's the same as ut_offset
	this.calcPos(jday, i * 12 - loc.ut_offset_start);
	if (this.body == "Moon") {
	    this.pos[i][0] = this.lambda;
	    this.pos[i][1] = this.beta;
	    this.pos[i][2] = this.lambda_s;
	}
	else {
	    this.pos[i][0] = 0;
	    this.pos[i][1] = 0;
	    this.pos[i][2] = 0;
	}
	this.pos[i][3] = this.sin_hp;
	this.pos[i][4] = this.ra;
	this.pos[i][5] = this.declination;
	this.pos[i][6] = this.sd0;

	// ensure that lambda, lambda_s, and RA never jump from PI2 to 0
	if (i > 0) {
	    if (this.pos[i][0] <= this.pos[i-1][0])
		this.pos[i][0] += Math.PI2;
	    if (this.pos[i][2] <= this.pos[i-1][2])
		this.pos[i][2] += Math.PI2;
	    if (this.pos[i][4] <= this.pos[i-1][4])
		this.pos[i][4] += Math.PI2;
	}
    }
}

// interpolate Sun and Moon positions from values at 0h, 12h, and 24h
// similar to approach used in Sinnott (1989)
function interpPos(jday, ut, loc)
{
    var n;

    // use the time offset at 0h LCT to match initPosArray(); except for
    // DST start/end dates, it's the same as ut_offset
    // effect of delta T is already included in the arrays
    n = (ut + loc.ut_offset_start) / 24;

    if (this.body == "Moon") {
	// first 3 are needed to calculate Moon's phase
	this.lambda   = interpolate(this.pos[0][0], this.pos[1][0], this.pos[2][0], n);
	this.beta     = interpolate(this.pos[0][1], this.pos[1][1], this.pos[2][1], n);
	this.lambda_s = interpolate(this.pos[0][2], this.pos[1][2], this.pos[2][2], n);
	this.sin_hp   = interpolate(this.pos[0][3], this.pos[1][3], this.pos[2][3], n);
	this.sd0      = interpolate(this.pos[0][6], this.pos[1][6], this.pos[2][6], n);
    }
    else {
	// use noon values for Sun
	this.sin_hp = this.pos[1][3];
	this.sd0    = this.pos[1][6];
    }

    this.ra          = interpolate(this.pos[0][4], this.pos[1][4], this.pos[2][4], n);
    this.declination = interpolate(this.pos[0][5], this.pos[1][5], this.pos[2][5], n);

    this.gst = GSTofUT(jday, ut) + this.eq_equinoxes.RtoH();
    this.gha = this.gst - this.ra.RtoH();
    this.gha = this.gha.setRange(24) * 15;
}

// interpolate Sun and Moon positions from values at 0h, 12h, and 24h
// interpolating factor p = x - x1
function interpolate(y1, y2, y3, p)
{
    var a, c;

    a = y2 - y1;		// first difference
    c = y3 - y2 - a;		// second difference

    return y1 + p * (2 * a + c * (2 * p - 1));
}

// *********************** Sun object ******************************

function SunPos()
{
    this.body = "Sun";
    this.HP0= (8.794 / 3600).DtoR();	// at 1 AU (Meeus 1991, 263)
    this.SIN_HP0 = Math.sin(this.HP0);	// at 1 AU
    this.SD0 = 959.63 / 3600;		// geocentric SD, in deg, at 1 AU (Meeus 1991, 359)
}

SunPos.prototype.eclipticToEquat = eclipticToEquat;
SunPos.prototype.geoToTopo = geoToTopo;
SunPos.prototype.getTopoSD = getTopoSD;
SunPos.prototype.calcAltAz = calcAltAz;
SunPos.prototype.getGeoAlt = getGeoAlt;
SunPos.prototype.addParallax = addParallax;
SunPos.prototype.getTopoAlt = getTopoAlt;
SunPos.prototype.getAppAlt = getAppAlt;
SunPos.prototype.addRefraction = addRefraction;
SunPos.prototype.getRefrAlt = getRefrAlt;
SunPos.prototype.calcDecl = calcDecl;
SunPos.prototype.getAzRS = getAzRS;
SunPos.prototype.adjustDecl = adjustDecl;
SunPos.prototype.getMaxAlt = getMaxAlt;
SunPos.prototype.getMinAlt = getMinAlt;
SunPos.prototype.getPathAngle = getPathAngle;
SunPos.prototype.getEventTime = getEventTime;
SunPos.prototype.initPosArray = initPosArray;
SunPos.prototype.interpPos = interpPos;

/*
    Low-precision Sun ephemeris
    Van Flandern & Pulkkinen (1979)--approx 1' accuracy
    Fundamental arguments from Montenbruck & Pfleger (1999, 152-153)
    (N_m = L_m - F_m; L_s = L_m - D_ms)
    Greenwich Hour Angle (GHA) in degrees
    declination (from eclipticToEquat) in radians
*/
SunPos.prototype.calcPos = function(jday, ut)
{
    var
	T,	// time in Julian days since J2000
	T1900,	// time in Julian centuries since 1900.0
	L_s,	// Sun's mean longitude
	G_s,	// mean anomaly
	G_2,	// mean anomaly of Venus
	G_4,	// mean anomaly of Mars
	G_5,	// mean anomaly of Jupiter
	L_m,	// Moon's mean longitude
	N_m,	// longitude of Moon's ascending node
	lambda,
	dist;

    T = (jday + ut / 24.0 + this.deltaT - J2000) / 36525.0;
    T2 = T * T;
    T1900 = T + 1;

    /* fundamental arguments in revolutions; term numbers from V & P paper, p.392 */
    L_m = 0.60643382 + 1336.85522267 * T - 0.00000313 * T2;	/* term 1; M & P */
    N_m = 0.34734264 -    5.37260713 * T + 0.00000579 * T2;	/* term 5; M & P */
    L_s = 0.77907196 +  100.00213759 * T + 0.00000084 * T2;	/* term 7; M & P */
    G_s = 0.99312619 +   99.99735956 * T - 0.00000044 * T2;	/* term 8; M & P */
    G_2 = 0.140023   +  162.54946219 * T;			/* term 13 */
    G_4 = 0.053856   +   53.16627469 * T;			/* term 16 */
    G_5 = 0.056531   +    8.43029617 * T;			/* term 19 */

    /* normalize to 0-1 and convert to radians */
    L_m = L_m.setRange(1) * Math.PI2;
    N_m = N_m.setRange(1) * Math.PI2;
    L_s = L_s.setRange(1) * Math.PI2;
    G_s = G_s.setRange(1) * Math.PI2;
    G_2 = G_2.setRange(1) * Math.PI2;
    G_4 = G_4.setRange(1) * Math.PI2;
    G_5 = G_5.setRange(1) * Math.PI2;

    // ecliptic longitude - mean longitude, in arc sec; V & P "PLON"
    lambda = 6910 * Math.sin(G_s)
	    +  72 * Math.sin(2 * G_s)
	    -  17 * T1900 * Math.sin(G_s)
            -   7 * Math.cos(G_s - G_5)
	    +   6 * Math.sin(L_m - L_s)
	    +   5 * Math.sin(4 * G_s - 8 * G_4 + 3 * G_5)
	    -   5 * Math.cos(2 * G_s - 2 * G_2)
	    -   4 * Math.sin(G_s - G_2)
	    +   4 * Math.cos(4 * G_s - 8 * G_4 + 3 * G_5)
	    +   3 * Math.sin(2 * G_s - 2 * G_2)
	    -   3 * Math.sin(G_5)
	    -   3 * Math.sin(2 * G_s - 2 * G_5);

    lambda -= 20;		// annual aberration

    // V & P "RP", in AU
    dist = 1.00014
	 - 0.01675 * Math.cos(G_s)
	 - 0.00014 * Math.cos(2 * G_s);

    lambda *= (1).DtoR() / 3600.0;
    this.lambda = (L_s + lambda + this.nut_lon).setRange(Math.PI2);
    this.beta = 0;
    this.dist = dist;
    this.sin_hp = this.SIN_HP0 / dist;
    this.sd0 = this.SD0 / dist;

    // sets this.ra and this.declination
    this.eclipticToEquat(this.obliquity + this.nut_obl);

    // apparent GST
    this.gst = GSTofUT(jday, ut) + this.eq_equinoxes.RtoH();
    this.gha = this.gst - this.ra.RtoH();
    this.gha = this.gha.setRange(24) * 15;
};

// length of time Sun is above horizon
SunPos.prototype.getDayLen = function(rise, set)
{
    var
	day,
	rise_event = rise.testEvent(),
	set_event = set.testEvent();

    // handle set before rise
    if (rise_event === true && set_event === true) {
	if (rise < set)
	    day = set - rise;
	else
	    day = 24 - (rise - set);
    }
    else if (rise_event === false && set_event === false) {
	// we don't really need to test both, do we?
	if (rise >= F_CIRCUMPOLAR || set >= F_CIRCUMPOLAR) {
	    day = 24;
	}
	else
	    day = 0;
    }
    else if (rise_event === true && set_event === false)
	day = 24 - rise;
    else if (rise_event === false && set_event === true)
	day = set;

    return day;
};

// ************************ Moon object ******************************

function MoonPos()
{
    this.body = "Moon";
    this.RADIUS =  1738;	// km
    this.SD0 = "0:15:32.6".DMSto();	// Seidelmann 1992, 701
}

MoonPos.prototype.eclipticToEquat = eclipticToEquat;
MoonPos.prototype.geoToTopo = geoToTopo;
MoonPos.prototype.getTopoSD = getTopoSD;
MoonPos.prototype.calcAltAz = calcAltAz;
MoonPos.prototype.getGeoAlt = getGeoAlt;
MoonPos.prototype.addParallax = addParallax;
MoonPos.prototype.getTopoAlt = getTopoAlt;
MoonPos.prototype.getAppAlt = getAppAlt;
MoonPos.prototype.addRefraction = addRefraction;
MoonPos.prototype.getRefrAlt = getRefrAlt;
MoonPos.prototype.getAzRS = getAzRS;
MoonPos.prototype.adjustDecl = adjustDecl;
MoonPos.prototype.getMaxAlt = getMaxAlt;
MoonPos.prototype.getMinAlt = getMinAlt;
MoonPos.prototype.calcAltAz = calcAltAz;
MoonPos.prototype.calcDecl = calcDecl;
MoonPos.prototype.eclipticToTopo = eclipticToTopo;
MoonPos.prototype.getPathAngle = getPathAngle;
MoonPos.prototype.getEventTime = getEventTime;
MoonPos.prototype.initPosArray = initPosArray;
MoonPos.prototype.interpPos = interpPos;

/*
    Low-precision Moon ephemeris
    Van Flandern & Pulkkinen (1979)--approx 1' accuracy
    Fundamental arguments from Montenbruck & Pfleger (1999, 152-153)
    (N_m = L_m - F_m; L_s = L_m - D_ms), and J.  Meeus (1991, 200, Table
    30.A).
    Greenwich Hour Angle (GHA) in degrees
    declination (from eclipticToEquat) in radians
*/
MoonPos.prototype.calcPos = function(jday, ut)
{
    var
	T,		// time in Julian centuries since J2000
	T2,
	T1900,		// time in Julian centuries since 1900.0
	L_m,		// Moon's mean longitude
	G_m,		// Moon's mean anomaly
	F_m,		// Moon's mean distance from ascending node
	N_m,		// longitude of Moon's ascending node
	D_ms,		// Moon's mean elongation
	G_s,		// Sun's mean anomaly
	L_s,		// Sun's mean longitude
	G_2,		// mean longitude of Venus
	d_lambda,
	lambda,		// Moon's ecliptic longitude
	lambda_s,	// Sun's ecliptic longitude
	beta,		// Moon's ecliptic latitude
	dist;		// Earth-Moon distance, Earth radii

    T = (jday + ut / 24 + this.deltaT - J2000) / 36525.0;
    T2 = T * T;
    T1900 = T + 1;

    /* fundamental arguments in revolutions; term numbers from V & P (1979, 392) */
    L_m  = 0.60643382 + 1336.85522467 * T - 0.00000313 * T2;	/* term 1; M & P */
    G_m  = 0.37489701 + 1325.55240982 * T + 0.00002565 * T2;	/* term 2; M & P */
    F_m  = 0.25909118 + 1342.22782980 * T - 0.00000892 * T2;	/* term 3; M & P */
    D_ms = 0.82736186 + 1236.85308708 * T - 0.00000397 * T2;	/* term 4; M & P */
    N_m  = 0.34734264 -    5.37260513 * T + 0.00000579 * T2;	/* term 5; M & P */
    L_s  = 0.77907196 +  100.00213759 * T + 0.00000084 * T2;	/* term 7; M & P */
    G_s  = 0.99312619 +   99.99735956 * T - 0.00000044 * T2;	/* term 8; M & P */
    L_2  = 0.50549945 +  162.55336953 * T + 8.628e-07  * T2;	/* term 12; Meeus */

    /* normalize to 0-1 and convert to radians */
    L_m  = L_m.setRange(1)  * Math.PI2;
    G_m  = G_m.setRange(1)  * Math.PI2;
    F_m  = F_m.setRange(1)  * Math.PI2;
    D_ms = D_ms.setRange(1) * Math.PI2;
    N_m  = N_m.setRange(1)  * Math.PI2;
    L_s  = L_s.setRange(1)  * Math.PI2;
    G_s  = G_s.setRange(1)  * Math.PI2;
    L_2  = L_2.setRange(1)  * Math.PI2;

    // low-precision Sun longitude
    d_lambda = 6910 * Math.sin(G_s)
	      +  72 * Math.sin(2 * G_s)
	      -  17 * T1900 * Math.sin(G_s);

    d_lambda -= 20;		// annual aberration

    d_lambda *= (1).DtoR() / 3600.0;
    lambda_s = (L_s + d_lambda + this.nut_lon).setRange(Math.PI2);

    // ecliptic longitude - mean longitude, in arc sec; V & P "PLON"
    d_lambda = 22640 * Math.sin(G_m)			// major inequality
	      - 4586 * Math.sin(G_m - 2 * D_ms)		// evection
	      + 2370 * Math.sin(2 * D_ms)		// variation
	      +  769 * Math.sin(2 * G_m)		// major inequality
	      -  668 * Math.sin(G_s)			// annual inequality
	      -  412 * Math.sin(2 * F_m)		// reduction to the ecliptic
	      -  212 * Math.sin(2 * G_m - 2 * D_ms)
	      -  206 * Math.sin(G_m - 2 * D_ms + G_s)
	      +  192 * Math.sin(G_m + 2 * D_ms)
	      +  165 * Math.sin(2 * D_ms - G_s)
	      +  148 * Math.sin(G_m - G_s)
	      -  125 * Math.sin(D_ms)			// parallactic inequality
	      -  110 * Math.sin(G_m + G_s)
	      -   55 * Math.sin(2 * F_m - 2 * D_ms)
	      -   45 * Math.sin(G_m + 2 * F_m)
	      +   40 * Math.sin(G_m - 2 * F_m)
	      -   38 * Math.sin(G_m - 4 * D_ms)
	      +   36 * Math.sin(3 * G_m)
	      -   31 * Math.sin(2 * G_m - 4 * D_ms)
	      +   28 * Math.sin(G_m - 2 * D_ms - G_s)
	      -   24 * Math.sin(2 * D_ms + G_s)
	      +   19 * Math.sin(G_m - D_ms)
	      +   18 * Math.sin(D_ms + G_s)
	      +   15 * Math.sin(G_m + 2 * D_ms - G_s)
	      +   14 * Math.sin(2 * G_m + 2 * D_ms)
	      +   14 * Math.sin(4 * D_ms)
	      -   13 * Math.sin(3 * G_m - 2 * D_ms)
	      -   11 * Math.sin(G_m + 16 * L_s - 18 * L_2)
	      +   10 * Math.sin(2 * G_m - G_s)
	      +    9 * Math.sin(G_m - 2 * F_m - 2 * D_ms)
	      +    9 * Math.cos(G_m + 16 * L_s - 18 * L_2)
	      -    9 * Math.sin(2 * G_m - 2 * D_ms + G_s)
	      -    8 * Math.sin(G_m + D_ms)
	      +    8 * Math.sin(2 * D_ms - 2 * G_s)
	      -    8 * Math.sin(2 * G_m + G_s)
	      -    7 * Math.sin(2 * G_s)
	      -    7 * Math.sin(G_m - 2 * D_ms + 2 * G_s)
	      +    7 * Math.sin(N_m)
	      -    6 * Math.sin(G_m - 2 * F_m + 2 * D_ms)
	      -    6 * Math.sin(2 * F_m + 2 * D_ms)
	      -    4 * Math.sin(G_m - 4 * D_ms + G_s)
	      +    4 * T1900 * Math.cos(G_m + 16 * L_s - 18 * L_2)
	      -    4 * Math.sin(2 * G_m + 2 * F_m)
	      +    4 * T1900 * Math.sin(G_m + 16 * L_s - 18 * L_2)
	      +    3 * Math.sin(G_m - 3 * D_ms)
	      -    3 * Math.sin(G_m + 2 * D_ms + G_s)
	      -    3 * Math.sin(2 * G_m - 4 * D_ms + G_s)
	      +    3 * Math.sin(G_m - 2 * G_s)
	      +    3 * Math.sin(G_m - 2 * D_ms - 2 * G_s)
	      -    2 * Math.sin(2 * G_m - 2 * D_ms - G_s)
	      -    2 * Math.sin(2 * F_m - 2 * D_ms + G_s)
	      +    2 * Math.sin(G_m + 4 * D_ms)
	      +    2 * Math.sin(4 * G_m)
	      +    2 * Math.sin(4 * D_ms - G_s)
	      +    2 * Math.sin(2 * G_m - D_ms);

    // ecliptic latitude in arc sec; V & P "BETA"
    beta = 18461 * Math.sin(F_m)
	  + 1010 * Math.sin(G_m + F_m)
	  + 1000 * Math.sin(G_m - F_m)
	  -  624 * Math.sin(F_m - 2 * D_ms)
	  -  199 * Math.sin(G_m - F_m - 2 * D_ms)
	  -  167 * Math.sin(G_m + F_m - 2 * D_ms)
	  +  117 * Math.sin(F_m + 2 * D_ms)
	  +   62 * Math.sin(2 * G_m + F_m)
	  +   33 * Math.sin(G_m - F_m + 2 * D_ms)
	  +   32 * Math.sin(2 * G_m - F_m)
	  -   30 * Math.sin(F_m - 2 * D_ms + G_s)
	  -   16 * Math.sin(2 * G_m + F_m - 2 * D_ms)
	  +   15 * Math.sin(G_m + F_m + 2 * D_ms)
	  +   12 * Math.sin(F_m - 2 * D_ms - G_s)
	  -    9 * Math.sin(G_m - F_m - 2 * D_ms + G_s)
	  -    8 * Math.sin(F_m + N_m)
	  +    8 * Math.sin(F_m + 2 * D_ms - G_s)
	  -    7 * Math.sin(G_m + F_m - 2 * D_ms + G_s)
	  +    7 * Math.sin(G_m + F_m - G_s)
	  -    7 * Math.sin(G_m + F_m - 4 * D_ms)
	  -    6 * Math.sin(F_m + G_s)
	  -    6 * Math.sin(3 * F_m)
	  +    6 * Math.sin(G_m - F_m - G_s)
	  -    5 * Math.sin(F_m + D_ms)
	  -    5 * Math.sin(G_m + F_m + G_s)
	  -    5 * Math.sin(G_m - F_m + G_s)
	  +    5 * Math.sin(F_m - G_s)
	  +    5 * Math.sin(F_m - D_ms)
	  +    4 * Math.sin(3 * G_m + F_m)
	  -    4 * Math.sin(F_m - 4 * D_ms)
	  -    3 * Math.sin(G_m - F_m - 4 * D_ms)
	  +    3 * Math.sin(G_m - 3 * F_m)
	  -    2 * Math.sin(2 * G_m - F_m - 4 * D_ms)
	  -    2 * Math.sin(3 * F_m - 2 * D_ms)
	  +    2 * Math.sin(2 * G_m - F_m + 2 * D_ms)
	  +    2 * Math.sin(G_m - F_m + 2 * D_ms - G_s)
	  +    2 * Math.sin(2 * G_m - F_m - 2 * D_ms)
	  +    2 * Math.sin(3 * G_m - F_m);

    // V & P "RP", in Earth radii
    dist =  60.36298
	  -  3.27746 * Math.cos(G_m)
	  -  0.57994 * Math.cos(G_m - 2 * D_ms)
	  -  0.46357 * Math.cos(2 * D_ms)
	  -  0.08904 * Math.cos(2 * G_m)
	  +  0.03865 * Math.cos(2 * G_m - 2 * D_ms)
	  -  0.03237 * Math.cos(2 * D_ms - G_s)
	  -  0.02688 * Math.cos(G_m + 2 * D_ms)
	  -  0.02358 * Math.cos(G_m - 2 * D_ms + G_s)
	  -  0.02030 * Math.cos(G_m - G_s)
	  +  0.01719 * Math.cos(D_ms)
	  +  0.01671 * Math.cos(G_m + G_s)
	  +  0.01247 * Math.cos(G_m - 2 * F_m)
	  +  0.00704 * Math.cos(G_s)
	  +  0.00529 * Math.cos(2 * D_ms + G_s)
	  -  0.00524 * Math.cos(G_m - 4 * D_ms)
	  +  0.00398 * Math.cos(G_m - 2 * D_ms - G_s)
	  -  0.00366 * Math.cos(3 * G_m)
	  -  0.00295 * Math.cos(2 * G_m - 4 * D_ms)
	  -  0.00263 * Math.cos(D_ms + G_s)
	  +  0.00249 * Math.cos(3 * G_m - 2 * D_ms)
	  -  0.00221 * Math.cos(G_m + 2 * D_ms - G_s)
	  +  0.00185 * Math.cos(2 * F_m - 2 * D_ms)
	  -  0.00161 * Math.cos(2 * D_ms - 2 * G_s)
	  +  0.00147 * Math.cos(G_m + 2 * F_m - 2 * D_ms)
	  -  0.00142 * Math.cos(4 * D_ms)
	  +  0.00139 * Math.cos(2 * G_m - 2 * D_ms + G_s)
	  -  0.00118 * Math.cos(G_m - 4 * D_ms + G_s)
	  -  0.00116 * Math.cos(2 * G_m + 2 * D_ms)
	  -  0.00110 * Math.cos(2 * G_m - G_s);

    this.dist = dist;
    this.sin_hp = 1 / dist;

    d_lambda *= (1).DtoR() / 3600;
    lambda = (L_m + d_lambda + this.nut_lon).setRange(Math.PI2);
    beta *= (1).DtoR() / 3600;

    // geocentric SD
    this.sd0 = Math.asin(this.RADIUS / EARTH_RADIUS * this.sin_hp).RtoD();

    this.lambda = lambda;
    this.beta = beta;
    this.lambda_s = lambda_s;

    // sets this.ra and this.declination
    this.eclipticToEquat(this.obliquity + this.nut_obl);

    // apparent GST
    this.gst = GSTofUT(jday, ut) + this.eq_equinoxes.RtoH();
    this.gha = this.gst - this.ra.RtoH();
    this.gha = this.gha.setRange(24) * 15;
};

// calculate topocentric Moon phase
MoonPos.prototype.calcPhase = function(sun_dist, loc)
{
    var
	lambda,
	beta,
	cos_elong,
	long_diff,	// Moon-Sun longitude difference
	elong,		// Moon-Sun elongation
	phase_angle,	// Moon's phase angle
	moon_dist;	// Moon's distance in km

    sun_dist *= Math.AU;
    moon_dist = this.dist * EARTH_RADIUS;

    // get Moon's topocentric ecliptic coordinates
    this.eclipticToTopo(loc);
    lambda = this.lambda_t;
    beta = this.beta_t;

    long_diff = lambda - this.lambda_s;
    cos_elong = Math.cos(beta) * Math.cos(long_diff);
    elong = Math.acos(cos_elong);

    // Meeus (1991, 315-316)
    phase_angle = Math.atan2(sun_dist * Math.sin(elong),
			     moon_dist - sun_dist * cos_elong);
    this.phase = (1 + Math.cos(phase_angle)) / 2;
    this.phase_angle = Math.abs(phase_angle.RtoD());	// for testing

    // waxing/waning: topocentric observer
    if (long_diff.setRange(Math.PI2) < Math.PI)
	this.waxing = true;
    else
	this.waxing = false;
};

/*
    References

    Bennett, G.G. 1982.  The Calculation of Astronomical Refraction in
	Marine Navigation.  Journal of Navigation 35:255-259.

    Cameron, Winifred S., John H. Glenn, M.  Scott Carpenter, and John
	A. O'Keefe. 1963.  Effect of Refraction on the Setting Sun as
	Seen from Space in Theory and Observation.  Astronomical Journal
	68, no. 5 (June):348-351.

    Flanagan, David. 2006.  JavaScript: The Definitive Guide. 5th ed.
	Sebastopol, CA: O'Reilly Media, Inc.

    Meeus, Jean. 1991.  Astronomical Algorithms.  Richmond, VA:
	Willmann-Bell.

    Montenbruck, Oliver, and Pfleger, Thomas.  Astronomy on the Personal
	Computer. 4th ed.  Berlin: Springer- Verlag, 1999

    Saemundsson, Thorsteinn. 1986.  Astronomical Refraction.  Sky and
	Telescope 72 (July):70.

    Sinnott, Roger W. 1989.  Ups and Downs of the Moon.  Sky & Telescope,
	July 1989, 78-80

    Sweer, John. 1938.  The Path of a Ray of Light Tangent to the
	Surface of the Earth.  Journal of the Optical Society of America
	28 (September):327-329.

    Van Flandern, T.C., and K.F. Pulkkinen. 1979.  Low-Precision
	Formulae for Planetary Positions.  Astrophysical Journal
	Supplement Series 41:391-411.

    Yallop, B.D., and C.Y. Hohenkerk. 1992.  Astronomical Phenomena in
	Explanatory Supplement to the Astronomical Almanac, rev. ed.
	ed.  P. Kenneth Seidelmann.  Mill Valley, CA: University Science
	Books.
*/

/*
 *****************************************************************************
    output functions
 *****************************************************************************
*/

// *************************** output functions ********************************

function set_font_size()
{
    var
	FONT_SIZE =  flags.font_size;	// font size for printed output

    /* global */
    PRINT_STYLE = '<style>' + LF
		+ PAD4 + 'body {' + LF
		+ PAD8 + 'font-size: ' + FONT_SIZE + 'pt;' + LF
	        + PAD8 + 'margin-left: 0; margin-right: 0;' + LF
		+ PAD4 + '}' + LF
		+ PAD4 + 'table { font-size: ' + FONT_SIZE + 'pt; }' + LF
		+ '</style>' + LF;
}

// add context-sensitive help to output column headings
function add_help(name, href, tooltip)
{
    if (!href)
	return name;
    var link = "<a class=\"help\"";
    if (tooltip)
	link += " title=\"" + tooltip + "\"";
    link += " onclick='blur(); help(\"" + href + "\");'>" + name + "</a>";

    return link;

}

// add a link to set location to names on List Locations report
function add_place_link(name, ndx)
{
    var
	tag = '<a class="placeTag" title="Set location to ' + name + '"'
	    + LF + PAD12 +  'onclick="blur(); set_place(' + ndx + ');">'
	    + name + '</a>';
    return tag;
}

// add a link to set location to names on List Locations report
function add_date_link(tipStr, dateStr, date)
{
    var
	tag = '<a class="dateTag" title="Set Sun and Moon Positions Date to ' + tipStr + '"'
	    + LF + PAD12 + 'onclick="blur(); set_calc_date(' + date + ');">'
	    + dateStr + '</a>';
    return tag;
}

// generate a unique identifier for each window or tab
function makeWindowTag(calc_type)
{
    var tag;

    if (flags.sep_all_time_pos_windows === true) {
	if (flags.url_parameters === true) {
	    // use a time stamp--sequence won't work because it resets
	    // with each loading
	    var Today = new Date();
	    var hours   = Today.getHours();
	    var minutes = Today.getMinutes();
	    var seconds = Today.getSeconds();

	    tag = hours;

	    if (minutes < 10)
		tag += ':0' + minutes;
	    else
		tag += ':' + minutes;

	    if (seconds < 10)
		tag += ':0' + seconds;
	    else
		tag += ':' + seconds;
	}
	else {
	    // just use a numbered sequence
	    // use separate sequences for times and positions
	    if (calc_type == POSITIONS) {
		if (this.pos_seq === undefined)
		    this.pos_seq = 0;
		tag = ++this.pos_seq;
	    }
	    else {	// rise and set times
		if (this.times_seq === undefined)
		    this.times_seq = 0;
		tag = ++this.times_seq;
	    }
	}
	tag = ' (' + tag + ')';
    }
    else
	tag = '';

    return tag;
}

function begin_document(name)
{
    var
	d,
	handle,
	url;

    url = "";

    if (flags.use_popups === true) {
	var
	    wid = 0.98 * screen.availWidth,
	    ht = 0.86 * screen.availHeight,
	    xpos = 5,
	    ypos = 0.005 * screen.availHeight,
	    win_size,
	    win_attribs,
	    win_features;

	win_size = ",height=" + ht + ",width=" + wid + "," + win_attribs;
	win_attribs = "resizable=1,menubar=1,toolbar=0,status=1,scrollbars=1";
	win_pos = "left=" + xpos + "," + "top=" + ypos;
	win_features = win_size + "," + win_pos + "," + win_attribs;
	handle = window.open(url, name, win_features);
    }
    else
	handle = window.open(url, name, "");

    handle.document.close();
    handle.document.open("text/html");

    return handle;
}

// add "close", "Print", and "Help" buttons to bottom of output page
function add_buttons()
{
    var form;

    // omit buttons from printer-friendly output
    if (flags.print !== true) {
	form =  "<form name='Buttons' action='none'>" + LF;
	form += "<center>" + LF;

	form += "<INPUT type='button' value='Close' onClick='window.close()'>" + LF;
	// generate printer-friendly page
	// not available with all results sent to different windows
	// because only one result each for times and positions is
	// saved, and reformatting would use the latest result rather than
	// the one being reformatted

	if (flags.sep_all_time_pos_windows === false)
	    form += SP2 + "<input type='button' value='Print' onclick='reformat(\"" + this.type + "\")'>" + LF;
	form += SP2 + "<input type='button' value='Help'  style='font-weight: bold;' onclick='help()'>" + LF;

	form += "</center>" + LF;
	form += "</form>";

	this.buttons = form;
    }
    else
	this.buttons = null;
}

// **************** Sun and Moon positions ***********************************

// table header for Sun and Moon positions
function build_positions_header(hdr)
{
    var header;

    if (arguments.length > 0)
	header = hdr;
    else
	header = BR + LF;
    header += POS_TABLE;
    header += POS_TABLE_COLSPEC;
    header += THD + LF;
    header += TR + LF;
    header += TH21 + "Time";
    if (flags.show_ut === true)
	header += BR + " (UT)";
    header += THE + LF;
    header += TH14 + "Sun" + THE + LF;
    header += TH15 + "Moon" + THE + LF;
    header += TRE + LF;
    header += TR + LF;

    // Sun
    if (flags.show_mag_north === true)
	header += TH11 + add_help("Azimuth*", "posAzimuth") + THE + LF;
    else
	header += TH11 + add_help("Azimuth", "posAzimuth") + THE + LF;
    header += TH11 + add_help("Altitude", "posAltitude") + THE + LF;
    header += TH11 + add_help("Path" + BR + "Angle", "posPathAngle",
			      "Angle of Sun's path with horizon") + THE + LF;
    header += TH11 + add_help("Shadow" + BR + "Length", "posShadowLength",
			      "Shadow length of object of unit height")  + THE + LF;

    // Moon
    if (flags.show_mag_north === true)
	header += TH11 + add_help("Azimuth*", "posAzimuth") + THE + LF;
    else
	header += TH11 + add_help("Azimuth", "posAzimuth") + THE + LF;
    header += TH11 + add_help("Altitude", "posAltitude") + THE + LF;
    header += TH11 + add_help("Path" + BR + "Angle", "posPathAngle",
			      "Angle of Moon's path with horizon") + THE + LF;
    header += TH11 + add_help("Phase", "posPhase",
			      "Fraction of Moon illuminated") + THE + LF;
    header += TH11 + add_help("SD", "posSD", "Semidiameter") + THE + LF;

    header += TRE + LF;
    header += THDE + LF;
    header += TBD + LF;

    this.positions_header = header;
}

// ************ document header for rise/set times and positions **************

function build_results_doc_head(title)
{
    var head;

    head  = "<head>" + LF;
    head += CONTENT + LF;
    head += "<title>Sun/Moon " + title + "</title>" + LF;
    head += SCRIPT;
    head += STYLE;
    if (flags.print === true && flags.use_font_size === true)
	head += PRINT_STYLE;
    head += "</head>" + LF;

    this.doc_head = head;
}

// output times or positions results
function output_results(type)
{
    var i, handle, d, results;

    // build the top of page
    this.doc_body = '<body>' + LF;
    this.doc_body += this.page_top;

    // add the calculation results
    // Sun/Moon rise/set positons
    if (this.rs_criteria)
	this.doc_body += this.rs_criteria;
    this.doc_body += this.times_header;
    // Sun/Moon rise and set times
    if (this.times.length > 0) {
	for (i = 0; i < this.times.length; i++)
	    this.doc_body += this.times[i];
	this.doc_body += TBDE + LF;
	this.doc_body += TABLE_END + LF;
    }
    // Sun/Moon positions
    if (this.type == "positions") {
	this.doc_body += this.positions_header;
	if (this.positions.length > 0) {
	    for (i = 0; i < this.positions.length; i++)
		this.doc_body += this.positions[i];
	    this.doc_body += TBDE + LF;
	    this.doc_body += TABLE_END + LF;
	}
    }

    this.doc_body += BR + SP2 + this.copyright + LF;

    if (this.prog_time)
	this.doc_body += this.prog_time + BR + LF;

    if (this.buttons)
	this.doc_body += this.buttons;

    this.doc_body += LF + '</body>';

    results = DOC_START + this.doc_head + this.doc_body + DOC_END;

    // create the document
    handle = begin_document(this.name);
    d = handle.document;

    // output the results
    //write_db(results);		// show the code
    d.write(results);
    d.close();

    handle.focus();

    if (handle.print && flags.print === true)
	handle.print();
}

// information at top of times/positions results page
function build_page_top(calc_params, rs_opts, loc)
{
    var header, title, time_zone, elev_units;

    if (flags.elevation_in_feet === true)
	elev_units = "ft";
    else
	elev_units = "m";

    header = "";

    title = "Location: " + loc.name.replace(/'/g, "&rsquo;");
    header += SP + title.big().bold() + BR + LF;

    if (loc.latitude < 0)
	title = "Latitude: " + (-loc.latitude).toDMS(2) + " S";
    else
	title = "Latitude: " + loc.latitude.toDMS(2) + " N";
    header += SP + title.bold() + ",";

    if (loc.longitude < 0)
	title = "Longitude: " + (-loc.longitude).toDMS(2) + " W";
    else
	title = "Longitude: " + loc.longitude.toDMS(2) + " E";
    header += SP + title.bold();

    if (flags.elevation_in_feet === true)
	loc.elevation = loc.elevation.MtoFT();
    if (loc.elevation < 0)
	title = "Elevation: " + MINUS + addCommas(Math.round(-loc.elevation));
    else if (loc.elevation > 0)
	title = "Elevation: " + addCommas(Math.round(loc.elevation));

    title += " " + elev_units;

    if (loc.elevation !== 0)
	header += "," + SP + title.bold();

    header += BR + LF;
    
    title = "Time Zone: ";
    // show fractional time zones as h:mm
    if (Math.floor(loc.timezone) != loc.timezone) {
	if (loc.timezone < 0)
	    title += "UTC" + MINUS + (-loc.timezone).toDMS();
	else
	    title += "UTC+" + loc.timezone.toDMS();
    }
    else {
	if (loc.timezone < 0)
	    title += "UTC" + MINUS + (-loc.timezone);
	else
	    title += "UTC+" + loc.timezone;
    }
    if ((time_zone = loc.getTimezone()))
	title += " (" + time_zone + ")";
    header += SP + title.bold() + BR + LF;

    /*
	show magnetic declination if mean date is within 1 year of model
	range or azimuths relative to true north or conversions between
	true and magnetic north are specified
    */
    if (loc.mag_dec_date_valid != INVALID ||
      flags.show_mag_north === true || flags.show_az_adjust === true) {
	title = add_help("Magnetic Declination: ", "magdec");
	if (loc.mag_dec_mean < 0)
	    title += (-loc.mag_dec_mean).toFixed(3) + DEG + " W";
	else
	    title += loc.mag_dec_mean.toFixed(3) + DEG + " E";
	title = title.bold();

	// show date for mag declination if calculation period is > 6 months
	if (calc_params.end_date - calc_params.start_date > 180)
	    title += " on " + loc.mag_date_str;

	// warn if mean date is outside model range
	if (loc.mag_dec_date_valid != VALID)
	    title += SP2 + "(Caution: outside magnetic model range of "
		  + mag_model.valid_range_str + ")";

	header += SP + title + BR + LF;
    }

    title = (flags.show_mag_north === true ? "Magnetic" : "True") + " North";
    title = "Azimuths relative to " + title.bold();

    // show the conversion between true and magnetic north if specified
    // don't show if there is no difference
    if (flags.show_az_adjust === true && Math.abs(loc.mag_dec_mean) >= -0.05) {
	var az_adjustment;
	if (loc.mag_dec_mean < 0) {	// west declination
	    az_adjustment = (-loc.mag_dec_mean).toFixed(1);
	    if (flags.show_mag_north === true)
		title += " (subtract " + az_adjustment + DEG + " for True North)";
	    else
		title += " (add " +  az_adjustment + DEG + " for Magnetic North)";
	}
	else {				// east declination
	    az_adjustment = loc.mag_dec_mean.toFixed(1);
	    if (flags.show_mag_north === true)
		title += " (add " +  az_adjustment + DEG + " for True North)";
	    else	// true to magnetic
		title += " (subtract " + az_adjustment + DEG + " for Magnetic North)";
	}
    }

    /*
	when calculating rise/set times and showing azimuths relative to
	magnetic north, warn if all or part of calculation range is
	outside model range (warning given with magnetic declination
	suffices when calculating positions; there is no range of dates)
    */
    if (calc_params.calc_type == TIMES && flags.show_mag_north === true &&
      loc.mag_dec_valid === false) {
	    title += SP2 + "(Caution: ";
	    if (calc_params.start_date > mag_model.end_date + MagModel.GRACE ||
	      calc_params.end_date < mag_model.start_date - MagModel.GRACE)
		title += "all dates ";
	    else
		title += "some dates ";
	    title += "outside magnetic model range of "
		  + mag_model.valid_range_str + ")";
    }

    header += SP + title + BR + LF;

    if (loc.height > 0) {
	if (flags.elevation_in_feet === true)
	    loc.height = loc.height.MtoFT();

	title = add_help("Height above Horizon:", "HeightAboveHorizon")
	      + SP + addCommas(loc.height.toFixed(0)) + " " + elev_units
	      + SP + "(elevation at horizon:"
	      + SP + addCommas((loc.elevation - loc.height).toFixed(0)) + " " + elev_units + ")"
	      + BR + LF;
	title += SP + add_help("Dip of the horizon: ", "dip") + loc.dip.toFixed(2) + "&deg;";
	header += SP + title + BR + LF;
    }

    this.page_top = header;
}

// show rise/set criteria with times output
function add_rs_criteria(calc_params, rs_opts)
{
    // ---------- functions for Sun and Moon criteria -----------

    function add_sun_criteria()
    {
	var align;

	/* sunrise */
	// sunrise altitude range
	if (rs_opts.alt_sr_range === true) {
	    header += SP + "Sunrise Altitude ";
	    if (rs_opts.moon_s_range === true)
		align = rs_opts.alt_moon_s_range_align;	// should be "center"
	    else
		align = rs_opts.alt_sr_align;
	    switch (align) {
		case "center":
		    header += "(center): ";
		    break;
		case "bottom":
		    header += "(lower limb): ";
		    break;
		default:
		    header += "(upper limb): ";
		    break;
	    }
	    if (rs_opts.alt_sr_min < 0)
		header += MINUS + -Math.rnd(rs_opts.alt_sr_min, 2);
	    else
		header += Math.rnd(rs_opts.alt_sr_min, 2);
	    header += DEG + " to ";
	    if (rs_opts.alt_sr_max < 0)
		header += MINUS + -Math.rnd(rs_opts.alt_sr_max, 2);
	    else
		header += Math.rnd(rs_opts.alt_sr_max, 2);
	    header += DEG + BR + LF;
	}
	// single sunrise altitude !== 0 or != "top"
	else if (rs_opts.alt_sr !== 0  || rs_opts.alt_sr_align != "top") {
	    header += SP + "Sunrise Altitude:" + SP;
	    switch (rs_opts.alt_sr_align) {
		case "center":
		    header += "center at ";
		    break;
		case "bottom":
		    header += "lower limb at ";
		    break;
		default:
		    header += "upper limb at ";
		    break;
	    }
	    if (rs_opts.alt_sr < 0)
		header += MINUS + -Math.rnd(rs_opts.alt_sr, 2);
	    else
		header += Math.rnd(rs_opts.alt_sr, 2);
	    header += DEG + BR + LF;
	}

	// sunrise azimuth
	if (rs_opts.az_sr_check === true) {
	    header +=  SP + "Sunrise Azimuth: " + Math.rnd(rs_opts.az_sr_min, 2) + DEG;
	    if (rs_opts.az_sr_max != rs_opts.az_sr_min)
		header += " to " + Math.rnd(rs_opts.az_sr_max, 2) + DEG;
	    header += BR + LF;
	}

	/* sunset */
	// sunset altitude range
	if (rs_opts.alt_ss_range === true) {
	    header += SP + "Sunset Altitude" + SP;
	    if (rs_opts.moon_s_range === true)
		align = rs_opts.alt_moon_s_range_align;	// should be "center"
	    else
		align = rs_opts.alt_ss_align;
	    switch (align) {
		case "center":
		    header += "(center): ";
		    break;
		case "bottom":
		    header += "(lower limb): ";
		    break;
		default:
		    header += "(upper limb): ";
		    break;
	    }
	    if (rs_opts.alt_ss_min < 0)
		header += MINUS + -Math.rnd(rs_opts.alt_ss_min, 2);
	    else
		header += Math.rnd(rs_opts.alt_ss_min, 2);
	    header += DEG + " to ";
	    if (rs_opts.alt_ss_max < 0)
		header += MINUS + -Math.rnd(rs_opts.alt_ss_max, 2);
	    else
		header += Math.rnd(rs_opts.alt_ss_max, 2);
	    header += DEG + BR + LF;
	}
	// single sunset altitude !== 0 or != "top"
	else if (rs_opts.alt_ss !== 0  || rs_opts.alt_ss_align != "top") {
	    header += SP + "Sunset Altitude:" + SP;
	    switch (rs_opts.alt_ss_align) {
		case "center":
		    header += "center at ";
		    break;
		case "bottom":
		    header += "lower limb at ";
		    break;
		default:
		    header += "upper limb at ";
		    break;
	    }
	    if (rs_opts.alt_ss < 0)
		header += MINUS + -Math.rnd(rs_opts.alt_ss, 2);
	    else
		header += Math.rnd(rs_opts.alt_ss, 2);
	    header += DEG + BR + LF;
	}

	// sunset azimuth
	if (rs_opts.az_ss_check === true) {
	    header +=  SP + "Sunset Azimuth: " + Math.rnd(rs_opts.az_ss_min, 2) + DEG;
	    if (rs_opts.az_ss_max != rs_opts.az_ss_min)
		header += " to " + Math.rnd(rs_opts.az_ss_max, 2) + DEG;
	    header += BR + LF;
	}
    }

    function add_moon_criteria()
    {
	/* moonrise */
	// moonrise altitude range
	if (rs_opts.alt_mr_range === true) {
	    header += SP + "Moonrise Altitude" + SP;
	    switch (rs_opts.alt_mr_align) {
		case "center":
		    header += "(center): ";
		    break;
		case "bottom":
		    header += "(lower limb): ";
		    break;
		default:
		    header += "(upper limb): ";
		    break;
	    }
	    header += Math.rnd(rs_opts.alt_mr_min, 2) + DEG
		    + " to " + Math.rnd(rs_opts.alt_mr_max, 2) + DEG + BR + LF;
	}
	// single moonrise altitude !== 0 or != "top"
	else if (rs_opts.alt_mr !== 0 || rs_opts.alt_mr_align != "top") {
	    header += SP + "Moonrise Altitude:" + SP;
	    switch (rs_opts.alt_mr_align) {
		case "center":
		    header += "center at ";
		    break;
		case "bottom":
		    header += "lower limb at ";
		    break;
		default:
		    header += "upper limb at ";
		    break;
	    }
	    header += Math.rnd(rs_opts.alt_mr, 2) + DEG + BR + LF;
	}
	// moonrise event box checked without moonrise altitude range, with Sun alt range 
	else if (rs_opts.mr_event === true && rs_opts.moon_s_range === true) {
	    header += SP + "Moonrise Altitude:" + SP;
	    header += "upper limb at ";	// only allowable option
	    header += Math.rnd(rs_opts.alt_mr, 2) + DEG + BR + LF;
	}
	// moonrise azimuth range
	if (rs_opts.az_mr_check === true) {
	    header +=  SP + "Moonrise Azimuth: " + Math.rnd(rs_opts.az_mr_min, 2) + DEG;
	    if (rs_opts.az_mr_max != rs_opts.az_mr_min)
		header += " to " + Math.rnd(rs_opts.az_mr_max, 2) + DEG;
	    header += BR + LF;
	}

	// moonrise phase range--don't display unless range really is restricted
	if (rs_opts.phase_mr_check === true &&
	  (rs_opts.phase_mr_min > 0 || rs_opts.phase_mr_max < 1)) {
	    header +=  SP + "Moonrise Phase: " + Math.rnd(rs_opts.phase_mr_min, 4)
		     + " to " + Math.rnd(rs_opts.phase_mr_max, 4);
	    if (rs_opts.phase_mr_waxing === true)
		header += ", waxing";
	    else if (rs_opts.phase_mr_waning === true)
		header += ", waning";
	    header += BR + LF;
	}

	// moonrise semidiameter range--don't display unless range really is restricted
	if (rs_opts.sd_mr_check === true &&
	  (rs_opts.sd_mr_min > MOON_SD_MIN || rs_opts.sd_mr_max < MOON_SD_MAX)) {
	    //FIXME to show actual values?
	    header +=  SP + "Moonrise Semidiameter: " + Math.rnd(rs_opts.sd_mr_min, 4) + DEG
		     + " to " + Math.rnd(rs_opts.sd_mr_max, 4) + DEG;
	    header += BR + LF;
	}

	// Moonrise/Sun event time difference
	// show a time difference specified on the form but not one set by
	// the program
	if (rs_opts.tdiff_mr_specified === true) {
	    header += SP + "Moonrise ";
	    if (rs_opts.tdiff_mr_min < 0)
		header += -rs_opts.tdiff_mr_min + " min before " + rs_opts.tdiff_mr_type;
	    else
		header += rs_opts.tdiff_mr_min + " min after " + rs_opts.tdiff_mr_type;
	    header += " to ";
	    if (rs_opts.tdiff_mr_max < 0)
		header += -rs_opts.tdiff_mr_max + " min before " + rs_opts.tdiff_mr_type;
	    else
		header += rs_opts.tdiff_mr_max + " min after " + rs_opts.tdiff_mr_type;
	    header += BR + LF;
	}

	/*
	    criteria for moonset
	*/

	// moonset altitude range
	if (rs_opts.alt_ms_range === true) {
	    header += SP + "Moonset Altitude" + SP;
	    switch (rs_opts.alt_ms_align) {
		case "center":
		    header += "(center): ";
		    break;
		case "bottom":
		    header += "(lower limb): ";
		    break;
		default:
		    header += "(upper limb): ";
		    break;
	    }
	    header += Math.rnd(rs_opts.alt_ms_min, 2) + DEG
		    + " to " + Math.rnd(rs_opts.alt_ms_max, 2) + DEG + BR + LF;
	}
	// moonset altitude !== 0
	else if (rs_opts.alt_ms !== 0  || rs_opts.alt_ms_align != "top") {
	    header += SP + "Moonset Altitude:" + SP;
	    switch (rs_opts.alt_ms_align) {
		case "center":
		    header += "center at ";
		    break;
		case "bottom":
		    header += "lower limb at ";
		    break;
		default:
		    header += "upper limb at ";
		    break;
	    }
	    header += Math.rnd(rs_opts.alt_ms, 2) + DEG + BR + LF;
	}
	// moonset box checked with Sun alt range
	else if (rs_opts.ms_event === true && rs_opts.moon_s_range === true) {
	    header += SP + "Moonset Altitude:" + SP;
	    header += "center at ";
	    header += Math.rnd(rs_opts.alt_ms, 2) + DEG + BR + LF;
	}

	// moonset azimuth range
	if (rs_opts.az_ms_check === true) {
	    header +=  SP + "Moonset Azimuth: " + Math.rnd(rs_opts.az_ms_min, 2) + DEG;
	    if (rs_opts.az_ms_max != rs_opts.az_ms_min)
		header += " to " + Math.rnd(rs_opts.az_ms_max, 2) + DEG;
	    header += BR + LF;
	}

	// moonset phase range
	if (rs_opts.phase_ms_check === true &&
	  (rs_opts.phase_ms_min > 0 || rs_opts.phase_ms_max < 1)) {
	    header +=  SP + "Moonset Phase: " + Math.rnd(rs_opts.phase_ms_min, 4)
		     + " to " + Math.rnd(rs_opts.phase_ms_max, 4);
	    if (rs_opts.phase_ms_waxing === true)
		header += ", waxing";
	    else if (rs_opts.phase_ms_waning === true)
		header += ", waning";
	    header += BR + LF;
	}

	// moonset semidiameter range--don't display unless range really is restricted
	if (rs_opts.sd_ms_check === true &&
	  (rs_opts.sd_ms_min > MOON_SD_MIN || rs_opts.sd_ms_max < MOON_SD_MAX)) {
	    header +=  SP + "Moonset Semidiameter: " + Math.rnd(rs_opts.sd_ms_min, 3) + DEG
		     + " to " + Math.rnd(rs_opts.sd_ms_max, 3) + DEG;
	    header += BR + LF;
	}

	// Moonset/Sun event time difference
	// show a time difference specified on the form but not one set by
	// the program
	if (rs_opts.tdiff_ms_specified === true) {
	    header += SP + "Moonset ";
	    if (rs_opts.tdiff_ms_min < 0)
		header += -rs_opts.tdiff_ms_min + " min before " + rs_opts.tdiff_ms_type;
	    else
		header += rs_opts.tdiff_ms_min + " min after " + rs_opts.tdiff_ms_type;
	    header += " to ";
	    if (rs_opts.tdiff_ms_max < 0)
		header += -rs_opts.tdiff_ms_max + " min before " + rs_opts.tdiff_ms_type;
	    else
		header += rs_opts.tdiff_ms_max + " min after " + rs_opts.tdiff_ms_type;
	    header += BR + LF;
	}
    }
    // -----------------------------------------------------------------

    if (rs_opts.selections === false) {
	this.rs_criteria = null;

	if (rs_opts.rs_alts === false)
	    return;
    }

    var
	header = "",
	date_step_units = [ "days", "weeks", "months (30 day)", "months (1/12 year)", "years" ];

    if (rs_opts.selections === true) {
	var
	    StartDate = new Date(calc_params.start_date.DayToMsec()),
	    EndDate = new Date(calc_params.end_date.DayToMsec());
	header = SP + 'Dates: ' + StartDate.toLocDateStr(0)
	       + ' to ' + EndDate.toLocDateStr(0) + BR + LF;
	if (calc_params.date_step != 1)
	    header += SP + 'Date Interval: '
		   + (calc_params.date_step / calc_params.date_step_units_value)
		   + ' ' + date_step_units[calc_params.date_step_units_ndx] + BR + LF;
    }

    if (rs_opts.moon_s_range === false)
	add_sun_criteria();
    add_moon_criteria();
    if (rs_opts.moon_s_range === true)
	add_sun_criteria();

    // indicate Universal Time
    if (flags.show_ut === true)
	header += SP + "Times in " + "UT".bold() + BR + LF;

    if (rs_opts.selections === true) {
	if (rs_opts.matches == 1)
	    header += BR + SP + rs_opts.matches + ' date meets criteria:';
	else if (rs_opts.matches > 0)
	    header += BR + SP + rs_opts.matches + ' dates meet criteria:';
	header += BR + LF;
    }

    this.rs_criteria = header;
}

// ***************** Sun and Moon rise and set times ***********************

// table header for Sun and Moon rise and set times
function build_times_header(rs_opts)
{
    var
	header,
	rs_alt_precis = 2;	// precision for nonzero rise/set alts

    if (this.times.length === 0) {
	this.times_header = BR + SP2 + "**** No dates meet criteria ****".big().bold() + BR;
	return;
    }

    header = BR + LF;
    header += TIMES_TABLE;
    header += TIMES_TABLE_DATE_COLSPEC;
    if (flags.show_all_twilight === true)
	header += TIMES_TABLE_SUN_COLSPEC2;
    else
	header += TIMES_TABLE_SUN_COLSPEC1;
    if (rs_opts.show_tdiff !== null)
	header += TIMES_TABLE_MOON_COLSPEC2;
    else
	header += TIMES_TABLE_MOON_COLSPEC1;

    header += THD + LF;
    header += TR + LF;
    header += TH31 + "Day" + THE + LF;
    header += TH31 + "Date" + THE + LF;
    if (flags.show_all_twilight === true)
	header += TH113 + "Sun" + THE + LF;
    else
	header += TH19 + "Sun" + THE + LF;

    if (rs_opts.show_tdiff !== null)
	header += TH19 + "Moon" + THE + LF;
    else
	header += TH18 + "Moon" + THE + LF;
    header += TRE + LF;

    // Sun
    header += TR + LF;
    if (flags.show_all_twilight === true) {
	header += TH21 + add_help("Astro" + BR + "Dawn", "timeAstroDawn",
				  "Beginning of morning astronomical twilight") + THE + LF;
	header += TH21 + add_help("Naut" + BR + "Dawn", "timeNautDawn",
				  "Beginning of morning nautical twilight") + THE + LF;
	header += TH21 + add_help("Civil" + BR + "Dawn", "timeDawn",
				  "Beginning of morning civil twilight") + THE + LF;
    }
    else
	header += TH21 + add_help("Dawn", "timeDawn",
			          "Beginning of morning civil twilight") + THE + LF;
    
    header += TH21 + add_help("Rise", "timeRise");
    if (rs_opts.alt_sr_align == "center")
	header += RS_CENTER;
    else if (rs_opts.alt_sr_align == "bottom")
	header += RS_LOWER;
    if (rs_opts.alt_sr !== 0) {
	header += BR;
	if (rs_opts.alt_sr < 0)
	    header += MINUS + -Math.rnd(rs_opts.alt_sr, rs_alt_precis) + DEG;
	else
	    header +=  Math.rnd(rs_opts.alt_sr, rs_alt_precis) + DEG;
    }
    header += THE + LF;

    header += TH21 + add_help("Transit", "timeTransit") + THE + LF;

    header += TH21 + add_help("Set", "timeSet");
    if (rs_opts.alt_ss_align == "center")
	header += RS_CENTER;
    else if (rs_opts.alt_ss_align == "bottom")
	header += RS_LOWER;
    if (rs_opts.alt_ss !== 0) {
	header += BR;
	if (rs_opts.alt_ss < 0)
	    header += MINUS + -Math.rnd(rs_opts.alt_ss, rs_alt_precis) + DEG;
	else
	    header += Math.rnd(rs_opts.alt_ss, rs_alt_precis) + DEG;
    }
    header += THE + LF;

    if (flags.show_all_twilight === true) {
	header += TH21 + add_help("Civil" + BR + "Dusk", "timeDusk",
				  "End of evening civil twilight") + THE + LF;
	header += TH21 + add_help("Naut" + BR + "Dusk", "timeNautDusk",
				  "End of evening nautical twilight") + THE + LF;
	header += TH21 + add_help("Astro" + BR + "Dusk", "timeAstroDusk",
				  "End of evening astronomical twilight") + THE + LF;
    }
    else
	header += TH21 + add_help("Dusk", "timeDusk",
				  "End of evening civil twilight") + THE + LF;

    header += TH21 + add_help("Day" + BR + "Length", "dayLength")  + THE + LF;
    if (flags.show_mag_north === true)
	header += TH12 +add_help("Azimuth*", "timeRiseAzimuth") + THE + LF;
    else
	header += TH12 +add_help("Azimuth", "timeRiseAzimuth") + THE + LF;
    header += TH21 + add_help("Max" + BR + "Alt", "timeMaxAlt") + THE + LF;

    // Moon
    header += TH21 + add_help("Rise", "timeRise");
    if (rs_opts.alt_mr_align == "center")
	header += RS_CENTER;
    else if (rs_opts.alt_mr_align == "bottom")
	header += RS_LOWER;
    if (rs_opts.alt_mr !== 0) {
	header += BR;
	header += Math.rnd(rs_opts.alt_mr, rs_alt_precis) + DEG;
    }
    header += THE + LF;

    header += TH21 + add_help("Transit", "timeTransit")  + THE + LF;

    header += TH21 + add_help("Set", "timeSet");
    if (rs_opts.alt_ms_align == "center")
	header += RS_CENTER;
    if (rs_opts.alt_ms_align == "bottom")
	header += RS_LOWER;
    if (rs_opts.alt_ms !== 0) {
	header += BR;
	header += Math.rnd(rs_opts.alt_ms, rs_alt_precis) + DEG;
    }
    header += THE + LF;

    // Moon event - Sun event time difference
    if (rs_opts.show_tdiff !== null)
	header += TH21 + add_help("Time" + BR + "Diff", "timeTimeDiff") + THE + LF;

    if (flags.show_mag_north === true)
	header += TH12 +add_help("Azimuth*", "timeRiseAzimuth") + THE + LF;
    else
	header += TH12 +add_help("Azimuth", "timeRiseAzimuth") + THE + LF;
    header += TH21 + add_help("Max" + BR + "Alt", "timeMaxAlt") + THE + LF;

    switch(rs_opts.show_phase_sd) {
	case "rise":
	    header += TH12 + add_help("At Rise", "timePhase") + THE + LF;
	    break;
	case "transit":
	    header += TH12 + add_help("At Transit", "timePhase") + THE + LF;
	    break;
	case "set":
	    header += TH12 + add_help("At Set", "timePhase") + THE + LF;
	    break;
	default:
	    break;
    }

    header += TRE + LF;

    header += TR + LF;

    // Sun
    header += TH11 + add_help("Rise", "timeRiseAzimuth") + THE + LF;
    header += TH11 + add_help("Set", "timeSetAzimuth") + THE + LF;

    // Moon
    header += TH11 + add_help("Rise", "timeRiseAzimuth") + THE + LF;
    header += TH11 + add_help("Set", "timeSetAzimuth") + THE + LF;
    header += TH11 + add_help("Phase", "timePhase",
			      "Fraction of Moon illuminated") + THE + LF;
    header += TH11 + add_help("SD", "timeSD", "Semidiameter") + THE + LF;
    header += TRE + LF;
    header += THDE + LF;
    header += TBD + LF;

    this.times_header = header;
}

function format_times(cdate, ctype, s, m, rs_opts, t_offset, loc, d)
{
    var
	alt_precis,		// precision for Sun/Moon maximum altitudes
	az_precis,		// precision for Sun/Moon rise/set azimuths
	cdate_time,
	dateStr,
	transit_dir,		// direction of transit: n or s
	t_diff,			// Moon event - Sun event time difference
	rpad_d,			// right padding for Dawn time string
	rpad_t,			// right padding for Transit time string
	NO_EVENT = MDASH,	// event does not occur [em dash]
	line = "";		// table row

    alt_precis = 0;
    az_precis  = 1;

    // optimize alignment when column header is wider than data
    if (flags.show_am_pm_time === true && flags.show_ut === false)
	rpad_d = 0;	// appended 'a' or 'p' covers it
    else if (flags.show_ut === true) {
	rpad_d = 0;	// appended PLUS, MINUS, or SP2 covers it
	rpad_t = 0;
    }
    else {
	rpad_d = 1;
	rpad_t = 1;
    }

    line += TR_R + LF;
    line += TD_L + cdate.getLocDayName(loc) + TDE + LF;

    // left pad day of month so dates align
    if (ctype == TIMES)
	line += TD_L
	     + add_date_link(cdate.toLocDateStr(0), cdate.toLocDateStr(1),
			     cdate.getTime().MsecToDay());
    else
	line += TD_L + cdate.toLocDateStr(1);

    if (flags.show_ut === true)
	line += " (UT)";
    else if (cdate.getDayDST(loc) === true)
	line += "*";
    line += TDE + LF;

	// Sun events
    if (flags.show_all_twilight === true) {
	line += s.adawn.showEventTime(cdate, loc, "T", rpad_d) + LF;
	line += s.ndawn.showEventTime(cdate, loc, "T", rpad_d) + LF;
    }
    line += s.dawn.showEventTime(cdate, loc, "T", rpad_d) + LF;
    line += s.rise.showEventTime(cdate, loc, "", 0) + LF;
    line += s.transit.showEventTime(cdate, loc, "", rpad_t) + LF;
    line += s.set.showEventTime(cdate, loc, "", 0) + LF;
    line += s.dusk.showEventTime(cdate, loc, "T", 0) + LF;
    if (flags.show_all_twilight === true) {
	line += s.ndusk.showEventTime(cdate, loc, "T", 0) + LF;
	line += s.adusk.showEventTime(cdate, loc, "T", 0) + LF;
    }

	// length of day
    if (s.day.testEvent() === true)
	line += TD + (s.day).toDMS() + SP2 + TDE + LF;
    else
	line += TD_C + NO_EVENT + TDE + LF;

	// Sun rise/set azimuths
    if (s.az_rise === null)
	line += TD_C + NO_EVENT + TDE + LF;
    else
	line += TD + s.az_rise.toFixed(az_precis) + SP + TDE + LF;
    if (s.az_set === null)
	line += TD_C + NO_EVENT + TDE + LF;
    else
	line += TD + s.az_set.toFixed(az_precis) + TDE + LF;

	// Sun maximum altitude
    if (s.transit.testEvent() === false)
	line += TD_C + NO_EVENT + TDE + LF;
    else {
	// show direction of transit for abs(latitude) < 30
	if (Math.abs(loc.latitude) < 30) {
	    if (s.decl_trans.RtoD() < loc.latitude)
		transit_dir = " s";
	    else
		transit_dir = " n";
	    line += s.maxalt.showMaxAlt(alt_precis, transit_dir) + LF;
	}
	else
	    line += s.maxalt.showMaxAlt(alt_precis) + LF;
    }

	// Moon events
    line += m.rise.showEventTime(cdate, loc, "", 0) + LF;
    line += m.transit.showEventTime(cdate, loc, "", rpad_t) + LF;
    line += m.set.showEventTime(cdate, loc, "", 0) + LF;

    // Moon event - Sun event time difference
    if (rs_opts.show_tdiff == "rise") {
	if (m.az_rise === null)
	    line += TD_C + NO_EVENT + TDE + LF;
	else {
	    if (rs_opts.tdiff_mr_type == "sunset")
		t_diff = m.rise - s.set;
	    else
		t_diff = m.rise - s.rise;

	    if (t_diff < 0)
		line += TD + MINUS + (-t_diff).toDMS() + TDE + LF;
	    else
		line += TD + t_diff.toDMS() + TDE + LF;
	}
    }
    else if (rs_opts.show_tdiff == "set") {
	if (m.az_set === null)
	    line += TD_C + NO_EVENT + TDE + LF;
	else {
	    if (rs_opts.tdiff_ms_type == "sunset")
		t_diff = m.set - s.set;
	    else
		t_diff = m.set - s.rise;

	    if (t_diff < 0)
		line += TD + MINUS + (-t_diff).toDMS() + TDE + LF;
	    else
		line += TD + t_diff.toDMS() + TDE + LF;
	}
    }

	// Moon rise/set azimuths
    if (m.az_rise === null)
	line += TD_C + NO_EVENT + TDE + LF;
    else
	line += TD + m.az_rise.toFixed(az_precis) + SP + TDE + LF;
    if (m.az_set === null)
	line += TD_C + NO_EVENT + TDE + LF;
    else
	line += TD + m.az_set.toFixed(az_precis) + TDE + LF;

	// Moon maximum altitude
    if (m.transit.testEvent() === false)
	line += TD_C + NO_EVENT + TDE + LF;
    else {
	// show direction of transit for abs(latitude) < 30
	if (Math.abs(loc.latitude) < 30) {
	    if (m.decl_trans.RtoD() < loc.latitude)
		transit_dir = " s";
	    else
		transit_dir = " n";
	    line += m.maxalt.showMaxAlt(alt_precis, transit_dir) + LF;
	}
	else
	    line += m.maxalt.showMaxAlt(alt_precis) + LF;
    }

    // Moon phase and semidiameter
    switch(rs_opts.show_phase_sd) {
	case "rise":
	    if (m.az_rise === null) {
		line += TD_C + NO_EVENT + TDE + LF;	// phase
		line += TD_C + NO_EVENT + TDE + LF;	// semidiameter
	    }
	    else {
		// phase
		line += TD_L + m.phase_r.toFixed(3);
		// indicate waxing or waning if phase criteria have been
		// given or if flag to always show is set
		if (rs_opts.phase_check === true ||
		  flags.always_show_wax_wane === true)
		    line += (m.waxing_r === true ? WAXING : WANING);
		line += TDE + LF;

		// semidiameter
		line += TD + m.sd_r.toFixed(3) + TDE + LF;
	    }
	    break;
	case "transit":
	    if (m.transit.testEvent() === false) {
		line += TD_C + NO_EVENT + TDE + LF;	// phase
		line += TD_C + NO_EVENT + TDE + LF;	// semidiameter
	    }
	    else {
		// phase
		line += TD_L + m.phase_t.toFixed(3);
		// indicate waxing or waning if phase criteria have been
		// given or if flag to always show is set
		if (rs_opts.phase_check === true ||
		  flags.always_show_wax_wane === true)
		    line += (m.waxing_t === true ? WAXING : WANING);
		line += TDE + LF;

		// semidiameter
		line += TD + m.sd_t.toFixed(3) + TDE + LF;
	    }
	    break;
	case "set":
	    if (m.az_set === null) {
		line += TD_C + NO_EVENT + TDE + LF;	// phase
		line += TD_C + NO_EVENT + TDE + LF;	// semidiameter
	    }
	    else {
		// phase
		line += TD_L + m.phase_s.toFixed(3);
		// indicate waxing or waning if phase criteria have been
		// given or if flag to always show is set
		if (rs_opts.phase_check === true ||
		  flags.always_show_wax_wane === true)
		    line += (m.waxing_s === true ? WAXING : WANING);
		line += TDE + LF;

		// semidiameter
		line += TD + m.sd_s.toFixed(3) + TDE + LF;
	    }
	    break;
	default:
	    break;
    }

    line += TRE + LF;

    return line;
}

// ***************** output database locations ********************************

function build_places_doc_head()
{

    var PLACES_STYLE = '<style>' + LF;

    if (flags.show_mag_dec === true && flags.show_dst_rules === true && flags.show_dst_dates === true)
	// use minimal left margin; eliminate right margin
	PLACES_STYLE += PAD4 + 'body { margin-left: 1%; margin-right: 0; }' + LF;

    // add error color
    PLACES_STYLE += PAD4 + 'td.error { background-color: yellow; }' + LF
		 + '-->' + LF
		 + '</style>' + LF;
    var header;

    // document header
    header  = "<head>" + LF;
    header += CONTENT + LF;
    header += "<title>Sun/Moon Calculator Locations</title>" + LF;

    header += SCRIPT;
    header += STYLE;
    header += PLACES_STYLE;
    // specify fixed font size
    if (flags.print === true && flags.use_font_size === true)
	header += PRINT_STYLE;

    header += "</head>" + LF;

    this.doc_head = header;
}

// document and table header for places in database
function build_places_header(year, date)
{
    var elev_units, header;

    if (flags.elevation_in_feet === true)
	elev_units = "ft";
    else
	elev_units = "m";

    header = "";
    header += "Sun/Moon Calculator Locations".big().bold() + VSPACE + LF;

    if (flags.show_mag_dec === true) {
	var mag_date = new Date();

	mag_date.setTime(date.DayToMsec());

	header += SP + "Magnetic declinations on " + mag_date.toLocDateStr(0);
	if (date < mag_model.start_date - MagModel.GRACE ||
	   date > mag_model.end_date + MagModel.GRACE)
	    header += SP2 + "(Caution: outside magnetic model range of "
		   + mag_model.valid_range_str + ")";
	header += VSPACE + LF;
    }

    this.page_top = header;

    // table header
    header = PLACES_TABLE;
    header += PLACES_TABLE_COLSPEC1;

    if (flags.show_dst_rules === true)
	header += PLACES_TABLE_COLSPEC2;

    if (flags.show_dst_dates === true)
	header += PLACES_TABLE_COLSPEC2;

    header += THD + LF;
    header += TR + LF;

    if (flags.show_dst_rules === true || flags.show_dst_dates === true) {
	header += TH21 + "Name" + THE + LF;
	header += TH21 + "Latitude" + THE + LF;
	header += TH21 + "Longitude" + THE + LF;
	header += TH21 + "Elevation," + BR + elev_units + THE + LF;
	if (flags.show_mag_dec === true)
	    header += TH21 + "Magnetic" + BR + "Declination" + THE + LF;
    }
    else {
	header += TH11 + "Name" + THE + LF;
	header += TH11 + "Latitude" + THE + LF;
	header += TH11 + "Longitude" + THE + LF;
	header += TH11 + "Elevation," + BR + elev_units + THE + LF;
	if (flags.show_mag_dec === true)
	    header += TH11 + "Magnetic" + BR + "Declination" + THE + LF;
    }

    // put Time Zone heading on two lines if everything is output
    if (flags.show_mag_dec === true && flags.show_dst_rules === true && flags.show_dst_dates === true)
	header += TH21 + "Time" + BR + "Zone" + THE + LF;
    else if (flags.show_dst_rules === true || flags.show_dst_dates === true)
	header += TH21 + "Time Zone" + THE + LF;
    else
	header += TH11 + "Time Zone" + THE + LF;

    if (flags.show_dst_rules === true)
	header += TH12 + "DST Rule for " + year + THE + LF;

    if (flags.show_dst_dates === true)
	header += TH12 + "DST Dates for " + year + THE + LF;

    if (flags.show_dst_rules === true || flags.show_dst_dates === true) {
	header += TRE + LF;
	header += TR + LF;
    }

    if (flags.show_dst_rules === true) {
	header += TH11 + "Start" + THE + LF;
	header += TH11 + "End" + THE + LF;
    }
    if (flags.show_dst_dates === true) {
	header += TH11 + "Start" + THE + LF;
	header += TH11 + "End" + THE + LF;
    }

    header += TRE + LF;
    header += THDE + LF;

    this.places_header = header;
}

// show properties for all places in the database
function build_place_list(year, date)
{
    var
	ERRMSG = "*** Missing DST rule ***",
	NO_DST_MSG = "DST not observed",
	TD_ERRMSG,
	TD_L_ERR = PAD8 + '<td class="error" align="left">',
	TD_MSG,
	TD_NAME;
    var
	errors = 0,
	line,
	ndx,
	i = 0,		// index of place_list[] array
	msg_wid = 0;
    var
	loc = new Place();

    if (flags.show_dst_rules === true)
	msg_wid++;
    if (flags.show_dst_dates === true)
	msg_wid++;

    switch (msg_wid) {
	case 1:
	    TD_MSG = TD12;
	    TD_ERRMSG = PAD8 + '<td class="error" colspan="2" align="center">';
	    break;
	case 2:
	    TD_MSG = TD14;
	    TD_ERRMSG = PAD8 + '<td class="error" colspan="4" align="center">';
	    break;
	default:
	    break;
    }

    place_list.length = 0;

    for (ndx = 0; places[ndx]; ndx++) {
	loc.Init(places[ndx]);

	TD_NAME = TD_L;		// for output with no DST errors

	name = add_place_link(loc.name.replace(/'/g, "&rsquo;"), ndx);

	line = TD_L + SP;
	if (loc.latitude < 0)
	    line += (-loc.latitude).toDMSLeftPadded(2) + SP + 'S';
	else
	    line += (loc.latitude).toDMSLeftPadded(2) + SP + 'N';
	line += TDE + LF;

	line += TD_L + SP;
	if (loc.longitude < 0)
	    line += (-loc.longitude).toDMSLeftPadded(3) + SP + 'W';
	else
	    line += (loc.longitude).toDMSLeftPadded(3) + SP + 'E';
	line += TDE + LF;

	if (flags.elevation_in_feet === true)
	    loc.elevation = loc.elevation.MtoFT();
	if (loc.elevation < 0)
	    line += TD_R + SP + MINUS + (-loc.elevation).toFixed(0) + SP;
	else if (loc.elevation > 0)
	    line += TD_R + SP + (loc.elevation).toFixed(0) + SP;
	else
	    line += TD_R + MDASH + SP2;
	line += TDE + LF;

	if (flags.show_mag_dec === true) {
	    line += TD_L + SP2;

	    loc.mag_dec = mag_model.calcMagDec(loc, date);
	    if (loc.mag_dec < 0)
		line += (-loc.mag_dec).toFixedLeftPadded(1, 3) + ' W';
	    else
		line += loc.mag_dec.toFixedLeftPadded(1, 3) + ' E';
	    line += TDE + LF;
	}

	line += TD_L + SP;
	if (loc.timezone < 0)
	    line += 'UTC' + MINUS + (-loc.timezone);
	else
	    line += 'UTC' + PLUS + loc.timezone;

	if (! (flags.show_dst_rules === true && flags.show_dst_dates === true)) {
	    var time_zone;
	    if ((time_zone = loc.getTimezone()))
		line += " (" + time_zone + ")";
	}

	line += TDE + LF;

	// daylight saving time rules--don't bother checking if they aren't displayed
	if (flags.show_dst_rules === true || flags.show_dst_dates === true) {
	    if (loc.uses_dst === true) {
		var
		    start_month,
		    start_day,
		    start_week,
		    start_DoW,
		    end_month,
		    end_day,
		    end_week,
		    end_DoW;

		if (loc.getDSTLimits(year) === false) {
		    name = name.bold();
		    TD_NAME = TD_L_ERR;
		    line += TD_ERRMSG +  ERRMSG.bold() + TDE + LF;
		}
		// no DST specified in DST rule
		else if (loc.dst_start === null || loc.dst_end === null)
			line += TD_MSG + NO_DST_MSG + TDE + LF;
		else {
		    if (flags.show_dst_rules === true) {
			line += TD_L + SP + showDSTRule(loc.DSTStartStr) + TDE + LF;
			line += TD_L + SP + showDSTRule(loc.DSTEndStr) + TDE + LF;
		    }
		    if (flags.show_dst_dates === true) {
			line += TD_L + SP + showDSTDate(loc.DSTStartStr, year) + TDE + LF;
			line += TD_L + SP + showDSTDate(loc.DSTEndStr, year) + TDE + LF;
		    }
		}
	    }
	    else
		// no DST specified in location database
		line += TD_MSG + NO_DST_MSG + TDE + LF;
	}

	name = TD_NAME + name + TDE + LF;
	line = TR + LF + name + line + TRE + LF;

	this.places[i++] = line;
    }
}

// output list of database locations
function output_places()
{
    var d, handle, places;

    // build the top of page
    this.doc_body = '<body>' + LF;
    this.doc_body += this.page_top;
    this.doc_body += this.places_header;

    // add the places
    this.doc_body += this.places.join(LF) + TABLE_END + LF;
    this.doc_body += BR + SP2 + this.copyright + LF;

    if (this.prog_time)
	this.doc_body += this.prog_time + BR + LF;

    if (this.buttons)
	this.doc_body += this.buttons;

    this.doc_body += LF + '</body>';

    places  = DOC_START + this.doc_head + this.doc_body + DOC_END;

    // create the document
    handle = begin_document(this.name);
    d = handle.document;

    // output the document
    //write_db(places);		// show the code
    d.write(places);
    d.close();

    handle.focus();

    if (handle.print && flags.print === true)
	handle.print();
}

// reformat times or positions results or location list for printing:
// remove Close/Print/Help buttons from bottom of page
function reformat_results(type)
{
    var title;

    flags.print = true;
    if (flags.use_font_size === true)
	set_font_size();

    if (type == "positions") {
	results = positions_results;
	title = "Positions";
    }
    else {
	results = times_results;
	title = "Times";
    }

    title += " (print)";

    results.build_doc_head(title);
    results.add_buttons();

    results.output();

    flags.print = false;
}
// *************** Result object ***************************

function Result(type)
{
    this.type = type;
    this.doc_head = null;
    this.page_top = null;
    this.times_header = null;
    this.times = new Array();
    this.positions_header = null;
    this.positions = new Array();
}

Result.prototype.calculate_times = calculate_times;
Result.prototype.calculate_positions = calculate_positions;
Result.prototype.build_doc_head = build_results_doc_head;
Result.prototype.build_page_top = build_page_top;
Result.prototype.add_rs_criteria = add_rs_criteria;
Result.prototype.build_times_header = build_times_header;
Result.prototype.build_positions_header = build_positions_header;
Result.prototype.add_buttons = add_buttons;
Result.prototype.output = output_results;

// **************** PlaceList object ***********************

function PlaceList()
{
    this.type = "places";
    this.doc_head = null;
    this.page_top = null;
    this.places_header = null;
    this.places = new Array();
}

PlaceList.prototype.build_doc_head = build_places_doc_head;
PlaceList.prototype.build_places_header = build_places_header;
PlaceList.prototype.build_place_list = build_place_list;
PlaceList.prototype.add_buttons = add_buttons;
PlaceList.prototype.output = output_places;

// ************** misc formatting functions *********************

// format a Sun/Moon event time
Number.prototype.showEventTime = function(cdate, loc, type, r_pad)
{
    var
	NO_EVENT = MDASH,	// event does not occur [em dash]
	ABOVE = "****",		// circumpolar; never sets
	BELOW = "-----",	// circumpolar; never rises
	LIGHT = "/////",	// twilight never ends
	DARK  = "===";		// twilight never begins

    var column = null;

    if (type == "T") {		// twilight
	if (this <= -F_CIRCUMPOLAR)
	    column = DARK;
	else if (this >= F_CIRCUMPOLAR)
	    column = LIGHT;
	else if (this > F_TEST_NO_EVENT)
	    column = NO_EVENT;
    }
    else {			// rise/set
	if (this <= -F_CIRCUMPOLAR)
	    column = BELOW;
	else if (this >= F_CIRCUMPOLAR)
	    column = ABOVE;
	else if (this > F_TEST_NO_EVENT)
	    column = NO_EVENT;
    }

    if (column)
	return TD_C + column + TDE;

    var
	date = new Date(),
	time = this,
	ut_offset;

    date.setTime(cdate.getTime() + time.HtoMsec());
    ut_offset = loc.getTimeOffset(date);

    if (flags.show_ut === false) {
	time += ut_offset;

	if (time < 0 || time > 24)
	    column = NO_EVENT;
    }

    if (column)
	return TD_C + column + TDE;

    // times outside 0-24 happen only when showing UT
    if (time < 0)		// previous day
	column = (time + 24).formatTime("T") + MINUS;
    else if (time > 24)	// next day
	column = (time - 24).formatTime("T") + PLUS;
    else {
	column = time.formatTime("T");
	if (flags.show_ut === true)
	    column += SP2;	// align (approximately) with appended PLUS or MINUS
    }

    while (r_pad-- > 0)
	column += SP;

    return TD + column + TDE;
};

// format a Sun/Moon position time
Number.prototype.showPosTime = function(date, loc)
{
    var
	time = this,
	timeStr, 
	ut_offset = loc.getTimeOffset(date);

    if (flags.show_ut === false)
	time = this + ut_offset;

    if (time < 0)			// previous day
	timeStr = (time + 24).formatTime("P") + MINUS;
    else if (time >= 24) {		// next day
	while (time >= 24)
	    time -= 24;
	timeStr = (time).formatTime("P") + PLUS;
    }
    else {
	timeStr = time.formatTime("P");
	if (flags.show_ut === true || flags.next_day === true)
	    timeStr += SP2;	// align (approximately) with appended PLUS or MINUS
    }

    return timeStr;
};

// format Sun/Moon maximum altitude
Number.prototype.showMaxAlt = function(precis, hemisphere)
{
    var column;

    if (this < -9.5)
	//column = MINUS + -Math.round(this);
	column = MINUS + (-this).toFixed(precis);
    else if (this < 0)
	column = MINUS + (-this).toFixed(1);
    else if (this < 9.5)
	column = this.toFixed(1);
    else
	//column = Math.round(this);
	column = this.toFixed(precis);
    if (arguments.length > 1)
	column += hemisphere;
    
    return TD + column + SP + TDE;
};

Number.prototype.showMinMaxAlt = function(precis)
{
    var column;

    if (this < -9.5)
	//column = MINUS + -Math.round(this);
	column = MINUS + (-this).toFixed(precis);
    else if (this < 0)
	column = MINUS + (-this).toFixed(1);
    else if (this < 9.5)
	column = this.toFixed(1);
    else
	//column = Math.round(this);
	column = this.toFixed(precis);
    
    return column;
};

  </script>
<script type="text/javascript" src="http://www.largeformatphotography.info/sunmooncalc/SMCalcDSTRules.js"></script>

<style>
    body {
	    margin-left: 5%;
	    margin-right: 5%;
	    color: #000040;
	    background-color: #f4f4f4;
    }
    form a.help { cursor: help; }
    form a.help:link, a.help:visited { text-decoration: none; color: #000040; }

    form h1 { font-size: 150%; color: navy; }
    form h2 {
	    font-size: 110%; color: navy;
	    margin-top: 1.5ex; margin-bottom: 0.2ex; white-space: nowrap;
    }
    form h3 { color: navy; margin-top: 1.5ex; margin-bottom: 0.2ex; }
    form h4 { color: black; margin-top: 1.5ex; margin-bottom: 0.2ex; }

    form input.LocSearch  { width: 17em; padding-left: 0.1em; }
    form input.LocName    { width: 17em; padding-left: 0.1em; }
    form input.LatLon     { width: 5.5em; padding-right: 0.1em; text-align: right; }
    form input.elevation  { width: 4em; padding-right: 0.1em; text-align: right; }
    form input.height     { width: 4em; padding-right: 0.1em; text-align: right; }
    form input.DateYear   { width: 2.5em; text-align: center; }
    form input.DateOffset { width: 3em; padding-right: 0.1em; text-align: right; }
    form input.DateStep   { width: 3em; padding-right: 0.1em; text-align: right; }
    form input.TimeSpec   { width: 3em; text-align: center; }
    form input.TimeOffset { width: 2.6em; padding-right: 0.1em; text-align: right; }

    form table {
	    border-collapse: separate; border-spacing: 0;
	    border: 1px solid #777;
	    background-color: #fff; }

    form td {
	    white-space: nowrap;
	    padding: 1px; padding-left: 0; padding-right: 3px;
    }
    form td.x { border: 1px solid red; }	/* remove '.x' to debug layout */
    form td.left  { padding-left: 0.5em; }	/* left-side padding */
    form td.right { padding-right: 0.5em; }	/* right-side padding */
    form td.right4 { padding-right: 4em; }	/* 4-em right-side padding */
    form td.both { padding-left: 0.5em; padding-right: 0.5em; }	/* padding  both sides */
    form tr.pad { height: 6px; font-size: 0; }	/* top and bottom padding */
    form td.pad { border-left: 1px solid #777; border-right: 1px solid #777; }

    form .topMenu {
	text-align: right; vertical-align: top;
	margin-left: 28em;
	font-family: Arial,Helvetica,sans-serif;
	font-weight: normal;
	font-style: normal;
	font-size: 85%;
    }

    /* for showing multiple results from GeoNames queries */
    form span.selectListAnchor { position: relative; z-index: 11; }
    form span.selectList { position: absolute; top: 1.1em; left: -4.8em; z-index:13;
	visibility: hidden
    }

    #selectListElement {
	    background-color: #fff; border: 1px solid #777; text-align: left;
	    white-space: nowrap; visibility: hidden;
    }
    .selectListTD { border: 1px solid #777; padding-left: 0.2em; padding-right: 0.2em; }
    .selectListTR { background-color: #fff; border-collapse: collapse;  }
    .selectListMouseOver { background-color: navy; color: white; cursor: pointer; }

    /* top-of-page buttons */
    a.SMCalcTop {
	padding: 3px;
	padding-left: 6px;
	padding-right: 6px;
	background-color: #f4f4f4;
	border: 1px solid #f4f4f4;
	cursor: pointer;
    }
    a.SMCalcTopMouseOver {
	padding: 3px;
	padding-left: 6px;
	padding-right: 6px;
	background-color: #fff;
	border: 1px solid #aaa;
	cursor: pointer;
    }
    a.SMCalcTopMouseDown {
	padding: 3px;
	padding-left: 6px;
	padding-right: 6px;
	background-color: #fff;
	border: 1px dotted #aaa;
	cursor: pointer;
    }
    /* reverts to .SMCalcTopMouseOver on mouse up */
    /* reverts to .SMCalcTop on mouse out */

</style>

</head>

<body onload='initialize_form()'>
				   <!-- prevent submit on Enter -->
<form name="SunMoonCalc" action="NoAction" onsubmit="return false">
    <span class="topMenu">
		       <!--
		       style="padding: 3px; border: 1px solid #f4f4f4"
		       -->
    <a class="SMCalcTop"
       title="Open User Preferences dialog" id="PrefLink"
       onmouseover='onSMCalcTopMouseOver(this.id)'
       onmouseout='onSMCalcTopMouseOut(this.id)'
       onmousedown='onSMCalcTopMouseDown(this.id)'
       onmouseup='onSMCalcTopMouseUp(this.id)'
       onclick='blur(); get_preferences()'>Preferences</a>&emsp;
    <a class="SMCalcTop"
       title="Open Sun/Moon Calculator Reference" id="HelpLink"
       onmouseover='onSMCalcTopMouseOver(this.id)'
       onmouseout='onSMCalcTopMouseOut(this.id)'
       onmousedown='onSMCalcTopMouseDown(this.id)'
       onmouseup='onSMCalcTopMouseUp(this.id)'
       onclick='blur(); help()'>Help</a>&emsp;
    <a class="SMCalcTop"
       title="Open Sun/Moon Calculator tutorial" id="TutorialLink"
       onmouseover='onSMCalcTopMouseOver(this.id)'
       onmouseout='onSMCalcTopMouseOut(this.id)'
       onmousedown='onSMCalcTopMouseDown(this.id)'
       onmouseup='onSMCalcTopMouseUp(this.id)'
       onclick='blur(); open_tutorial()'>Tutorial</a>
    </span>

    <h1 style="margin-top: 0;">
	<a class="help" title="The Sun/Moon Calculator &copy; 1998&ndash;2015 Jeff Conrad"
	   onclick="blur(); help('Legal'); return false;">The Sun/Moon Calculator</a>
    </h1>

    <input type=hidden name="status" value=0>

    <!--************** store values for User Preferences form *************-->

    <input type="hidden" name="SepTimePosWindows" value="false" >
    <input type="hidden" name="SepAllTimePosWindows" value="false" >
    <input type="hidden" name="UsePopups" value="false" >
    <input type="hidden" name="UseAllTabs" value="false" >

    <input type="hidden" name="ShowSearch" value="true" >
    <input type="hidden" name="UseREs" value="false" >

    <input type="hidden" name="ShowMagDec" value="false" >
    <input type="hidden" name="ShowDSTRules" value="false" >
    <input type="hidden" name="ShowDSTDates" value="false" >

    <input type="hidden" name="ShowDST" value="true" >
    <input type="hidden" name="ShowAMPMTime" value="false" >
    <input type="hidden" name="ShowUT" value="false" >
    <input type="hidden" name="ShowMagNorth" value="false" >
    <input type="hidden" name="ElevationInFeet" value="true" >

    <input type="hidden" name="ShowAllTwilight" value="false" >

    <!-- primarily for debugging; hidden on User Preferences form -->
    <input type="hidden" name="InterpolateRSPositions" value="true" >
    <input type="hidden" name="RSShowMoonSD" value="false" >

    <!-- adjust Moon-Sun event time-difference limits for azimuth -->
    <input type="hidden" name="AdjustTimeLimitsAz" value="true" >

    <input type="hidden" name="AlwaysShowWaxWane" value="false" >
    <input type="hidden" name="ShowTdiffAllSearches" value="false" >

    <input type="hidden" name="EnableInactiveInputs" value="false" >
    <input type="hidden" name="ShowCopyDates" value="false" >
    <input type="hidden" name="ShowCheckPlaces" value="false" >
    <input type="hidden" name="ShowAzAdjust" value="false" >
    <input type="hidden" name="TimeProgram" value="false" >
    <input type="hidden" name="UseFontSize" value="false" >
    <input type="hidden" name="FontSize" value="10" >

    <!--**** store values for Rise/Set Criteria form  ********-->

    <input type="hidden" name="RSCriteria" value="0">

    <input type="hidden" name="Sunrise" value="false">
    <input type="hidden" name="SunriseAltRange" value="false">
    <input type="hidden" name="SunriseAltMin" value="0">
    <input type="hidden" name="SunriseAltMax" value="0">
    <input type="hidden" name="SunriseAltType" value="top">

    <input type="hidden" name="SunriseAzRange" value="false">
    <input type="hidden" name="SunriseAzMin" value="0">
    <input type="hidden" name="SunriseAzMax" value="180">

    <input type="hidden" name="Sunset" value="false">
    <input type="hidden" name="SunsetAltRange" value="false">
    <input type="hidden" name="SunsetAltMin" value="0">
    <input type="hidden" name="SunsetAltMax" value="0">
    <input type="hidden" name="SunsetAltType" value="top">

    <input type="hidden" name="SunsetAzRange" value="false">
    <input type="hidden" name="SunsetAzMin" value="180">
    <input type="hidden" name="SunsetAzMax" value="360">

    <!-- moonrise -->
    <input type="hidden" name="Moonrise" value="false">
    <input type="hidden" name="MoonriseAltRange" value="false">
    <input type="hidden" name="MoonriseAltMin" value="0">
    <input type="hidden" name="MoonriseAltMax" value="0">
    <input type="hidden" name="MoonriseAltType" value="top">

    <input type="hidden" name="MoonriseAzRange" value="false">
    <input type="hidden" name="MoonriseAzMin" value="0">
    <input type="hidden" name="MoonriseAzMax" value="180">

    <input type="hidden" name="MoonrisePhaseRange" value="false">
    <input type="hidden" name="MoonrisePhaseMin" value="0">
    <input type="hidden" name="MoonrisePhaseMax" value="1">
    <input type="hidden" name="MoonrisePhaseWaxing" value="false">
    <input type="hidden" name="MoonrisePhaseWaning" value="false">

    <input type="hidden" name="MoonriseSDRange" value="false">
    <input type="hidden" name="MoonriseSDMin" value="0.245">
    <input type="hidden" name="MoonriseSDMax" value="0.284">

    <input type="hidden" name="MoonriseTdiff" value="false">
    <input type="hidden" name="MoonriseTdiffMin" value="-15">
    <input type="hidden" name="MoonriseTdiffMax" value="10">
    <input type="hidden" name="MoonriseTdiffType" value="sunset">

    <!-- moonset -->
    <input type="hidden" name="Moonset" value="false">
    <input type="hidden" name="MoonsetAltRange" value="false">
    <input type="hidden" name="MoonsetAltMin" value="0">
    <input type="hidden" name="MoonsetAltMax" value="0">
    <input type="hidden" name="MoonsetAltType" value="top">

    <input type="hidden" name="MoonsetAzRange" value="false">
    <input type="hidden" name="MoonsetAzMin" value="180">
    <input type="hidden" name="MoonsetAzMax" value="360">

    <input type="hidden" name="MoonsetPhaseRange" value="false">
    <input type="hidden" name="MoonsetPhaseMin" value="0">
    <input type="hidden" name="MoonsetPhaseMax" value="1">
    <input type="hidden" name="MoonsetPhaseWaxing" value="false">
    <input type="hidden" name="MoonsetPhaseWaning" value="false">

    <input type="hidden" name="MoonsetSDRange" value="false">
    <input type="hidden" name="MoonsetSDMin" value="0.245">
    <input type="hidden" name="MoonsetSDMax" value="0.284">

    <input type="hidden" name="MoonsetTdiff" value="false">
    <input type="hidden" name="MoonsetTdiffMin" value="-10">
    <input type="hidden" name="MoonsetTdiffMax" value="15">
    <input type="hidden" name="MoonsetTdiffType" value="sunrise">

    <!--**************** location ******************************-->
    <h2><a class="help" title="Select location or specify properties"
	   onclick="blur(); help('Location'); return false;">
	&nbsp;Location</a></h2>

    <table>
    <tbody id="stdLocTxt0">
    <tr id="stdLocTxt00" class="pad"><td colspan="4">&nbsp;</td></tr>
    <tr>
	<!-- ================ location in database ===================== -->
	<td id="stdLocTxt01" class="left"><input type=radio name="loc_type" id="stdLocType"
		    checked value="city"
		    onclick='setLocTypeAttrib(); SaveState.write(form); blur()'></td>
	<!-- Place -->
	<td class="right" colspan="3"><span id="stdLocTxt02"><a class=help
	    title="Select a location from the built-in database"
	    onclick="blur(); help('Location'); return false;" >
	    Select:</a></span>&nbsp;
	    <select name="place"
		    id="stdLocPlace"
		    onchange='SaveState.write(form)' >
		    <optgroup label="United States">
			<option>Anchorage, AK</option>
			<option>Barrow, AK</option>
			<option>Bethel, AK</option>
			<option>Cordova, AK</option>
			<option>Craig, AK</option>
			<option>Dillingham, AK</option>
			<option>Diomede, AK</option>
			<option>Fairbanks, AK</option>
			<option>Homer, AK</option>
			<option>Hooper Bay, AK</option>
			<option>Juneau, AK</option>
			<option>Ketchikan, AK</option>
			<option>Kodiak, AK</option>
			<option>Navy Town, AK</option>
			<option>Nome, AK</option>
			<option>Seward, AK</option>
			<option>Sitka, AK</option>
			<option>Skagway, AK</option>
			<option>Unalaska, AK</option>
			<option>Wrangell, AK</option>
			<option>Auburn, AL</option>
			<option>Birmingham, AL</option>
			<option>Dothan, AL</option>
			<option>Gadsden, AL</option>
			<option>Huntsville, AL</option>
			<option>Livingston, AL</option>
			<option>Mobile, AL</option>
			<option>Montgomery, AL</option>
			<option>Selma, AL</option>
			<option>Tuscaloosa, AL</option>
			<option>Blytheville, AR</option>
			<option>Brinkley, AR</option>
			<option>Clinton, AR</option>
			<option>El Dorado, AR</option>
			<option>Fayetteville, AR</option>
			<option>Fort Smith, AR</option>
			<option>Jonesboro, AR</option>
			<option>Little Rock, AR</option>
			<option>Mountain Home, AR</option>
			<option>Russellville, AR</option>
			<option>Texarkana, AR</option>
			<option>Pago Pago, AS</option>
			<option>Ajo, AZ</option>
			<option>Flagstaff, AZ</option>
			<option>Holbrook, AZ</option>
			<option>Kayenta, AZ</option>
			<option>Kingman, AZ</option>
			<option>Nogales, AZ</option>
			<option>Page, AZ</option>
			<option>Phoenix, AZ</option>
			<option>Sedona, AZ</option>
			<option>Springerville, AZ</option>
			<option>Tucson, AZ</option>
			<option>Willcox, AZ</option>
			<option>Yuma, AZ</option>
			<option>Alturas, CA</option>
			<option>Baker, CA</option>
			<option>Bakersfield, CA</option>
			<option>Barstow, CA</option>
			<option>Bishop, CA</option>
			<option>Blythe, CA</option>
			<option>Borrego Springs, CA</option>
			<option>Crescent City, CA</option>
			<option>Eureka, CA</option>
			<option>Fort Bragg, CA</option>
			<option>Fresno, CA</option>
			<option>Gorman, CA</option>
			<option>Lee Vining, CA</option>
			<option>Lone Pine, CA</option>
			<option>Los Angeles, CA</option>
			<option>Los Osos, CA</option>
			<option>Mojave, CA</option>
			<option>Monterey, CA</option>
			<option>Mount Shasta, CA</option>
			<option>Needles, CA</option>
			<option>Nevada City, CA</option>
			<option>Orick, CA</option>
			<option>Quincy, CA</option>
			<option>Redding, CA</option>
			<option>Sacramento, CA</option>
			<option>San Diego, CA</option>
			<option selected>San Francisco, CA</option>
			<option>San Luis Obispo, CA</option>
			<option>Santa Barbara, CA</option>
			<option>Santa Rosa, CA</option>
			<option>Susanville, CA</option>
			<option>Truckee, CA</option>
			<option>Twentynine Palms, CA</option>
			<option>Yreka, CA</option>
			<option>Aspen, CO</option>
			<option>Burlington, CO</option>
			<option>Colorado Springs, CO</option>
			<option>Craig, CO</option>
			<option>Denver, CO</option>
			<option>Durango, CO</option>
			<option>Fort Collins, CO</option>
			<option>Grand Junction, CO</option>
			<option>Lamar, CO</option>
			<option>Pueblo, CO</option>
			<option>Rifle, CO</option>
			<option>Steamboat Springs, CO</option>
			<option>Telluride, CO</option>
			<option>Trinidad, CO</option>
			<option>Bridgeport, CT</option>
			<option>Danbury, CT</option>
			<option>Hartford, CT</option>
			<option>New Haven, CT</option>
			<option>New London, CT</option>
			<option>Norwich, CT</option>
			<option>Putnam, CT</option>
			<option>Salisbury, CT</option>
			<option>Stamford, CT</option>
			<option>Waterbury, CT</option>
			<option>Washington, DC</option>
			<option>Bethany Beach, DE</option>
			<option>Dover, DE</option>
			<option>Laurel, DE</option>
			<option>Wilmington, DE</option>
			<option>Cape Coral, FL</option>
			<option>Daytona Beach, FL</option>
			<option>Fort Pierce, FL</option>
			<option>Gainesville, FL</option>
			<option>Jacksonville, FL</option>
			<option>Key West, FL</option>
			<option>Melbourne, FL</option>
			<option>Miami, FL</option>
			<option>Orlando, FL</option>
			<option>Pensacola, FL</option>
			<option>Tallahassee, FL</option>
			<option>Tampa, FL</option>
			<option>Athens, GA</option>
			<option>Atlanta, GA</option>
			<option>Bainbridge, GA</option>
			<option>Brunswick, GA</option>
			<option>Carrollton, GA</option>
			<option>Columbus, GA</option>
			<option>Dalton, GA</option>
			<option>Macon, GA</option>
			<option>Savannah, GA</option>
			<option>Valdosta, GA</option>
			<option>Hilo, HI</option>
			<option>Honolulu, HI</option>
			<option>Kahului, HI</option>
			<option>Kaunakakai, HI</option>
			<option>Lanai City, HI</option>
			<option>Burlington, IA</option>
			<option>Cedar Rapids, IA</option>
			<option>Davenport, IA</option>
			<option>Des Moines, IA</option>
			<option>Dubuque, IA</option>
			<option>Fort Dodge, IA</option>
			<option>Mason City, IA</option>
			<option>Sioux City, IA</option>
			<option>Spencer, IA</option>
			<option>Waterloo, IA</option>
			<option>Boise, ID</option>
			<option>Bonners Ferry, ID</option>
			<option>Coeur d'Alene, ID</option>
			<option>Dubois, ID</option>
			<option>Montpelier, ID</option>
			<option>Moscow, ID</option>
			<option>Mullan, ID</option>
			<option>New Meadows, ID</option>
			<option>Pocatello, ID</option>
			<option>Salmon, ID</option>
			<option>Sandpoint, ID</option>
			<option>Twin Falls, ID</option>
			<option>Carbondale, IL</option>
			<option>Champaign, IL</option>
			<option>Chicago, IL</option>
			<option>De Kalb, IL</option>
			<option>Decatur, IL</option>
			<option>Effingham, IL</option>
			<option>Galesburg, IL</option>
			<option>Peoria, IL</option>
			<option>Quincy, IL</option>
			<option>Rockford, IL</option>
			<option>Springfield, IL</option>
			<option>Evansville, IN</option>
			<option>Fort Wayne, IN</option>
			<option>Gary, IN</option>
			<option>Indianapolis, IN</option>
			<option>Kokomo, IN</option>
			<option>Lafayette, IN</option>
			<option>Muncie, IN</option>
			<option>Richmond, IN</option>
			<option>South Bend, IN</option>
			<option>Terre Haute, IN</option>
			<option>Belleville, KS</option>
			<option>Chanute, KS</option>
			<option>Dodge City, KS</option>
			<option>Emporia, KS</option>
			<option>Goodland, KS</option>
			<option>Hays, KS</option>
			<option>Hiawatha, KS</option>
			<option>Liberal, KS</option>
			<option>Manhattan, KS</option>
			<option>Oswego, KS</option>
			<option>Salina, KS</option>
			<option>Topeka, KS</option>
			<option>Wichita, KS</option>
			<option>Ashland, KY</option>
			<option>Bowling Green, KY</option>
			<option>Elizabethtown, KY</option>
			<option>Frankfort, KY</option>
			<option>Lexington, KY</option>
			<option>Louisville, KY</option>
			<option>Owensboro, KY</option>
			<option>Paducah, KY</option>
			<option>Pikeville, KY</option>
			<option>Richmond, KY</option>
			<option>Williamsburg, KY</option>
			<option>Alexandria, LA</option>
			<option>Baton Rouge, LA</option>
			<option>Lafayette, LA</option>
			<option>Lake Charles, LA</option>
			<option>Monroe, LA</option>
			<option>New Orleans, LA</option>
			<option>Opelousas, LA</option>
			<option>Ruston, LA</option>
			<option>Shreveport, LA</option>
			<option>Tallulah, LA</option>
			<option>Amherst, MA</option>
			<option>Barnstable, MA</option>
			<option>Boston, MA</option>
			<option>Falmouth, MA</option>
			<option>Gardner, MA</option>
			<option>Gloucester, MA</option>
			<option>Haverhill, MA</option>
			<option>Lowell, MA</option>
			<option>Nantucket, MA</option>
			<option>New Bedford, MA</option>
			<option>Pittsfield, MA</option>
			<option>Plymouth, MA</option>
			<option>Provincetown, MA</option>
			<option>Springfield, MA</option>
			<option>Williamstown, MA</option>
			<option>Worcester, MA</option>
			<option>Annapolis, MD</option>
			<option>Baltimore, MD</option>
			<option>Cumberland, MD</option>
			<option>Frederick, MD</option>
			<option>Hagerstown, MD</option>
			<option>Ridge, MD</option>
			<option>Salisbury, MD</option>
			<option>Augusta, ME</option>
			<option>Bangor, ME</option>
			<option>Bar Harbor, ME</option>
			<option>Caribou, ME</option>
			<option>Dennistown, ME</option>
			<option>Dickey, ME</option>
			<option>Farmington, ME</option>
			<option>Houlton, ME</option>
			<option>Lewiston, ME</option>
			<option>Pembroke, ME</option>
			<option>Portland, ME</option>
			<option>Alpena, MI</option>
			<option>Detroit, MI</option>
			<option>Escanaba, MI</option>
			<option>Flint, MI</option>
			<option>Grand Rapids, MI</option>
			<option>Houghton, MI</option>
			<option>Jackson, MI</option>
			<option>Kalamazoo, MI</option>
			<option>Lansing, MI</option>
			<option>Mackinaw City, MI</option>
			<option>Manistee, MI</option>
			<option>Marquette, MI</option>
			<option>Menominee, MI</option>
			<option>Midland, MI</option>
			<option>Sault Ste. Marie, MI</option>
			<option>Traverse City, MI</option>
			<option>Alexandria, MN</option>
			<option>Austin, MN</option>
			<option>Bagley, MN</option>
			<option>Brainerd, MN</option>
			<option>Chisholm, MN</option>
			<option>Duluth, MN</option>
			<option>Grand Marais, MN</option>
			<option>Hallock, MN</option>
			<option>Marshall, MN</option>
			<option>Minneapolis, MN</option>
			<option>Rochester, MN</option>
			<option>Saint Cloud, MN</option>
			<option>Winona, MN</option>
			<option>Bethany, MO</option>
			<option>Cape Girardeau, MO</option>
			<option>Columbia, MO</option>
			<option>Hannibal, MO</option>
			<option>Jefferson City, MO</option>
			<option>Joplin, MO</option>
			<option>Kansas City, MO</option>
			<option>Kirksville, MO</option>
			<option>Saint Louis, MO</option>
			<option>Sedalia, MO</option>
			<option>Sikeston, MO</option>
			<option>Springfield, MO</option>
			<option>Biloxi, MS</option>
			<option>Clarksdale, MS</option>
			<option>Columbus, MS</option>
			<option>Greenville, MS</option>
			<option>Hattiesburg, MS</option>
			<option>Jackson, MS</option>
			<option>Meridian, MS</option>
			<option>Olive Branch, MS</option>
			<option>Tupelo, MS</option>
			<option>Vicksburg, MS</option>
			<option>Billings, MT</option>
			<option>Bozeman, MT</option>
			<option>Butte, MT</option>
			<option>Dillon, MT</option>
			<option>Glasgow, MT</option>
			<option>Glendive, MT</option>
			<option>Great Falls, MT</option>
			<option>Havre, MT</option>
			<option>Helena, MT</option>
			<option>Kalispell, MT</option>
			<option>Lewistown, MT</option>
			<option>Missoula, MT</option>
			<option>Plentywood, MT</option>
			<option>Shelby, MT</option>
			<option>Asheville, NC</option>
			<option>Charlotte, NC</option>
			<option>Fayetteville, NC</option>
			<option>Greensboro, NC</option>
			<option>Havelock, NC</option>
			<option>Lumberton, NC</option>
			<option>Manteo, NC</option>
			<option>Raleigh, NC</option>
			<option>Rocky Mount, NC</option>
			<option>Wilmington, NC</option>
			<option>Winston-Salem, NC</option>
			<option>Bismarck, ND</option>
			<option>Bottineau, ND</option>
			<option>Bowman, ND</option>
			<option>Cavalier, ND</option>
			<option>Dickinson, ND</option>
			<option>Fargo, ND</option>
			<option>Grand Forks, ND</option>
			<option>Jamestown, ND</option>
			<option>Linton, ND</option>
			<option>Lisbon, ND</option>
			<option>Minot, ND</option>
			<option>Rugby, ND</option>
			<option>Stanley, ND</option>
			<option>Valley City, ND</option>
			<option>Williston, ND</option>
			<option>Alliance, NE</option>
			<option>Broken Bow, NE</option>
			<option>Chadron, NE</option>
			<option>Columbus, NE</option>
			<option>Grand Island, NE</option>
			<option>Kearney, NE</option>
			<option>Lincoln, NE</option>
			<option>McCook, NE</option>
			<option>Norfolk, NE</option>
			<option>North Platte, NE</option>
			<option>O'Neill, NE</option>
			<option>Omaha, NE</option>
			<option>Scottsbluff, NE</option>
			<option>Tecumseh, NE</option>
			<option>Valentine, NE</option>
			<option>Berlin, NH</option>
			<option>Concord, NH</option>
			<option>Keene, NH</option>
			<option>Littleton, NH</option>
			<option>Manchester, NH</option>
			<option>Nashua, NH</option>
			<option>Pittsburg, NH</option>
			<option>Portsmouth, NH</option>
			<option>Rochester, NH</option>
			<option>Atlantic City, NJ</option>
			<option>Bridgeton, NJ</option>
			<option>Cherry Hill, NJ</option>
			<option>New Brunswick, NJ</option>
			<option>Newark, NJ</option>
			<option>Paterson, NJ</option>
			<option>Toms River, NJ</option>
			<option>Trenton, NJ</option>
			<option>Alamogordo, NM</option>
			<option>Albuquerque, NM</option>
			<option>Bard, NM</option>
			<option>Carlsbad, NM</option>
			<option>Clovis, NM</option>
			<option>Farmington, NM</option>
			<option>Gallup, NM</option>
			<option>Hernandez, NM</option>
			<option>Hobbs, NM</option>
			<option>Las Cruces, NM</option>
			<option>Lordsburg, NM</option>
			<option>Raton, NM</option>
			<option>Roswell, NM</option>
			<option>Austin, NV</option>
			<option>Beatty, NV</option>
			<option>Carson City, NV</option>
			<option>Elko, NV</option>
			<option>Ely, NV</option>
			<option>Hawthorne, NV</option>
			<option>Jackpot, NV</option>
			<option>Las Vegas, NV</option>
			<option>Lovelock, NV</option>
			<option>McDermitt, NV</option>
			<option>Mesquite, NV</option>
			<option>Pahrump, NV</option>
			<option>Reno, NV</option>
			<option>Tonopah, NV</option>
			<option>Warm Springs, NV</option>
			<option>Winnemucca, NV</option>
			<option>Albany, NY</option>
			<option>Binghamton, NY</option>
			<option>Bridgehampton, NY</option>
			<option>Buffalo, NY</option>
			<option>Elizabethtown, NY</option>
			<option>Garden City, NY</option>
			<option>Glen Cove, NY</option>
			<option>Jamestown, NY</option>
			<option>Lake Placid, NY</option>
			<option>Medford, NY</option>
			<option>New York, NY</option>
			<option>Rochester, NY</option>
			<option>Syracuse, NY</option>
			<option>Watertown, NY</option>
			<option>Akron, OH</option>
			<option>Canton, OH</option>
			<option>Cincinnati, OH</option>
			<option>Cleveland, OH</option>
			<option>Columbus, OH</option>
			<option>Dayton, OH</option>
			<option>Mansfield, OH</option>
			<option>Portsmouth, OH</option>
			<option>Toledo, OH</option>
			<option>Youngstown, OH</option>
			<option>Zanesville, OH</option>
			<option>Altus, OK</option>
			<option>Ardmore, OK</option>
			<option>Bartlesville, OK</option>
			<option>Boise City, OK</option>
			<option>Elk City, OK</option>
			<option>Enid, OK</option>
			<option>Hugo, OK</option>
			<option>Lawton, OK</option>
			<option>Miami, OK</option>
			<option>Norman, OK</option>
			<option>Oklahoma City, OK</option>
			<option>Stillwater, OK</option>
			<option>Tulsa, OK</option>
			<option>Astoria, OR</option>
			<option>Baker City, OR</option>
			<option>Bend, OR</option>
			<option>Coos Bay, OR</option>
			<option>Eugene, OR</option>
			<option>Gold Beach, OR</option>
			<option>Grants Pass, OR</option>
			<option>Hood River, OR</option>
			<option>Klamath Falls, OR</option>
			<option>Ontario, OR</option>
			<option>Portland, OR</option>
			<option>Allentown, PA</option>
			<option>Altoona, PA</option>
			<option>Bradford, PA</option>
			<option>Clarion, PA</option>
			<option>Erie, PA</option>
			<option>Harrisburg, PA</option>
			<option>Philadelphia, PA</option>
			<option>Pittsburgh, PA</option>
			<option>Reading, PA</option>
			<option>Scranton, PA</option>
			<option>Towanda, PA</option>
			<option>Williamsport, PA</option>
			<option>San Juan, PR</option>
			<option>Newport, RI</option>
			<option>Providence, RI</option>
			<option>Westerly, RI</option>
			<option>Woonsocket, RI</option>
			<option>Charleston, SC</option>
			<option>Columbia, SC</option>
			<option>Florence, SC</option>
			<option>Greenville, SC</option>
			<option>Greenwood, SC</option>
			<option>Myrtle Beach, SC</option>
			<option>Rock Hill, SC</option>
			<option>Spartanburg, SC</option>
			<option>Summerville, SC</option>
			<option>Sumter, SC</option>
			<option>Aberdeen, SD</option>
			<option>Brookings, SD</option>
			<option>Chamberlain, SD</option>
			<option>Hot Springs, SD</option>
			<option>Huron, SD</option>
			<option>Milbank, SD</option>
			<option>Mitchell, SD</option>
			<option>Pierre, SD</option>
			<option>Rapid City, SD</option>
			<option>Redfield, SD</option>
			<option>Sioux Falls, SD</option>
			<option>Spearfish, SD</option>
			<option>Vermillion, SD</option>
			<option>Watertown, SD</option>
			<option>Chattanooga, TN</option>
			<option>Clarksville, TN</option>
			<option>Cookeville, TN</option>
			<option>Jackson, TN</option>
			<option>Johnson City, TN</option>
			<option>Knoxville, TN</option>
			<option>Lynchburg, TN</option>
			<option>Memphis, TN</option>
			<option>Nashville, TN</option>
			<option>Abilene, TX</option>
			<option>Amarillo, TX</option>
			<option>Austin, TX</option>
			<option>Beaumont, TX</option>
			<option>Brownsville, TX</option>
			<option>Corpus Christi, TX</option>
			<option>Dallas, TX</option>
			<option>Del Rio, TX</option>
			<option>Eagle Pass, TX</option>
			<option>El Paso, TX</option>
			<option>Houston, TX</option>
			<option>Huntsville, TX</option>
			<option>Laredo, TX</option>
			<option>Longview, TX</option>
			<option>Lubbock, TX</option>
			<option>Lufkin, TX</option>
			<option>Midland, TX</option>
			<option>New Boston, TX</option>
			<option>Paris, TX</option>
			<option>San Angelo, TX</option>
			<option>San Antonio, TX</option>
			<option>Tyler, TX</option>
			<option>Waco, TX</option>
			<option>Wichita Falls, TX</option>
			<option>Cedar City, UT</option>
			<option>Kanab, UT</option>
			<option>Logan, UT</option>
			<option>Mexican Hat, UT</option>
			<option>Moab, UT</option>
			<option>Monticello, UT</option>
			<option>Price, UT</option>
			<option>Richfield, UT</option>
			<option>Saint George, UT</option>
			<option>Salt Lake City, UT</option>
			<option>Vernal, UT</option>
			<option>Wendover, UT</option>
			<option>Blacksburg, VA</option>
			<option>Charlottesville, VA</option>
			<option>Fredericksburg, VA</option>
			<option>Harrisonburg, VA</option>
			<option>Lebanon, VA</option>
			<option>Lynchburg, VA</option>
			<option>Manassas, VA</option>
			<option>Norfolk, VA</option>
			<option>Richmond, VA</option>
			<option>Roanoke, VA</option>
			<option>Staunton, VA</option>
			<option>Winchester, VA</option>
			<option>Saint John, VI</option>
			<option>Bennington, VT</option>
			<option>Brattleboro, VT</option>
			<option>Burlington, VT</option>
			<option>Montpelier, VT</option>
			<option>Newport, VT</option>
			<option>Rutland, VT</option>
			<option>Saint Albans, VT</option>
			<option>Saint Johnsbury, VT</option>
			<option>Swanton, VT</option>
			<option>Bellingham, WA</option>
			<option>Colville, WA</option>
			<option>Hoquiam, WA</option>
			<option>Mount Vernon, WA</option>
			<option>Olympia, WA</option>
			<option>Port Angeles, WA</option>
			<option>Pullman, WA</option>
			<option>Seattle, WA</option>
			<option>Spokane, WA</option>
			<option>Walla Walla, WA</option>
			<option>Wenatchee, WA</option>
			<option>Yakima, WA</option>
			<option>Ashland, WI</option>
			<option>Beloit, WI</option>
			<option>Eau Claire, WI</option>
			<option>Fond du Lac, WI</option>
			<option>Green Bay, WI</option>
			<option>Kenosha, WI</option>
			<option>La Crosse, WI</option>
			<option>Madison, WI</option>
			<option>Milwaukee, WI</option>
			<option>Oshkosh, WI</option>
			<option>Sheboygan, WI</option>
			<option>Stevens Point, WI</option>
			<option>Sturgeon Bay, WI</option>
			<option>Wausau, WI</option>
			<option>Bluefield, WV</option>
			<option>Charleston, WV</option>
			<option>Huntington, WV</option>
			<option>Parkersburg, WV</option>
			<option>Romney, WV</option>
			<option>Wheeling, WV</option>
			<option>Williamson, WV</option>
			<option>Casper, WY</option>
			<option>Cheyenne, WY</option>
			<option>Cody, WY</option>
			<option>Evanston, WY</option>
			<option>Gillette, WY</option>
			<option>Jackson, WY</option>
			<option>Laramie, WY</option>
			<option>Rawlins, WY</option>
			<option>Sheridan, WY</option>
			<option>Sundance, WY</option>
		    </optgroup>
		    <optgroup label="U.S. National Parks">
			<option>Denali NP, AK</option>
			<option>Gates of the Arctic NP, AK</option>
			<option>Glacier Bay NP, AK</option>
			<option>Katmai NP, AK</option>
			<option>Kenai Fjords NP, AK</option>
			<option>Kobuk Valley NP, AK</option>
			<option>Lake Clark NP, AK</option>
			<option>Wrangell-Saint Elias NP, AK</option>
			<option>Hot Springs NP, AR</option>
			<option>Canyon de Chelly NM, AZ</option>
			<option>Grand Canyon NP, AZ</option>
			<option>Petrified Forest NP, AZ</option>
			<option>Saguaro NP (East Unit), AZ</option>
			<option>Saguaro NP (Tucson Mountain Unit), AZ</option>
			<option>Carrizo Plain NM, CA</option>
			<option>Channel Islands NP, CA</option>
			<option>Death Valley NP (Eureka Valley), CA</option>
			<option>Death Valley NP (Furnace Creek), CA</option>
			<option>Death Valley NP (Stovepipe Wells), CA</option>
			<option>Devil's Postpile NM, CA</option>
			<option>Joshua Tree NP, CA</option>
			<option>Kings Canyon NP (Cedar Grove), CA</option>
			<option>Lassen Volcanic NP, CA</option>
			<option>Lava Beds NM, CA</option>
			<option>Pinnacles NM, CA</option>
			<option>Point Reyes NS, CA</option>
			<option>Redwood NP, CA</option>
			<option>Yosemite NP, CA</option>
			<option>Black Canyon of the Gunnison NM, CO</option>
			<option>Dinosaur NM, CO</option>
			<option>Great Sand Dunes NM, CO</option>
			<option>Mesa Verde NP, CO</option>
			<option>Rocky Mountain NP, CO</option>
			<option>White Sands NM, CO</option>
			<option>Biscayne NP, FL</option>
			<option>Dry Tortugas NP, FL</option>
			<option>Everglades NP, FL</option>
			<option>Haleakala NP, HI</option>
			<option>Hawaii Volcanoes NP, HI</option>
			<option>Prairie NP, KS</option>
			<option>Mammoth Cave NP, KY</option>
			<option>Fiske Hill NP, MA</option>
			<option>Fort Washington NP, MD</option>
			<option>Arcadia NP, ME</option>
			<option>Isle Royale NP, MI</option>
			<option>Voyageurs NP, MN</option>
			<option>Glacier NP, MT</option>
			<option>Great Smoky Mountains NP, NC</option>
			<option>Wind Cave NP, ND</option>
			<option>Washington Headquarters NP, NJ</option>
			<option>Great Basin NP, NV</option>
			<option>Crater Lake NP, OR</option>
			<option>Badlands NP, SD</option>
			<option>Big Bend NP, TX</option>
			<option>Guadalupe Mountains NP, TX</option>
			<option>Arches NP, UT</option>
			<option>Bryce Canyon NP, UT</option>
			<option>Canyonlands NP (Islands in the Sky), UT</option>
			<option>Canyonlands NP (Needles), UT</option>
			<option>Capitol Reef NP (Fruita), UT</option>
			<option>Cedar Breaks NM, UT</option>
			<option>Zion NP, UT</option>
			<option>Fort Hunt NP, VA</option>
			<option>Shenandoah NP, VA</option>
			<option>Mount Ranier NP, WA</option>
			<option>North Cascades NP, WA</option>
			<option>Olympic NP, WA</option>
			<option>Grand Teton NP, WY</option>
			<option>Yellowstone NP, WY</option>
		    </optgroup>
		    <optgroup label="Canada">
			<option>Calgary, AB</option>
			<option>Edmonton, AB</option>
			<option>Fort McMurray, AB</option>
			<option>Dawson Creek, BC</option>
			<option>Prince George, BC</option>
			<option>Prince Rupert, BC</option>
			<option>Vancouver, BC</option>
			<option>Victoria, BC</option>
			<option>Brandon, MB</option>
			<option>Churchill, MB</option>
			<option>Thompson, MB</option>
			<option>Winnipeg, MB</option>
			<option>Fredericton, NB</option>
			<option>Saint John, NB</option>
			<option>Happy Valley-Goose Bay, NL</option>
			<option>Saint John's, NL</option>
			<option>Halifax, NS</option>
			<option>Inuvik, NT</option>
			<option>Yellowknife, NT</option>
			<option>Aujuittuq (Grise Fiord), NU</option>
			<option>Iqaluit, NU</option>
			<option>Qausuittuq (Resolute Bay), NU</option>
			<option>London, ON</option>
			<option>Ottawa, ON</option>
			<option>Sault Ste. Marie, ON</option>
			<option>Sudbury, ON</option>
			<option>Thunder Bay, ON</option>
			<option>Toronto, ON</option>
			<option>Windsor, ON</option>
			<option>Charlottetown, PE</option>
			<option>Montreal, QC</option>
			<option>Quebec, QC</option>
			<option>Rimouski, QC</option>
			<option>Regina, SK</option>
			<option>Saskatoon, SK</option>
			<option>Dawson, YT</option>
			<option>Whitehorse, YT</option>
		    </optgroup>
		    <optgroup label="Canada  National Parks">
			<option>Banff NP, AB</option>
			<option>Elk Island NP, AB</option>
			<option>Jasper NP, AB</option>
			<option>Waterton Lakes NP, AB</option>
			<option>Wood Buffalo NP, AB</option>
			<option>Yoho NP, AB</option>
			<option>Glacier NP, BC</option>
			<option>Gwaii Haanas NP, BC</option>
			<option>Kootenay NP, BC</option>
			<option>Mount RevelStoke NP, BC</option>
			<option>Pacific Rim NP, BC</option>
			<option>Riding Mountain NP, MB</option>
			<option>Wapusk NP, MB</option>
			<option>Fundy NP, NB</option>
			<option>Kouchibouguac NP, NB</option>
			<option>Gros Morne NP, NL</option>
			<option>Terra Nova NP, NL</option>
			<option>Cape Breton Highlands NP, NS</option>
			<option>Kejimkujik NP, NS</option>
			<option>Aulavik NP, NT</option>
			<option>Nahanni NP, NT</option>
			<option>Tuktut Nogait NP, NT</option>
			<option>Auyuittuk NP, NU</option>
			<option>Quttinirpaaq NP, NU</option>
			<option>Bruce Peninsula NP, ON</option>
			<option>Downsview NP, ON</option>
			<option>Georgian Bay Islands NP, ON</option>
			<option>Point Pelee NP, ON</option>
			<option>Pukaskwa NP, ON</option>
			<option>Saint Lawrence Islands NP, ON</option>
			<option>Prince Edward Island NP, PE</option>
			<option>Fourillon NP, QC</option>
			<option>La Mauricie NP, QC</option>
			<option>Grasslands NP, SK</option>
			<option>Prince Albert NP, SK</option>
			<option>Ivvavik NP, YT</option>
			<option>Kluane NP, YT</option>
			<option>Vuntut NP, YT</option>
		    </optgroup>
		    <optgroup label="Mexico">
			<option>Acapulco, Mexico</option>
			<option>Aguascalientes, Mexico</option>
			<option>Cancun, Mexico</option>
			<option>Chetumal, Mexico</option>
			<option>Chihuahua, Mexico</option>
			<option>Ciudad Juarez, Mexico</option>
			<option>Culiacan, Mexico</option>
			<option>Durango, Mexico</option>
			<option>Ensenada, Mexico</option>
			<option>Guadalajara, Mexico</option>
			<option>Hermosillo, Mexico</option>
			<option>La Paz, Mexico</option>
			<option>Mazatlan, Mexico</option>
			<option>Merida, Mexico</option>
			<option>Mexico City, Mexico</option>
			<option>Monterrey, Mexico</option>
			<option>Oaxaca, Mexico</option>
			<option>San Lucas, Mexico</option>
			<option>Torreon, Mexico</option>
			<option>Villahermosa, Mexico</option>
		    </optgroup>
		    <optgroup label="Other North America">
			<option>San Jose, Costa Rica</option>
			<option>San Salvador, El Salvador</option>
			<option>Guatemala City, Guatemala</option>
			<option>Tegucigalpa, Honduras</option>
			<option>Managua, Nicaragua</option>
			<option>Panama City, Panama</option>
		    </optgroup>
		    <optgroup label="Caribbean">
			<option>Havana, Cuba</option>
			<option>Nassau, Bahamas</option>
			<option>Santo Domingo, Dominican Republic</option>
			<option>Port-au-Prince, Haiti</option>
			<option>Kingston, Jamaica</option>
		    </optgroup>
		    <optgroup label="South America">
			<option>Buenos Aires, Argentina</option>
			<option>La Paz, Bolivia</option>
			<option>Brasilia, Brazil</option>
			<option>Manaus, Brazil</option>
			<option>Recife, Brazil</option>
			<option>Rio de Janeiro, Brazil</option>
			<option>Sao Paulo, Brazil</option>
			<option>Punta Arenas, Chile</option>
			<option>Santiago, Chile</option>
			<option>Bogota, Colombia</option>
			<option>Quito, Ecuador</option>
			<option>Georgetown, Guyana</option>
			<option>Panama City, Panama</option>
			<option>Asuncion, Paraguay</option>
			<option>Lima, Peru</option>
			<option>Paramaribo, Suriname</option>
			<option>Montevideo, Uruguay</option>
			<option>Caracas, Venezuela</option>
		    </optgroup>
		    <optgroup label="Europe">
			<option>Tirana, Albania</option>
			<option>Innsbruck, Austria</option>
			<option>Salzburg, Austria</option>
			<option>Vienna, Austria</option>
			<option>Minsk, Belarus</option>
			<option>Brussels, Belgium</option>
			<option>Sarajevo, Bosnia and Herzegovina</option>
			<option>Zagreb, Croatia</option>
			<option>Prague, Czech Republic</option>
			<option>Copenhagen, Denmark</option>
			<option>Helsinki, Finland</option>
			<option>Oulu, Finland</option>
			<option>Bordeaux, France</option>
			<option>Brest, France</option>
			<option>Dijon, France</option>
			<option>Le Havre, France</option>
			<option>Lyon, France</option>
			<option>Marseille, France</option>
			<option>Orleans, France</option>
			<option>Paris, France</option>
			<option>Berlin, Germany</option>
			<option>Cologne, Germany</option>
			<option>Dresden, Germany</option>
			<option>Frankfurt, Germany</option>
			<option>Hamburg, Germany</option>
			<option>Munich, Germany</option>
			<option>Stuttgart, Germany</option>
			<option>Athens, Greece</option>
			<option>Budapest, Hungary</option>
			<option>Reykjavik, Iceland</option>
			<option>Cork, Ireland</option>
			<option>Dublin, Ireland</option>
			<option>Genoa, Italy</option>
			<option>Milan, Italy</option>
			<option>Naples, Italy</option>
			<option>Palermo, Italy</option>
			<option>Rome, Italy</option>
			<option>Turin, Italy</option>
			<option>Skopje, Macedonia</option>
			<option>Amsterdam, Netherlands</option>
			<option>Bergen, Norway</option>
			<option>Oslo, Norway</option>
			<option>Trondheim, Norway</option>
			<option>Gdansk, Poland</option>
			<option>Krakow, Poland</option>
			<option>Warsaw, Poland</option>
			<option>Wroclaw, Poland</option>
			<option>Lisbon, Portugal</option>
			<option>Bucharest, Romania</option>
			<option>Moscow, Russia</option>
			<option>Murmansk, Russia</option>
			<option>Omsk, Russia</option>
			<option>St. Petersburg, Russia</option>
			<option>Vladivostok, Russia</option>
			<option>Yakutsk, Russia</option>
			<option>Yekaterinburg, Russia</option>
			<option>Belgrade, Serbia and Montenegro</option>
			<option>Ljubljana, Slovenia</option>
			<option>Bratislava, Slovakia</option>
			<option>Barcelona, Spain</option>
			<option>Madrid, Spain</option>
			<option>Malaga, Spain</option>
			<option>Murcia, Spain</option>
			<option>Oviedo, Spain</option>
			<option>Seville, Spain</option>
			<option>Valencia, Spain</option>
			<option>Zaragoza, Spain</option>
			<option>Longyearbyen, Svalbard</option>
			<option>Goteborg, Sweden</option>
			<option>Malmo, Sweden</option>
			<option>Stockholm, Sweden</option>
			<option>Umea, Sweden</option>
			<option>Bern, Switzerland</option>
			<option>Geneva, Switzerland</option>
			<option>Zurich, Switzerland</option>
			<option>Aberdeen, United Kingdom</option>
			<option>Birmingham, United Kingdom</option>
			<option>Bristol, United Kingdom</option>
			<option>Cardiff, United Kingdom</option>
			<option>Edinburgh, United Kingdom</option>
			<option>Glasgow, United Kingdom</option>
			<option>Inverness, United Kingdom</option>
			<option>Liverpool, United Kingdom</option>
			<option>London, United Kingdom</option>
			<option>Manchester, United Kingdom</option>
			<option>Newcastle upon Tyne, United Kingdom</option>
			<option>Plymouth, United Kingdom</option>
			<option>Kiev, Ukraine</option>
		    </optgroup>
		    <optgroup label="Asia">
			<option>Kabul, Afghanistan</option>
			<option>Dhaka, Bangladesh</option>
			<option>Yangon, Burma</option>
			<option>Phnom Penh, Cambodia</option>
			<option>Beijing, China</option>
			<option>Shanghai, China</option>
			<option>Chennai, India</option>
			<option>Darjiling, India</option>
			<option>Kolkata, India</option>
			<option>Mumbai, India</option>
			<option>New Delhi, India</option>
			<option>Jakarta, Indonesia</option>
			<option>Tehran, Iran</option>
			<option>Baghdad, Iraq</option>
			<option>Jerusalem, Israel</option>
			<option>Sapporo, Japan</option>
			<option>Tokyo, Japan</option>
			<option>Amman, Jordan</option>
			<option>Seoul, Korea</option>
			<option>Beirut, Lebanon</option>
			<option>Kathmandu, Nepal</option>
			<option>Islamabad, Pakistan</option>
			<option>Karachi, Pakistan</option>
			<option>Manila, Philippines</option>
			<option>Mecca, Saudi Arabia</option>
			<option>Singapore, Singapore</option>
			<option>Damascus, Syria</option>
			<option>Taipei, Taiwan</option>
			<option>Bangkok, Thailand</option>
			<option>Lhasa, Tibet</option>
			<option>Istanbul, Turkey</option>
			<option>Nabulus, West Bank</option>
			<option>Hanoi, Vietnam</option>
		    </optgroup>
		    <optgroup label="Africa">
			<option>Algiers, Algeria</option>
			<option>Luanda, Angola</option>
			<option>Kinshasa, DRC</option>
			<option>Cairo, Egypt</option>
			<option>Addis Ababa, Ethiopia</option>
			<option>Nairobi, Kenya</option>
			<option>Monrovia, Liberia</option>
			<option>Tripoli, Libya</option>
			<option>Antananarivo, Madagascar</option>
			<option>Casablanca, Morocco</option>
			<option>Windhoek, Namibia</option>
			<option>Lagos, Nigeria</option>
			<option>Dakar, Senegal</option>
			<option>Mogadishu, Somalia</option>
			<option>Capetown, South Africa</option>
			<option>Khartoum, Sudan</option>
			<option>Dar es Salaam, Tanzania</option>
			<option>Tunis, Tunisia</option>
			<option>Kampala, Uganda</option>
		    </optgroup>
		    <optgroup label="Australia">
			<option>Adelaide, Australia</option>
			<option>Alice Springs, Australia</option>
			<option>Brisbane, Australia</option>
			<option>Canberra, Australia</option>
			<option>Darwin, Australia</option>
			<option>Hobart, Australia</option>
			<option>Melbourne, Australia</option>
			<option>Perth, Australia</option>
			<option>Sydney, Australia</option>
			<option>Townsville, Australia</option>
		    </optgroup>
		    <optgroup label="Other">
			<option>Hamilton, Bermuda</option>
			<option>Stanley, Falkland Islands</option>
			<option>Nuuk, Greenland</option>
			<option>Auckland, New Zealand</option>
			<option>Christchurch, New Zealand</option>
			<option>Grytviken, South Georgia</option>
			<option>Papeete, Tahiti</option>
		    </optgroup>
	    </select>&nbsp;

	    <input type="button" name="ListPlaces" id="stdLocListPlaces" value="List Locations"
		   title="List locations in internal database"
		   onmouseover="window.status='List all locations in the database'; return true"
		   onmouseout="window.status=''"
		   onclick="list_places()">&nbsp;

	    <input type="button" id="CheckPlaces" name="CheckPlaces" value="Check Locations"
		   style="display: none;"
		   onmouseover="window.status='Check location database for name and DST errors';
		       return true"
		   onmouseout="window.status=''"
		   onclick="check_places()">
	</td>
    </tr>
    <tr id="PlaceSearch">
	<td id="stdLocTxt03" class="left"></td>
	<td class="left" id="stdLocTxt04" colspan="3">
	    <a class="help"
	       title="Search the location database for a place matching the pattern"
	       onclick="blur(); help('SearchLocation'); return false;">
	    Search for</a>
	    <input type="text" name="search_pattern" class="LocSearch"
		   id="stdLocSearchPattern">&nbsp;

	    <input type="button" name="SearchPlaces" value="New Search"
		   id="stdLocSearchPlaces"
		   style="display: inline;"
		   onmouseover="window.status='Search location database for a location';
		       return true"
		   onmouseout="window.status=''"
		   onclick='search_places("new")'>&nbsp;

	    <input type="button" name="NextPlace" value="Next Match" disabled
		   id="stdLocNextPlace"
		   style="display: inline;"
		   onmouseover="window.status='Find next location matching pattern';
		       return true"
		   onmouseout="window.status=''"
		   onclick='search_places()'>
	</td>
    </tr>
    <tr id="stdLocTxt05" class="pad"><td colspan="4" style="border-bottom: 1px solid #ccc">&nbsp;</td></tr>
    </tbody>

	<!-- ==================== custom location ===================== -->
    <tbody id="cstmLocTxt0">
    <tr class="pad"><td colspan="4">&nbsp;</td></tr>
    <tr>
	<td id="cstmLocTxt00" class="left"><input type=radio name="loc_type" id="cstmLocType"
		   value="coord"
		   onclick='setLocTypeAttrib(); SaveState.write(form); blur()' >
        </td>
	<td class="right4" id="cstmLocTxt01"><a class=help
	    title="Specify location properties"
	    onclick="blur(); help('SpecifyProperties'); return false;"
	    >Specify:</a>
	</td>
	<!-- lat/lon lookup -->
	<!--
	<td id="cstmLocTxt02" colspan="3" style="text-align: right; width: 24em; padding-right: 2em;">
	-->
	<td id="cstmLocTxt02" colspan="2">
	<a class="help" title="Look up location properties using selected database"
	   id="LocLookupText"
	   onclick="blur(); help('LocationLookup'); return false;">
	    Look up a location using:</a>
	<select name="LocationLookup"
		id="cstmLocLookup"
		onchange='SaveState.write(form)'>
	    <optgroup label='Automatic Fill-In'>
		<option selected
		    title="GeoNames Web Services"
		    value="GeoNamesWebSvc">GeoNames Web Svc</option>
		<option
		    title="USGS GNIS XML Service"
		    value="USGS_XML_Svc">USGS GNIS XML Svc</option>
		<option
		    title="USGS GNIS Texas Water Science Center service"
		    value="USGS_TX_Svc">USGS TX Water Sci</option>
	    </optgroup>
	    <optgroup label='Lookup Only'>
		<option title="USGS Geographical Names Information System"
			value="USGS_GNIS">USGS GNIS (USA)</option>
		<option title="GeoNames"
			value="GeoNames">GeoNames</option>
		<option title="US National Geospatial-Intelligence Agency GEOnet Names Server"
			value="NGA_GEOnet">NGA GEOnet</option>
		<option title="Getty Thesaurus of Geographic Names"
			value="GettyThesaurus">Getty Thesaurus</option>
		<option title="timeanddate.com"
			value="timeanddate">timeanddate.com</option>
	    </optgroup>
	    <optgroup label='Location Map'>
		<option title="Show or find location in Google Maps"
			value="GoogleMaps">Google Maps</option>
		<option title="Show or find location in Bing Maps"
			value="BingMaps">Bing Maps</option>
	    </optgroup>
	</select>
	<input type="button" value="Go"
	       id="cstmLocLookupGo"
	       title="Look up location properties using selected database"
	       onclick="location_lookup(form.LocationLookup.value, form.place_name.value)">
	</td>
    </tr>
    </tbody>
	<!-- ==================== custom location properties ===================== -->
    <tbody id="cstmLocTxt1">
    <tr id="cstmLocTxt10">
	<td class="left"></td>
	<!-- Name -->
	<td class="left" colspan="3"><a class=help
	    title="Enter a name (<place>, <country>|<state>|<province>)"
	    onclick="blur(); help('CustomName'); return false;"
	    >N<!-- disable Google AutoFill -->ame:</a>

<!-- FIXME -->
    <!-- selectListAnchor span has relative positioning so that it can anchor resultsList -->
    <span class="selectListAnchor">
	    <input type="text" name="place_name" class="LocName"
		   id="cstmLocPlaceName"
	      onclick="GIS.closeSelectList();"
	      onblur="GIS.closeSelectList();"
		   onchange='fix_name(this);SaveState.write(form)' >&nbsp;

	    <span class="selectList" id="selectListElement"></span>
    </span>

	    <input type="button" name="CopyPlace" value="Copy Selected Location"
		   id="cstmLocCopyPlace"
		   title="Copy properties of location selected above"
		   onmouseover="window.status='Copy properties for selected Place to Custom Location';
		       return true;"
		   onmouseout="window.status=''; return true;"
		   onclick="copy_place(SunMoonCalc)">&nbsp;
	    <input type="button" name="ClearCustom" value="Clear"
		   id="cstmLocClearCustom"
		   title="Clear specified location properties"
		   onmouseover="window.status='Clear specified location properties';
		       return true;"
		   onmouseout="window.status=''; return true;"
		   onclick="clear_custom_location(SunMoonCalc)">&nbsp;
	</td>
    </tr>
    <tr id="cstmLocTxt11">
	<td class="left"></td>
	    <!-- Latitude -->
	<td class="left"><a class=help
	    title="Latitude in dd:mm:ss or degrees"
	    onclick="blur(); help('Latitude'); return false;"
	    >Latitude:</a></td>
	<td><input type="text" name="latitude" value="0" class="LatLon"
		   id="cstmLocLatitude"
		   onchange='check_latitude(form, this);SaveState.write(form)'>
	    <select name="lat_sign"
		    id="cstmLocLatSign"
		    onchange='SaveState.write(form)' >
		<option value=1 selected>N</option>
		<option value=-1>S</option>
	    </select>
	</td>
	<!-- Time Zone: positive values for west longitudes -->
	<td class="right" colspan="1"><a class=help
	    title="Select time zone for location"
	    onclick="blur(); help('TimeZone'); return false;"
	>&nbsp;&nbsp;Time Zone:&nbsp;</a>
	<select name="timezone"
		id="cstmLocTimeZone"
		onchange='SaveState.write(form)'>
										<!-- index -->
	    <option value="" selected>(calculate from longitude)</option>	<!--  0 -->
	    <option value=-12>UTC&minus;12</option>				<!--  1 -->
	    <option value=-11>UTC&minus;11&nbsp;(Samoa)</option>		<!--  2 -->
	    <option value=-10>UTC&minus;10&nbsp;(Hawaii-Aleutian)</option>	<!--  3 -->
	    <option value=-9.5>UTC&minus;9:30</option>				<!--  4 -->
	    <option value=-9>UTC&minus;9 &nbsp;&nbsp;(Alaska)</option>		<!--  5 -->
	    <option value=-8>UTC&minus;8 &nbsp;&nbsp;(Pacific)</option>		<!--  6 -->
	    <option value=-7>UTC&minus;7 &nbsp;&nbsp;(Mountain)</option>	<!--  7 -->
	    <option value=-6>UTC&minus;6 &nbsp;&nbsp;(Central)</option>		<!--  8 -->
	    <option value=-5>UTC&minus;5 &nbsp;&nbsp;(Eastern)</option>		<!--  9 -->
	    <option value=-4.5>UTC&minus;4:30</option>				<!-- 10 -->
	    <option value=-4>UTC&minus;4 &nbsp;&nbsp;(Atlantic)</option>	<!-- 11 -->
	    <option value=-3.5>UTC&minus;3:30&nbsp;(Newfoundland)</option>	<!-- 12 -->
	    <option value=-3>UTC&minus;3 &nbsp;&nbsp;(Greenland)</option>	<!-- 13 -->
	    <option value=-2>UTC&minus;2</option>				<!-- 14 -->
	    <option value=-1>UTC&minus;1</option>				<!-- 15 -->
	    <option value=0>UTC &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(GMT)</option><!-- 16 -->
	    <option value=1>UTC+1</option>					<!-- 17 -->
	    <option value=2>UTC+2</option>					<!-- 18 -->
	    <option value=3>UTC+3</option>					<!-- 19 -->
	    <option value=3.5>UTC+3:30</option>					<!-- 20 -->
	    <option value=4>UTC+4</option>					<!-- 21 -->
	    <option value=4.5>UTC+4:30</option>					<!-- 22 -->
	    <option value=5>UTC+5</option>					<!-- 23 -->
	    <option value=5.5>UTC+5:30</option>					<!-- 24 -->
	    <option value=5.75>UTC+5:45</option>				<!-- 25 -->
	    <option value=6>UTC+6</option>					<!-- 26 -->
	    <option value=6.5>UTC+6:30</option>					<!-- 27 -->
	    <option value=7>UTC+7</option>					<!-- 28 -->
	    <option value=8>UTC+8</option>					<!-- 29 -->
	    <option value=8.75>UTC+8:45</option>				<!-- 30 -->
	    <option value=9>UTC+9</option>					<!-- 31 -->
	    <option value=9.5>UTC+9:30</option>					<!-- 32 -->
	    <option value=10>UTC+10</option>					<!-- 33 -->
	    <option value=10.5>UTC+10:30</option>				<!-- 34 -->
	    <option value=11>UTC+11</option>					<!-- 35 -->
	    <option value=11.5>UTC+11:30</option>				<!-- 36 -->
	    <option value=12>UTC+12</option>					<!-- 37 -->
	    <option value=12.75>UTC+12:45</option>				<!-- 38 -->
	    <option value=13>UTC+13</option>					<!-- 39 -->
	    <option value=14>UTC+14</option>					<!-- 40 -->

	</select>
	</td>
    </tr>
    <tr id="cstmLocTxt12">
	<td class="left"></td>
	    <!-- Longitude -->
	<td class="left"><a class=help
	    title="Longitude in dd:mm:ss or degrees"
	    onclick="blur(); help('Longitude'); return false;"
	    >Longitude:</a>
	</td>
	<td><input type="text" name="longitude" value="0" class="LatLon"
		   id="cstmLocLongitude"
		   onchange='check_longitude(form, this);SaveState.write(form)'>
	    <select name="long_sign"
		   id="cstmLocLongSign"
		   onchange='SaveState.write(form)' >
		<option value=1>E</option>
		<option value=-1 selected>W</option>
	    </select>
	</td>
	    <!-- Uses Daylight Time? -->
	<td class="right" colspan="1">
	    <a class=help
		title="Specify whether location uses daylight saving time"
		onclick="blur(); help('UsesDaylightTime'); return false;">
	    &nbsp;&nbsp;Uses Daylight Time?&nbsp;</a>
	    <select name="uses_dst"
		    id="cstmLocUsesDST"
		    onchange='SaveState.write(form)'>
		<option value=0 selected>No</option>
		<option value=1>Yes</option>
	    </select>
	</td>
    </tr>
    <tr id="cstmLocTxt13">
	<td class="left"></td>
	    <!-- Elevation -->
	<td class="left"><a class=help
	    title="Elevation above sea level"
	    onclick="blur(); help('Elevation'); return false;"
	    >Elevation:</a>
	</td>
	<td><input type="text" name="elevation" value="0" class="elevation"
		   id="cstmLocElevation"
		   onchange='check_elevation(this);SaveState.write(form)'>
	    <!-- can be changed to m via User Preferences -->
	    <span id="ElevUnits">ft</span>
	</td>
	<td colspan="1" style="text-align: right; padding-right: 0.5em;">
	</td>
    </tr>
    <tr id="cstmLocTxt14" class="pad"><td colspan="4">&nbsp;</td></tr>
    </tbody>
	<!-- ============== observer height and weather ================ -->
    <tbody>
    <tr class="pad"><td style="border-top: 1px solid #777;" colspan="4">&nbsp;</td></tr>
    <tr>
	    <!-- Height above Horizon -->
	<td class="left" colspan="2" ><a class=help
	    title="Height above Horizon"
	    onclick="blur(); help('HeightAboveHorizon'); return false;"
	    >Height Above Horizon:&nbsp;</a>
	</td>
	<td><Input type=text class="height" name="height" value=0
		   onchange='check_height(form, this);SaveState.write(form)'>
	    <!-- can be changed to m via User Preferences -->
	    <span id="HeightUnits">ft</span>
	</td>
       <td class="left" colspan="1">
	<!-- weather -->
	<a class="help" title="Get a weather forecast for the selected location"
	   onclick="blur(); help('WeatherLookup'); return false;">
	    Weather:</a>
	<select name="WeatherLookup" onchange='SaveState.write(form)'>
	    <option selected>US National Weather Service</option>
	    <option>Weather Underground</option>
	    <option>BBC Weather</option>
	</select>
	<input type="button" value="Go"
	       onclick="weather_lookup(form.WeatherLookup.selectedIndex)">&nbsp;
       </td>
    </tr>
    <tr class="pad"><td colspan="4">&nbsp;</td></tr>
    </tbody>
    </table>

    <!--*****************************************************************-->
    <!--                          show rise/set times                    -->
    <!--*****************************************************************-->
    <h2 id="calcTimesHeading">
	<input type=radio name="calc_type" id="calcTimesCalcType" checked
	       onclick='SaveState.write(form); setCalcTypeAttrib(); blur()'>
	<a class="help" title="Show Sun and Moon rise and set times for specified dates"
	   onclick="blur(); help('CalcRiseSet'); return false;">
	   Rise and Set Times</a>&nbsp;&nbsp;&nbsp;&nbsp;
    </h2>

    <table id="calcTimesTab">
    <tr class="pad"><td colspan="3">&nbsp;</td></tr>
    <tr>
	<!--============== Start Date =======================-->
	<td class="left" colspan="2"><a class=help
	    title="Beginning date for rise/set calculations"
	    onclick="blur(); help('StartDate'); return false;"
	    >Start Date:</a></td>
	<td class="right">
	    <select name="StartDay"
	    id="calcTimesStartDay"
		    onblur='check_start_date(SunMoonCalc)'>
		<option>1</option>
		<option>2</option>
		<option>3</option>
		<option>4</option>
		<option>5</option>
		<option>6</option>
		<option>7</option>
		<option>8</option>
		<option>9</option>
		<option>10</option>
		<option>11</option>
		<option>12</option>
		<option>13</option>
		<option>14</option>
		<option>15</option>
		<option>16</option>
		<option>17</option>
		<option>18</option>
		<option>19</option>
		<option>20</option>
		<option>21</option>
		<option>22</option>
		<option>23</option>
		<option>24</option>
		<option>25</option>
		<option>26</option>
		<option>27</option>
		<option>28</option>
		<option>29</option>
		<option>30</option>
		<option>31</option>
	    </select>
	    <select name="StartMonth" 
		id="calcTimesStartMonth"
		    onblur='check_start_date(SunMoonCalc)'>
		<option value=0 selected>January</option>
		<option value=1>February</option>
		<option value=2>March</option>
		<option value=3>April</option>
		<option value=4>May</option>
		<option value=5>June</option>
		<option value=6>July</option>
		<option value=7>August</option>
		<option value=8>September</option>
		<option value=9>October</option>
		<option value=10>November</option>
		<option value=11>December</option>
	    </select>
		   <!-- onblur='check_year(this); check_start_date(SunMoonCalc)'> -->
	    <input type="text" name="StartYear" class="DateYear"
		   id="calcTimesStartYear"
		   onblur='check_start_date(SunMoonCalc)'>
	    <input type="button" name="CopyPositionsDate" value="Copy Positions Date"
		   id="calcTimesCopyPositionsDate"
		   style="visibility: hidden;"
		   onmouseover="window.status='Copy positions Date to Start Date'; return true;"
		   onmouseout="window.status=''; return true;"
		   onclick="copy_positions_date(SunMoonCalc)">
	    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</td>
    </tr>
	<!--============== End Date =======================-->
    <tr>
	<!--
	    check_end_date(): assume the user doesn't want to change the
	    start date when clicking the End Date radio button
	-->
	<td class="left"><input type=radio name="end_date" value="end" checked
		    id="calcTimesEndTypeDate"
		    onclick='enable_input(this); check_end_date(form, "start")'>
	</td>
	<td><a class=help
	    title="Show rise/set times from Start Date until End Date"
	    onclick="blur(); help('EndDate'); return false;"
	    >End Date:</a>
	</td>
	<td class="right">
	    <select name="EndDay"
		    id="calcTimesEndDay"
		    onfocus ='end_date[0].checked=true;enable_input(end_date[0])'
		    onblur='check_end_date(SunMoonCalc, "end")'>
		<option>1</option>
		<option>2</option>
		<option>3</option>
		<option>4</option>
		<option>5</option>
		<option>6</option>
		<option>7</option>
		<option>8</option>
		<option>9</option>
		<option>10</option>
		<option>11</option>
		<option>12</option>
		<option>13</option>
		<option>14</option>
		<option>15</option>
		<option>16</option>
		<option>17</option>
		<option>18</option>
		<option>19</option>
		<option>20</option>
		<option>21</option>
		<option>22</option>
		<option>23</option>
		<option>24</option>
		<option>25</option>
		<option>26</option>
		<option>27</option>
		<option>28</option>
		<option>29</option>
		<option>30</option>
		<option>31</option>
	    </select>
	    <select name="EndMonth"
		    id="calcTimesEndMonth"
		    onfocus ='end_date[0].checked=true;enable_input(end_date[0])'
		    onblur='check_end_date(SunMoonCalc, "end")'>
		<option value=0 selected>January</option>
		<option value=1>February</option>
		<option value=2>March</option>
		<option value=3>April</option>
		<option value=4>May</option>
		<option value=5>June</option>
		<option value=6>July</option>
		<option value=7>August</option>
		<option value=8>September</option>
		<option value=9>October</option>
		<option value=10>November</option>
		<option value=11>December</option>
	    </select>
	    <input type="text" name="EndYear" class="DateYear"
		   id="calcTimesEndYear"
		   onfocus ='end_date[0].checked=true;enable_input(end_date[0])'
		   onblur='check_end_date(SunMoonCalc, "end")'>
	    <input type="button" name="CopyStartDate" value="Copy Start Date"
		   id="calcTimesCopyStartDate"
		   style="visibility: hidden;"
		   onmouseover="window.status='Copy Start Date to End Date'; return true;"
		   onmouseout="window.status=''; return true;"
		   onclick="copy_start_date_to_end(SunMoonCalc);
			   end_date[0].checked=true; enable_input(form.end_date[0])">
	     <br>
	</td>
    </tr>
    <tr>
	<!--============== Date Offset =======================-->
	<td class="left"><input type=radio name="end_date" value="offset"
	            id="calcTimesEndTypeOffset"
		    onclick='enable_input(this);check_date_offset(form)' >
	</td>
	<td class="right" colspan="2"><a class=help
	    title="Show rise/set times from Start Date until Date Offset after Start Date"
	    onclick="blur(); help('DateOffset'); return false;"
	    >Date Offset:</a>
	    <input type="text" name="DateOffset" value=1 class="DateOffset"
	           id="calcTimesDateOffset"
		   onfocus='end_date[1].checked=true;enable_input(end_date[1])'
		   onblur='check_date_offset(form)'>
	    <select name="DateOffsetUnits"
	        id="calcTimesDateOffsetUnits"
		onfocus='end_date[1].checked=true;enable_input(end_date[1])'
	        onchange='check_date_offset(form)'>
		<option value=1 selected>days</option>
		<option value=7>weeks</option>
		<option value=30>months (30 day)</option>
		<option value=30.4375>months (1/12 year)</option>
		<option value=365.25>years</option>
	    </select> after Start
	</td>
    </tr>
    <tr>
	<!--============== Date Interval =======================-->
	<td class="both" colspan="3"><a class=help
	    title="Interval between rise/set calculations"
	    onclick="blur(); help('DateInterval'); return false;"
	    >Date Interval:</a>
		   <!-- FIXME & main JS -->
	    <input type="text" name="DateStep" value=1 class="DateStep"
		   id="calcTimesDateInterval"
		   onblur='check_date_step(this, form.DateIntervalUnits)'>
	    <select name="DateIntervalUnits"
		    id="calcTimesDateIntervalUnits"
		    onchange ='check_date_step(form.DateStep, this)'>
		<option value=1 selected>days</option>
		<option value=7>weeks</option>
		<option value=30>months (30 day)</option>
		<option value=30.4375>months (1/12 year)</option>
		<option value=365.25>years</option>
	    </select>
	    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	    <input type="button" name="RiseSetCriteria"
		    id="calcTimesRiseSetCriteria"
		    value="Rise/Set Criteria..."
		    title="Find dates on which the Sun or Moon meet specified criteria for altitude, azimuth, and phase"
		    onmouseover="window.status='Open Az/Alt Ranges dialog'; return true;"
		    onmouseout="window.status=''; return true;"
		   onclick="get_rs_criteria()">
	</td>
    </tr>
    <tr class="pad"><td colspan="3">&nbsp;</td></tr>
    </table>


    <!--*****************************************************************-->
    <!--                      show Sun and Moon positions                -->
    <!--*****************************************************************-->
    <h2 id="calcPosHeading">
	<input type=radio name="calc_type" id="calcPosCalcType"
	       onclick='SaveState.write(form); setCalcTypeAttrib(); blur()'>
	<a class="help" title="Show Sun and Moon positions at specified times"
	   onclick="blur(); help('CalcPositions'); return false;">
	Sun and Moon Positions</a>
    </h2>
    <table id="calcPosTab">
    <tr class="pad"><td colspan="5">&nbsp;</td></tr>
    <tr>
	<!--============== Date =======================-->
	 <td class="left" colspan="5"><a class=help
	    title="Date on which to show positions"
	    onclick="blur(); help('PositionsDate'); return false;"
	    >Date:</a>
	    <select name="CalcDay"
		    id="calcPosCalcDay"
		    onblur='check_calc_date(SunMoonCalc)'>
		<option>1</option>
		<option>2</option>
		<option>3</option>
		<option>4</option>
		<option>5</option>
		<option>6</option>
		<option>7</option>
		<option>8</option>
		<option>9</option>
		<option>10</option>
		<option>11</option>
		<option>12</option>
		<option>13</option>
		<option>14</option>
		<option>15</option>
		<option>16</option>
		<option>17</option>
		<option>18</option>
		<option>19</option>
		<option>20</option>
		<option>21</option>
		<option>22</option>
		<option>23</option>
		<option>24</option>
		<option>25</option>
		<option>26</option>
		<option>27</option>
		<option>28</option>
		<option>29</option>
		<option>30</option>
		<option>31</option>
	    </select>
	    <select name="CalcMonth"
		    id="calcPosCalcMonth"
		    onblur='check_calc_date(SunMoonCalc)'>
		<option value=0 selected>January</option>
		<option value=1>February</option>
		<option value=2>March</option>
		<option value=3>April</option>
		<option value=4>May</option>
		<option value=5>June</option>
		<option value=6>July</option>
		<option value=7>August</option>
		<option value=8>September</option>
		<option value=9>October</option>
		<option value=10>November</option>
		<option value=11>December</option>
	    </select>
	    <input type="text" name="CalcYear" class="DateYear"
		   id="calcPosCalcYear"
		   onblur='check_calc_date(SunMoonCalc)'>

	    <!-- 1-day date increment -->
	    <input type="button" name="DayDecrement" value="&minus; 1 day"
		   id="calcPosDayDecrement"
		   onmouseover="window.status='Decrement calculation Date'; return true;"
		   onmouseout="window.status=''; return true;"
		   onclick="increment_calc_date(SunMoonCalc, -1)">
	    <input type="button" name="DayIncrement" value="+ 1 day"
		   id="calcPosDayIncrement"
		   onmouseover="window.status='Increment calculation Date'; return true;"
		   onmouseout="window.status=''; return true;"
		   onclick="increment_calc_date(SunMoonCalc, 1)">&nbsp;

	    <input type="button" name="PosCopyStartDate" value="Copy Start Date"
		   id="calcPosCopyStartDate"
		   style="visibility: hidden;"
		   onmouseover="window.status='Copy Start Date to positions Date'; return true;"
		   onmouseout="window.status=''; return true;"
		   onclick="copy_start_date(SunMoonCalc)">&nbsp;
	</td>
    </tr>
    <tr>
	<!--============ Start Time ===================-->
	<td class="left" colspan="2"><a class=help
	    title="Beginning time for position calculations"
	    onclick="blur(); help('StartTime'); return false;"
	    >Start Time:</a> &nbsp;&nbsp;&nbsp;
	</td>
	<td>
	    <!--============ start event ==============-->
	    <input type=radio name="time_start_type" value="select" checked
		   onclick='enable_input(this)'
		   id="calcPosStartTypeEvent">
	</td>
	<td class="right">
	    <!-- time offset to start event -->
	    <input type=text name="StartEventOffset" class="TimeOffset" value=0
		     id="calcPosStartEventOffset"
		     onfocus ='time_start_type[0].checked=true;enable_input(time_start_type[0])'
		     onblur='check_event_time_offset(this, "start")'
		> min

	    <select name="StartEventOffsetSign"
		     id="calcPosStartEventOffsetSign"
		     onfocus ='time_start_type[0].checked=true;enable_input(time_start_type[0])'>
		     <option selected>before</option>
		     <option>after</option>
	    </select>
	    <!-- start event type -->
	    <select name="StartEvent"
		    id="calcPosStartEvent"
		    onfocus ='time_start_type[0].checked=true;enable_input(time_start_type[0])'
	            onblur='check_start_event(SunMoonCalc)'>
		<option>Dawn</option>
		<option selected>Sunrise</option>
		<option>Sun Transit</option>
		<option>Sunset</option>
		<option>Dusk</option>
		<option>Moonrise</option>
		<option>Moon Transit</option>
		<option>Moonset</option>
	    </select>&nbsp;&nbsp;
	</td>
	<td class="right">
	    <!--========== specified start time ==========-->
	    <input type=radio name="time_start_type" value="specify"
		   onclick='enable_input(this)'
		   id="calcPosStartTypeTime">
	    <input type="text" name="StartTime" class="TimeSpec" value = "00:00"
		   id="calcPosStartTime"
		   onfocus ='time_start_type[1].checked=true;enable_input(time_start_type[1])'
		   onblur='check_start_time(this)'>
		   <span id="TimeTag1">local time</span>
	</td>
    </tr>
    <tr>
	<!--============ End Time ===================-->
	<td class="left"><input type=radio name="end_time" id="calcPosEndTypeEnd"
				value="end" checked
				onclick='enable_input(this)'></td>
	<td><a class=help
	    title="Show positions from Start Time until End Time"
	    onclick="blur(); help('EndTime'); return false;">End Time:</a></td>
	<td>
	    <!--========== end event ================-->
	    <input type=radio name="time_end_type" value="select" checked
		   id="calcPosEndTimeEvent"
		   onclick ='end_time[0].checked=true;enable_input(end_time[0])'>
        </td>
	<td class="right">
	    <!-- time offset to end event -->
	    <input type=text name="EndEventOffset" class="TimeOffset" value=0
		     id="calcPosEndEventOffset"
		     onfocus ='end_time[0].checked=true;
		               time_end_type[0].checked=true
			       enable_input(end_time[0])'
		     onblur='check_event_time_offset(this, "end")'
		> min
	    <select name="EndEventOffsetSign"
		     id="calcPosEndEventOffsetSign"
		     onfocus ='end_time[0].checked=true;
		               time_end_type[0].checked=true;
			       enable_input(end_time[0])'>
		 <option>before</option>
		 <option selected >after</option>
	    </select>
	    <!-- end event type -->
	    <select name="EndEvent"
		    id="calcPosEndEvent"
		    onfocus ='end_time[0].checked=true;
		              time_end_type[0].checked=true;
			      enable_input(end_time[0])'
	            onblur='check_end_event(SunMoonCalc)'>
		<option>Dawn</option>
		<option>Sunrise</option>
		<option>Sun Transit</option>
		<option selected>Sunset</option>
		<option>Dusk</option>
		<option>Moonrise</option>
		<option>Moon Transit</option>
		<option>Moonset</option>
	    </select>&nbsp;&nbsp;
	</td>
	<td class="right">
	    <!--========= specified end time ============-->
	    <input type=radio name="time_end_type" value="specify"
		   onclick='enable_input(this)'
		   id="calcPosEndTimeTime">
	    <input type="text" name="EndTime" class="TimeSpec" value = "24:00"
		   id="calcPosEndTime"
		   onfocus ='end_time[0].checked=true;
		             time_end_type[1].checked=true;
			     enable_input(end_time[0])'
		   onblur='check_end_time(this)'>
		   <span id="TimeTag2">local time</span>
	</td>
    </tr>
    <tr>
	<!--============ Time Offset ===================-->
	<td class="left"><input type=radio name="end_time" value="offset"
		   id="calcPosEndTypeOffset" 
		   onclick='enable_input(this)'></td>
	<td colspan="2"><a class=help
	    title="Show positions from Start Time until Time Offset after Start Time"
	    onclick="blur(); help('TimeOffset'); return false;"
	>Time Offset:</a></td>
	<td colspan="2" class="right">
	    <input type="text" name="TimeOffset" value=1 class="TimeOffset"
		   id="calcPosTimeOffset"
		   onfocus ='end_time[1].checked=true;enable_input(end_time[1])'
		   onblur='check_time_offset(SunMoonCalc)'>
	    <select name="TimeOffsetUnits"
		    id="calcPosTimeOffsetUnits"
		    onfocus ='end_time[1].checked=true;enable_input(end_time[1])'
		    onchange='check_time_offset(SunMoonCalc)'>
		<option value=1 selected>hours</option>
		<option value=60>minutes</option>
	    </select> after Start
	</td>
    </tr>
    <tr>
	<!--============ Time Interval ===================-->
	<td class="left" colspan="5"><a class=help
	    title="Time interval between calculations"
	    onclick="blur(); help('TimeInterval'); return false;"> Time Interval:</a>
	    <select name="TimeStep" id="calcPosTimeInterval">
		<!--
		    as of 8 July 2015, only Firefox and Chrome recognize numsp;
		    only Firefox, Chrome, and IE recognize ensp
		-->
		<option value=1>&ensp;1 minute</option>
		<option value=2>&ensp;2 minutes</option>
		<option value=5>&ensp;5 minutes</option>
		<option value=10>10 minutes</option>
		<option value=15>15 minutes</option>
		<option value=20>20 minutes</option>
		<option value=30 selected>30 minutes</option>
		<option value=60>1 hour</option>
	    </select>
	</td>
    </tr>
    <tr class="pad"><td colspan="5">&nbsp;</td></tr>
    </table>

    <br>
    <!-- ************************* buttons ******************************* -->

    <!-- Display and Print -->
    <input type="button" name="Display" value="Display"
	   title="Show rise/set times or positions"
	   onmouseover="window.status='Show rise/set times or positions'; return true;"
	   onmouseout="window.status=''; return true;"
	   onclick="calculate('display')" >&nbsp;
    <input type="button" name="Print" value="Print"
	   title="Print rise/set times or positions"
	   onmouseover="window.status='Print rise/set times or positions'; return true;"
	   onmouseout="window.status=''; return true;"
	   onclick="calculate('print')" >&emsp;&emsp;

    <!-- Today and Reset -->
    <input type="button" name="SetCurrentDate" value="Today"
	   title="Set Start Date, End Date, and positions Date to today's date"
	   onmouseover="window.status='Set Start Date, End Date, and positions Date to current date';
	       return true;"
	   onmouseout="window.status=''; return true;"
	   onclick="reset_date(SunMoonCalc)">&nbsp;
    <input type="button" name="Reset" value="Reset"
	   title="Reset all values to default"
	   onmouseover="window.status='Reset all values to default'; return true;"
	   onmouseout="window.status=''; return true;"
	   onclick="reset_form(SunMoonCalc)" >&emsp;&emsp;

    <!-- Az/Alt Tool and TPE -->
    <input type="button" name="AzAltTool" value="Az/Alt Tool"
	   id="locAzAltTool"
	   title="Find azimuth and altitude of natural and man-made features"
	   onmouseover="window.status='Google Maps az/alt tool';
	       return true;"
	   onmouseout="window.status=''; return true;"
	   onclick="az_alt_tool();">&nbsp;
    <input type="button" name="RunTPE" value="TPE"
	   id="runTPE"
	   title="Run The Photographer's Ephemeris Web app"
	   onmouseover="window.status='Run The Photographer&rsquo;s Ephemeris Web app'; return true;"
	   onmouseout="window.status=''; return true;"
	   onclick="runPhotoEphemeris()">

</form>
<p>
&nbsp;&copy; 1998&ndash;2016 <a href="mailto:jeff_conrad@msn.com">Jeff Conrad</a>.
&nbsp;Hosted by <a href = "/">largeformatphotography.info</a>
&nbsp;<a href="http://www.largeformatphotography.info/forum/showthread.php?t=14717">View/Add Comments</a>
</p>
</body>
</html>
